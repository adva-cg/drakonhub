function Editor(
	render,
	persistence,
	items,
	translate,
	userId
) {

var tr = translate

var self = this;

var Items = items;

var RoundedRadius = 8

var gDragStartItem = null
var gDragItems = []
var gFreeBuilders = {}
var gMoveAllPos = null
var gMoveAllPrim = null
var gShouldMoveAll = false
var gNoLink = Utils.listToSet([
	"junction",
	"vertical",
	"horizontal",
	"f_line",
	"f_more",
	"f_label",
	"duration",
	"loopbegin",
	"loopend",
	"ctrlStart",
	"ctrlEnd",
	"pause",
	"timer",
	"address",
	"gdur",
	"end",
	"f_cloud",
	"f_ptr_left",
	"f_ptr_right"
])

var gUserSettings = {}

// Working data
this.readonly = false
this.render = render;
this.canvas = new CanvasCache(render);
this.storage = new Storage(persistence);
this.undo = new Undo();
this.persistence = persistence;
this.grips = [];




var gFormatNames = [
  "font",
  "align",
  "padding",
  "lineColor",
  "lineThickness",
  "textColor",
  "fillColor",
  "secondaryColor",
  "shadow",
  "lineStyle",
  "arrowStart",
  "arrowEnd"
]

var gNonCopiableFields = {
  tb: true,
  primitives: true
}

// Public methods

this.renameDiagram = renameDiagram
this.buildTextBoxes = buildTextBoxes
this.setReadonly = setReadonly
this.findVisualItem = findVisualItem;
this.startVisualDrag = startVisualDrag;
this.visualDrag = visualDrag;
this.endVisualDrag = endVisualDrag;
this.findSocket = findSocket;
this.fireSocket = fireSocket;
this.darkenSocket = darkenSocket;
this.clickSocket = clickSocket;

this.loadDiagram = loadDiagram;
this.createDiagram = createDiagram;
this.diagramToJson = diagramToJson;
this.autoSizeIcons = autoSizeIcons;

this.hit = hit;
this.setCallback = setCallback;

this.canEditText = canEditText;
this.startEditText = startEditText;
this.startEditTextAt = startEditTextAt;
this.measureDiagram = measureDiagram;
this.getIconCount = getIconCount;

this.showInsertionSockets = showInsertionSockets;
this.performUndo = performUndo;
this.performRedo = performRedo;
this.clearUndo = clearUndo;
this.toggleSilhouette = toggleSilhouette;
this.drawToOtherRender = drawToOtherRender;
this.addParameters = addParameters;
this.drawToOtherRender = drawToOtherRender;
this.mouseClick = mouseClick;
this.buildBlockMenu = buildBlockMenu;
this.deselect = deselect;
this.blockSelect = blockSelect;
this.beginBlockSelect = beginBlockSelect;
this.isSelected = isSelected;
this.deleteSelection = deleteSelection;

this.redraw = redraw;

this.setItemWidth = setItemWidth;
this.buildMenuAt = buildMenuAt;
this.insertFreeItem = insertFreeItem
this.setFreeItemSize = setFreeItemSize
this.moveHandle = moveHandle
this.saveHandlePos = saveHandlePos
this.getDiagramAsItems = getDiagramAsItems
this.setBackground = setBackground
this.setFormat = setFormat
this.getFormat = getFormat
this.getItemRect = getItemRect
this.getFonts = getFonts
this.getFont = getFont
this.clearFormat = clearFormat
this.getSelection = getSelection
this.copy = copy
this.cut = cut
this.paste = paste
this.selectAll = selectAll
this.findDraggable = findDraggable
this.setContent = setContent
this.setUserSettings = setUserSettings
this.startEdit = startEdit

this.arrowUp = arrowUp
this.arrowDown = arrowDown
this.arrowLeft = arrowLeft
this.arrowRight = arrowRight
this.getItem = getItem
this.selectOneItem = selectOneItem
this.toggleTreeType = toggleTreeType
this.getFontsForItems = getFontsForItems

var Callbacks = {};

var gTransplants = {};
gTransplants.leftInnerLine = leftInnerLine;
gTransplants.leftInnerLineTs = leftInnerLineTs;
gTransplants.leftInnerLineEx = leftInnerLineEx;
gTransplants.leftOuterCorner = leftOuterCorner;
gTransplants.leftInnerCorner = leftInnerCorner;
gTransplants.topOuterCorner = topOuterCorner;
gTransplants.topInnerCorner = topInnerCorner;
gTransplants.createCycle = createCycle;
gTransplants.onOuterFloor = onOuterFloor;
gTransplants.onInnerFloor = onInnerFloor;
gTransplants.rightLine = rightLine;
gTransplants.leftOuterLine = leftOuterLine;
gTransplants.leftOuterLineTs = leftOuterLineTs;
gTransplants.rightCorner = rightCorner;
gTransplants.onOuterSilFloor = onOuterSilFloor;
gTransplants.leftOuterCornerSil = leftOuterCornerSil;
gTransplants.shortCycleDown = shortCycleDown;
gTransplants.leftOuterCornerTs = leftOuterCornerTs;



// Autogenerated with DRAKON Editor 1.33


function ActionInfo(name, args) {
    this.name = name;
    this.args = args;
}

function CanvasCache(render) {
    this.graph = new Utils.Manhattan()
    this.free = new Utils.SortedSet()
    this.render = render
    this.sockets = []
    this.pgraph = createPhysicalGraph(
    	this.graph,
    	render
    )
}

function Command(type, table, id, action) {
    this.type = type;
    this.table = table;
    this.id = id;
    this.fields = action || {};
    this.undo = null;
}

function Draggable(id, type, dims) {
    this.id = id;
    this.type = type;
    this.dims = dims;
}

function Grip(id, type, dims, box, touchBox) {
    this.id = id;
    this.type = type;
    this.dims = dims;
    this.box = box;
    this.touchBox = touchBox;
}

function Guide(edge, min, max) {
    this.edge = edge
    this.min = min
    this.max = max
    this.found = false
}

function MinDistFinder(referenceItem, itemId, criteria) {
    this.check = MinDistFinder_check
    this.referenceItem = referenceItem
    this.itemId = itemId
    this.criteria = criteria
    this.minDist = 2000000000
    this.found = null
}

function MinDistFinder_check(id, item) {
    if ((id == this.itemId) || (!(this.criteria(item)))) {
        
    } else {
        var dist = findDistance(
        	this.referenceItem,
        	item
        )
        if (dist < this.minDist) {
            this.found = id
            this.minDist = dist
        }
    }
}

function Socket(id, center, type, action) {
    this.id = id;
    this.center =  Utils.copyPoint(center);
    this.type = type;
    this.action = action;
    this.box = Utils.boxFromPoint(
    	center.x,
    	center.y,
    	Config.SOCKET_TOUCH_RADIUS,
    	Config.SOCKET_TOUCH_RADIUS
    );
}

function SocketInfo(itemId, type, action, name) {
    this.id = itemId;
    this.type = type;
    this.action = action;
    this.name = name;
}

function Storage(persistence) {
    this.persistence = persistence;
    this.graph = new Utils.Manhattan();
    this.free = new Utils.SortedSet()
    this.selection = createSelection();
    this.nextId = 1;
}

function StorageItem(id, type, isLine, isVertical) {
    this.id = id;
    this.type = type;
    this.isLine = isLine;
    this.isVertical = isVertical;
    this.x = 0;
    this.y = 0;
    this.w = 0;
    this.h = 0;
    this.a = 0;
    this.b = 0;
    this.content = null;
    this.head = null;
    this.tail = null;
    this.flag1 = 0;
}

function Undo() {
    this.next = 0;
    this.steps = [];
}

function accumulateFormat(names, result, filled, content) {
    var _ind17769 = 0;
    var _col17769 = names;
    var _len17769 = _col17769.length;
    while (true) {
        if (_ind17769 < _len17769) {
            
        } else {
            break;
        }
        var name = _col17769[_ind17769];
        var rvalue = result[name]
        var cvalue = content[name]
        if (hasValue(cvalue)) {
            if (filled[name]) {
                if ((cvalue == rvalue) || (name == "fillColor")) {
                    
                } else {
                    result[name] = null
                }
            } else {
                filled[name] = true
                result[name] = cvalue
            }
        } else {
            filled[name] = true
            result[name] = null
        }
        _ind17769++;
    }
}

function addAllSubs(graph, skewer, result) {
    var _ind20998 = 0;
    var _col20998 = skewer.list;
    var _len20998 = _col20998.length;
    while (true) {
        if (_ind20998 < _len20998) {
            
        } else {
            break;
        }
        var itemId = _col20998[_ind20998];
        var item = graph.getItem(itemId)
        if (item.role == "sub") {
            var _ind20980 = 0;
            var _col20980 = graph.nodes;
            var _keys20980 = Object.keys(_col20980); 
            var _len20980 = _keys20980.length;
            while (true) {
                if (_ind20980 < _len20980) {
                    
                } else {
                    break;
                }
                var id = _keys20980[_ind20980]; var node = _col20980[id];
                if (node.role == "sub") {
                    result.add(id)
                }
                _ind20980++;
            }
            break;
        }
        _ind20998++;
    }
}

function addBlockItems(editor, subgraph, commands) {
    var idMap = {};
    addSubgraphItems(
    	editor,
    	subgraph,
    	commands,
    	idMap
    );
    return {
    	first: idMap[subgraph.first],
    	last: idMap[subgraph.last]
    };
}

function addDrnGrips(editor, id, freeGrips) {
    var item = getAnyItem(editor.storage, id)
    var left = item.x - item.w;
    var right = item.x + item.w;
    var top = item.y - item.h;
    var bottom = item.y + item.h;
    var grips = editor.grips;
    var dims = {
    	x: item.x,
    	y: item.y,
    	w: item.w,
    	h: item.h
    };
    if (item.free) {
        var candies = Items.getCandies(item)
        copyPoints(candies, freeGrips)
        addGrips(
        	grips,	
        	id,
        	candies,	
        	dims
        )
        var handles = Items.getHandles(item)
        addGrips(
        	grips,	
        	id,
        	handles,	
        	dims
        )
    } else {
        if (((item.isLine) || (item.type == "duration")) || (item.type == "end")) {
            
        } else {
            if (item.type == "junction") {
                addGrip(
                	grips,
                	id,
                	item.x,
                	item.y,
                	Const.DRN_MOVE,
                	dims
                );
            } else {
                var candies = Items.getCandies(item)
                addGrips(
                	grips,	
                	id,
                	candies,	
                	dims
                )
            }
        }
    }
}

function addDummyJunction(graph, id, x, y, group) {
    var junc = makeDummyJunction(id, x, y);
    junc.group = group;
    graph.addItem(junc);
}

function addDummyLine(graph, id, isVertical, head, tail, role) {
    var item = makeDummyLine(
    	id,
    	isVertical,
    	head,
    	tail,
    	role
    );
    graph.addItem(item);
}

function addEditLink(editor, item, menu) {
    if (canHaveLink(item)) {
        menu.push(
            { type: "item", text: tr("MES_EXTERNAL_LINK") + "...", 
        	code: function(x, y){
                	editLink(editor, item, x, y)
            }}
        );
    }
}

function addFindReferences(menu, item) {
    if ((item.role == "header") && (Callbacks.findReferences)) {
        var content = getContent(item)
        var text = content.txt
        if (text) {
            menu.push(
                {
            	type: "item", 
            	text: translate("MES_FIND_REFERENCES"),
            	code: function(){
                    Callbacks.findReferences(text)
                }}
            )
            menu.push(
                { type: "separator" }
            )
        }
    }
}

function addFollowLink(editor, item, menu) {
    var content = getContent(item)
    if (content.link) {
        var link = Utils.truncateText(
        	content.link,
        	Config.CONTEXT_ITEM_LENGTH + 10
        )
        menu.push(
            { type: "item", text: link, code: function(){
                followLink(editor, item.id)
            }}
        );
        menu.push(
            { type: "separator" }
        );
    }
}

function addGrip(grips, id, x, y, type, dims) {
    var box = Utils.boxFromPoint(
    	x,
    	y,
    	Config.GRIP,
    	Config.GRIP
    );
    var touchBox = Utils.boxFromPoint(
    	x,
    	y,
    	Config.GRIP_TOUCH,
    	Config.GRIP_TOUCH
    );
    var grip = new Grip(
    	id,
    	type,
    	dims,
    	box,
    	touchBox
    );
    grips.push(grip);
}

function addGrips(grips, id, candies, dims) {
    var _ind18779 = 0;
    var _col18779 = candies;
    var _len18779 = _col18779.length;
    while (true) {
        if (_ind18779 < _len18779) {
            
        } else {
            break;
        }
        var candy = _col18779[_ind18779];
        changeMindGrip(candy)
        addGrip(
        	grips,
        	id,
        	candy.x,
        	candy.y,
        	candy.name,
        	dims
        );
        _ind18779++;
    }
}

function addImagesToMenu(menu, images) {
    var _ind21580 = 0;
    var _col21580 = menu;
    var _len21580 = _col21580.length;
    while (true) {
        if (_ind21580 < _len21580) {
            
        } else {
            break;
        }
        var item = _col21580[_ind21580];
        if (item.text in images) {
            item.image = images[item.text]
        }
        _ind21580++;
    }
}

function addItemsSubset(items, output) {
    if (items) {
        var _ind17489 = 0;
        var _col17489 = items;
        var _keys17489 = Object.keys(_col17489); 
        var _len17489 = _keys17489.length;
        while (true) {
            if (_ind17489 < _len17489) {
                
            } else {
                break;
            }
            var id = _keys17489[_ind17489]; var item = _col17489[id];
            output.push(item)
            _ind17489++;
        }
    }
}

function addMany(set, items) {
    var _ind20904 = 0;
    var _col20904 = items;
    var _len20904 = _col20904.length;
    while (true) {
        if (_ind20904 < _len20904) {
            
        } else {
            break;
        }
        var item = _col20904[_ind20904];
        set.add(item)
        _ind20904++;
    }
}

function addMarkCommands(graph, items, commands) {
    var _ind23043 = 0;
    var _col23043 = items;
    var _len23043 = _col23043.length;
    while (true) {
        if (_ind23043 < _len23043) {
            
        } else {
            break;
        }
        var item = _col23043[_ind23043];
        var node = graph.getNode(item.id)
        var marked = (node.flag1 == 1)
        if (item.marked == marked) {
            
        } else {
            var command = getOrCreateUpdate(
            	commands,
            	item.id
            )
            if (item.marked) {
                command.fields.flag1 = 1
            } else {
                command.fields.flag1 = 0
            }
        }
        _ind23043++;
    }
}

function addMarkCompleted(editor, item, menu) {
    if ((ignoreCommand()) || (!(canHaveLink(item)))) {
        
    } else {
        var text
        var content = Utils.copyObject(
        	getContent(item)
        )
        if (content.status) {
            delete content.status
            text = "MES_CLEAR_MARK"
        } else {
            content.status = "completed"
            text = "MES_MARK_COMPLETED"
        }
        var action = function() {
        	setContent(item.id, content)
        }
        menu.push({
        	type: "item",
        	text: tr(text),
        	code: action
        });
        menu.push(
            { type: "separator" }
        );
    }
}

function addMindMenuAction(action, menu) {
    var callback = function() {
    	mindAction(action.action, action.itemId, action.type)
    }
    var item = {
        type: "item",
        text: tr(action.text),
        code: callback
    }
    if (action.image) {
        item.image = action.image
    }
    menu.push(item)
}

function addMindPasteAction(action, subtree, menu) {
    var toPaste = {
    	"MES_ADD_LEFT_ITEM": "MES_PASTE_LEFT_ITEM",
    	"MES_ADD_RIGHT_ITEM": "MES_PASTE_RIGHT_ITEM",
    	"MES_ADD_ITEM_ABOVE": "MES_PASTE_ITEM_ABOVE",
    	"MES_ADD_ITEM_BELOW": "MES_PASTE_ITEM_BELOW",
    	"MES_ADD_VER_CHILD": "MES_PASTE_VER_CHILD",
    	"MES_ADD_CHILD": "MES_PASTE_CHILD",
    	"MES_ADD_ITEM": "MES_PASTE_ITEM"
    }
    var callback = function() {
    	mindPasteAction(action.action, action.itemId, subtree)
    }
    var text = toPaste[action.text]
    var item = {
        type: "item",
        text: tr(text),
        code: callback
    }
    if (action.image) {
        item.image = action.image
    }
    menu.push(item)
}

function addParameters() {
    if (ignoreCommand()) {
        
    } else {
        if (hasDrakon()) {
            var parameters = getParameters(self);
            if (parameters) {
                selectItem(self, parameters.id);
                redrawCanvas(self);
            } else {
                insertAndEdit(self, null, "params")
            }
        } else {
            console.log("Not DRAKON")
        }
    }
}

function addSubgraphItems(editor, subgraph, commands, idMap) {
    var newId;
    var graph = subgraph.graph;
    var _ind12631 = 0;
    var _col12631 = graph.nodes;
    var _keys12631 = Object.keys(_col12631); 
    var _len12631 = _keys12631.length;
    while (true) {
        if (_ind12631 < _len12631) {
            
        } else {
            break;
        }
        var id = _keys12631[_ind12631]; var node = _col12631[id];
        newId = generateId(editor.storage);
        idMap[id] = newId;
        _ind12631++;
    }
    var _ind12789 = 0;
    var _col12789 = graph.nodes;
    var _keys12789 = Object.keys(_col12789); 
    var _len12789 = _keys12789.length;
    while (true) {
        if (_ind12789 < _len12789) {
            
        } else {
            break;
        }
        var id = _keys12789[_ind12789]; var node = _col12789[id];
        newId = idMap[id];
        pushInsertNode(
        	commands,
        	newId,
        	node
        );
        _ind12789++;
    }
    var _ind12634 = 0;
    var _col12634 = graph.edges;
    var _keys12634 = Object.keys(_col12634); 
    var _len12634 = _keys12634.length;
    while (true) {
        if (_ind12634 < _len12634) {
            
        } else {
            break;
        }
        var id = _keys12634[_ind12634]; var edge = _col12634[id];
        newId = generateId(editor.storage);
        idMap[id] = newId;
        var head = idMap[edge.head];
        var tail = idMap[edge.tail];
        if (edge.isVertical) {
            pushInsertVertical(
            	commands,
            	newId,
            	head,
            	tail,
            	edge.role
            );
        } else {
            pushInsertHorizontal(
            	commands,
            	newId,
            	head,
            	tail,
            	edge.role
            );
        }
        _ind12634++;
    }
}

function addToUndo(undo, before, commands, after) {
    commands = postEdit(commands)
    addToUndoCore(
    	undo,
    	before,
    	commands,
    	after
    )
}

function addToUndoCore(undo, before, commands, after) {
    var newSteps = undo.steps.slice(
    	0,
    	undo.next
    );
    var step = {
    	before: before,
    	commands: commands,
    	after: after,
    	info: CallTrace.peek()
    }
    newSteps.push(step);
    undo.steps = newSteps;
    undo.next = newSteps.length;
}

function addTrace(name, args) {
    CallTrace.add(name, args)
}

function addTypeToMenu(menu) {
    var _ind22055 = 0;
    var _col22055 = menu;
    var _len22055 = _col22055.length;
    while (true) {
        if (_ind22055 < _len22055) {
            
        } else {
            break;
        }
        var item = _col22055[_ind22055];
        item.type = Mind.getDefaultIconType(item.action)
        _ind22055++;
    }
}

function adjustFontSize(node) {
    if ((self.storage.version >= 20180619) && (node.type == "branch")) {
        var content = node.content
        if (content) {
            
        } else {
            content = new Utils.Content("", "")
        }
        if (content.font) {
            
        } else {
            content = Utils.copyObject(content)
            var fontInfo = getDefaultFont()
            var size = Math.max(
            	fontInfo.size,
            	Config.BRANCH_HEADER_SIZE
            )
            content.font = Utils.buildFontString(
            	false,
            	true,
            	size,
            	fontInfo.family
            )
        }
        node.content = content
    }
}

function adjustForWildCycles(pgraph, header, movedNodes) {
    var minX = header.x + Config.METRE
    var actualX = minX
    var _ind21089 = 0;
    var _col21089 = pgraph.graph.nodes;
    var _keys21089 = Object.keys(_col21089); 
    var _len21089 = _keys21089.length;
    while (true) {
        if (_ind21089 < _len21089) {
            
        } else {
            break;
        }
        var id = _keys21089[_ind21089]; var node = _col21089[id];
        if ((node.x > header.x) && (node.box.left < actualX)) {
            actualX = node.box.left
        }
        _ind21089++;
    }
    if (actualX < minX) {
        var hDelta = actualX - minX
        pgraph.moveRight(
        	header.id,
        	hDelta,
        	movedNodes
        );
    }
}

function alignEdges(pgraph, leftId, rightId, movedNodes) {
    var graph = pgraph.graph;
    var left = nextPointBelow(
    	graph,
    	leftId
    );
    var right = nextPointBelow(
    	graph,
    	rightId
    );
    var y;
    var edgeId;
    if (left.y < right.y) {
        y = right.y;
        edgeId = leftId;
    } else {
        y = left.y;
        edgeId = rightId;
    }
    var edge = graph.getEdge(edgeId);
    var tail = graph.getTail(edge);
    var h = tail.y - tail.box.top;
    var lowestTail = y + Config.METRE + h;
    if (tail.y >= lowestTail) {
        
    } else {
        var delta = lowestTail - tail.y;
        pgraph.moveDown(
        	tail.id,
        	delta,
        	movedNodes
        );
    }
    return y;
}

function analyzeSelection(editor) {
    var free = editor.storage.free
    var selection = editor.storage.selection
    var ids = Object.keys(selection.ids)
    var greens = []
    var frees = []
    var blues = []
    var _ind16996 = 0;
    var _col16996 = ids;
    var _len16996 = _col16996.length;
    while (true) {
        if (_ind16996 < _len16996) {
            
        } else {
            break;
        }
        var id = _col16996[_ind16996];
        if (selection.ids[id] == "green") {
            greens.push(id)
        } else {
            var item = free.get(id)
            if (item) {
                frees.push(id)
            } else {
                blues.push(id)
            }
        }
        _ind16996++;
    }
    return {
    	greens: greens,
    	frees: frees,
    	blues: blues
    }
}

function appendInsertionSocket(sockets, itemId, type, operation) {
    var socket = new SocketInfo(itemId, operation, type, "insert");
    sockets.push(socket);
}

function appendMindSocket(sockets, targetId, operation, action, socketType) {
    var type = {
    	action: action.action,
    	socketType: socketType,
    	itemId: action.itemId
    }
    appendInsertionSocket(
    	sockets,
    	targetId,
    	type,
    	operation
    )
}

function appendNodeMindSocket(graph, sockets, node, operation, socketType, action) {
    var _sw226170000_ = 0;
    var x = 0
    var y = 0
    var half = Config.METRE / 2
    _sw226170000_ = action.action;
    if (_sw226170000_ === "miv01") {
        x = - node.w + Config.METRE * 1.5
        y = node.h
        var type = makeSocketType(
        	socketType,
        	action,
        	x,
        	y
        )
        appendInsertionSocket(
        	sockets,
        	node.id,
        	type,
        	operation
        )
    } else {
        if (_sw226170000_ === "miv04") {
            x = - node.w
            y = node.h
            var type = makeSocketType(
            	socketType,
            	action,
            	x,
            	y
            )
            appendInsertionSocket(
            	sockets,
            	node.id,
            	type,
            	operation
            )
        } else {
            if ((_sw226170000_ === "mih02") || (_sw226170000_ === "mih03")) {
                x = node.w + half
                var type = makeSocketType(
                	socketType,
                	action,
                	x,
                	y
                )
                appendInsertionSocket(
                	sockets,
                	node.id,
                	type,
                	operation
                )
            } else {
                if ((_sw226170000_ === "mih04") || (_sw226170000_ === "mih05")) {
                    x = -node.w - half
                    var type = makeSocketType(
                    	socketType,
                    	action,
                    	x,
                    	y
                    )
                    appendInsertionSocket(
                    	sockets,
                    	node.id,
                    	type,
                    	operation
                    )
                } else {
                    if (_sw226170000_ === "mih01") {
                        x = 0
                        y = node.h
                        var type = makeSocketType(
                        	socketType,
                        	action,
                        	x,
                        	y
                        )
                        appendInsertionSocket(
                        	sockets,
                        	node.id,
                        	type,
                        	operation
                        )
                    } else {
                        if (_sw226170000_ === "miv03") {
                            if ((node.up) || (node.role == "header")) {
                                
                            } else {
                                y = -node.h - half
                                var type = makeSocketType(
                                	socketType,
                                	action,
                                	x,
                                	y
                                )
                                appendInsertionSocket(
                                	sockets,
                                	node.id,
                                	type,
                                	operation
                                )
                            }
                        } else {
                            if ((_sw226170000_ === "miv02") && (node.left)) {
                                var leftNode = graph.getNodeLeftEx(node)
                                if (leftNode.down) {
                                    
                                } else {
                                    y = node.h + half
                                    var type = makeSocketType(
                                    	socketType,
                                    	action,
                                    	x,
                                    	y
                                    )
                                    appendInsertionSocket(
                                    	sockets,
                                    	node.id,
                                    	type,
                                    	operation
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function appendNodeMindSockets(graph, sockets, node, operation, socketType, actions) {
    var _ind22250 = 0;
    var _col22250 = actions;
    var _len22250 = _col22250.length;
    while (true) {
        if (_ind22250 < _len22250) {
            
        } else {
            break;
        }
        var action = _col22250[_ind22250];
        appendNodeMindSocket(
        	graph,
        	sockets,
        	node,
        	operation,
        	socketType,
        	action
        )
        _ind22250++;
    }
}

function appendSingleMindSocket(sockets, item, operation, socketType, actions) {
    var dx = 0
    var dy = 0
    if ((item.isLine) && ((hasUpTs(self.storage.graph, item)) || (!(item.role == "bridge")))) {
        
    } else {
        var action = actions[0]
        var type = makeSocketType(
        	socketType,
        	action,
        	dx,
        	dy
        )
        appendInsertionSocket(
        	sockets,
        	item.id,
        	type,
        	operation
        )
    }
}

function appendSocket(sockets, itemId, action) {
    var name, realAction;
    if (typeof action == "string") {
        name = action;
        realAction = gTransplants[action];
        if (realAction) {
            
        } else {
            Utils.throwError(
             "transplant not found: " + action);
        }
    } else {
        name = "no name";
        realAction = action;
    }
    var socket = new SocketInfo(itemId, "liana", realAction, name);
    sockets.push(socket);
}

function applyCommands(editor, commandList, selectAfter) {
    applyCommandsCore(
    	editor,
    	commandList,
    	selectAfter,
    	true,
    	true
    )
}

function applyCommandsCore(editor, commandList, selectAfter, deselect, redraw) {
    if (commandList.length === 0) {
        
    } else {
        commandList = calculateUndo(
        	editor.storage,
        	commandList
        );
        var before = copyState(editor);
        var after = copyState(editor);
        if (deselect) {
            after.selection = createSelection();
            if (selectAfter) {
                if (typeof selectAfter == "object") {
                    var _ind22713 = 0;
                    var _col22713 = selectAfter;
                    var _len22713 = _col22713.length;
                    while (true) {
                        if (_ind22713 < _len22713) {
                            
                        } else {
                            break;
                        }
                        var id = _col22713[_ind22713];
                        after.selection.add(id, false);
                        _ind22713++;
                    }
                } else {
                    after.selection.add(selectAfter, true);
                }
            }
        }
        runAndSaveCommands(
        	editor, 
        	before, 
        	commandList, 
        	after, 
        	redraw
        );
    }
}

function arrowDown(ctrl, shift, visibleBox) {
    if (ctrl) {
        if (ignoreCommand()) {
            
        } else {
            moveByArrow(0, 1, visibleBox)
        }
    } else {
        var isBelow = function(item, current) {
        	return item.y > current.y
        }
        var manFinder = findBelow
        onArrow(manFinder, isBelow)
    }
}

function arrowLeft(ctrl, shift, visibleBox) {
    if (ctrl) {
        if (ignoreCommand()) {
            
        } else {
            moveByArrow(-1, 0, visibleBox)
        }
    } else {
        var isToLeft = function(item, current) {
        	return item.x < current.x
        }
        var manFinder = findLeft
        onArrow(manFinder, isToLeft)
    }
}

function arrowRight(ctrl, shift, visibleBox) {
    if (ctrl) {
        if (ignoreCommand()) {
            
        } else {
            moveByArrow(1, 0, visibleBox)
        }
    } else {
        var isToRight = function(item, current) {
        	return item.x > current.x
        }
        var manFinder = findRight
        onArrow(manFinder, isToRight)
    }
}

function arrowUp(ctrl, shift, visibleBox) {
    if (ctrl) {
        if (ignoreCommand()) {
            
        } else {
            moveByArrow(0, -1, visibleBox)
        }
    } else {
        var isAbove = function(item, current) {
        	return item.y < current.y
        }
        var manFinder = findAbove
        onArrow(manFinder, isAbove)
    }
}

function autoCycleMarks(edit) {
    var _sw230020000_ = 0;
    var branches = []
    var addresses = []
    var graph = self.storage.graph
    var _ind23000 = 0;
    var _col23000 = graph.nodes;
    var _keys23000 = Object.keys(_col23000); 
    var _len23000 = _keys23000.length;
    while (true) {
        if (_ind23000 < _len23000) {
            
        } else {
            break;
        }
        var id = _keys23000[_ind23000]; var node = _col23000[id];
        _sw230020000_ = node.type;
        if (_sw230020000_ === "branch") {
            copyCoreBranchInfo(
            	branches,
            	node
            )
        } else {
            if (_sw230020000_ === "address") {
                copyCoreBranchInfo(
                	addresses,
                	node
                )
            }
        }
        _ind23000++;
    }
    var _ind23021 = 0;
    var _col23021 = branches;
    var _len23021 = _col23021.length;
    while (true) {
        if (_ind23021 < _len23021) {
            
        } else {
            break;
        }
        var branch = _col23021[_ind23021];
        var _ind23026 = 0;
        var _col23026 = addresses;
        var _len23026 = _col23026.length;
        while (true) {
            if (_ind23026 < _len23026) {
                
            } else {
                break;
            }
            var address = _col23026[_ind23026];
            if ((address.x >= branch.x) && (address.text == branch.text)) {
                address.marked = true
                branch.marked = true
            }
            _ind23026++;
        }
        _ind23021++;
    }
    var commands = {}
    addMarkCommands(
    	graph,
    	branches,
    	commands
    )
    addMarkCommands(
    	graph,
    	addresses,
    	commands
    )
    combineRunCommands(
    	edit,
    	commands
    )
}

function autoSizeIcons() {
    addTrace(
    	"autoSizeIcons",
    	[]
    );
    var editor = self;
    buildBoxesForFree(editor)
    var before = copyState(editor);
    var after = copyState(editor);
    var graph = editor.storage.graph;
    var ids = Object.keys(graph.nodes);
    var i;
    var count = ids.length;
    var allCommands = [];
    i = 0;
    while (true) {
        if (i < count) {
            
        } else {
            break;
        }
        var id = ids[i];
        var node = graph.getNode(id);
        if (node.type == "junction") {
            
        } else {
            allCommands = setTextExecute(
            	editor,
            	id,
            	node.content,
            	allCommands
            );
        }
        i++;
    }
    if (allCommands.length == 0) {
        
    } else {
        runAndSaveCommands(
        	editor,
        	before,
        	allCommands,
        	after,
        	true
        )
    }
}

function bakeCommands(graph, commands) {
    var _ind16166 = 0;
    var _col16166 = commands;
    var _keys16166 = Object.keys(_col16166); 
    var _len16166 = _keys16166.length;
    while (true) {
        if (_ind16166 < _len16166) {
            
        } else {
            break;
        }
        var id = _keys16166[_ind16166]; var command = _col16166[id];
        if ((command.type == "update") && (command.table == "nodes")) {
            var node = graph.getNode(id);
            var _ind16173 = 0;
            var _col16173 = command.fields;
            var _keys16173 = Object.keys(_col16173); 
            var _len16173 = _keys16173.length;
            while (true) {
                if (_ind16173 < _len16173) {
                    
                } else {
                    break;
                }
                var field = _keys16173[_ind16173]; var value = _col16173[field];
                node[field] = value;
                _ind16173++;
            }
        }
        _ind16166++;
    }
}

function beginBlockSelect() {
    var editor = self;
    editor.storage.selection = createSelection();
    redrawCanvas(self);
}

function belongsToCycle(graph, cycleStartNode, edgeId) {
    var rightUpId =graph.getNodeRight(cycleStartNode);
    var rightUp = graph.getNode(rightUpId);
    var rightDownId = graph.getNodeDown(rightUp);
    var node = graph.getNode(rightDownId);
    var id;
    while (true) {
        if (node.left) {
            id = graph.getNodeLeft(node);
        } else {
            if (node.up) {
                
            } else {
                return false;
            }
            if (node.up == edgeId) {
                return true;
            }
            id = graph.getNodeUp(node);
        }
        node = graph.getNode(id);
    }
}

function blockSelect(box) {
    var graph = self.storage.graph
    var free = self.storage.free
    var selection = self.storage.selection
    if (selection.blockSelect(graph, free, box)) {
        redrawCanvas(self);
        return true;
    } else {
        return false;
    }
}

function buildAddSockets(graph, insertionSocket, operation) {
    var sockets = [];
    if ((insertionSocket === "branch") || (insertionSocket === "case")) {
        var _ind11773 = 0;
        var _col11773 = graph.edges;
        var _keys11773 = Object.keys(_col11773); 
        var _len11773 = _keys11773.length;
        while (true) {
            if (_ind11773 < _len11773) {
                
            } else {
                break;
            }
            var tid = _keys11773[_ind11773]; var target = _col11773[tid];
            if (target.isVertical) {
                if ((isAboveLastCase(graph, target)) && (insertionSocket == "case")) {
                    appendInsertionSocket(
                    	sockets,
                    	target.id,
                    	insertionSocket,
                    	operation
                    );
                }
            } else {
                var branch = getBranchForEdge(graph, target);
                if ((branch) && (branch.type == insertionSocket)) {
                    appendInsertionSocket(
                    	sockets,
                    	target.id,
                    	insertionSocket,
                    	operation
                    );
                }
            }
            _ind11773++;
        }
    } else {
        if (insertionSocket === "duration") {
            var _ind14979 = 0;
            var _col14979 = graph.nodes;
            var _keys14979 = Object.keys(_col14979); 
            var _len14979 = _keys14979.length;
            while (true) {
                if (_ind14979 < _len14979) {
                    
                } else {
                    break;
                }
                var nid = _keys14979[_ind14979]; var node = _col14979[nid];
                if (goodForPeriod(node)) {
                    appendInsertionSocket(
                    	sockets,
                    	nid,
                    	insertionSocket,
                    	operation
                    );
                }
                _ind14979++;
            }
        } else {
            if (insertionSocket === "path") {
                var _ind15419 = 0;
                var _col15419 = graph.edges;
                var _keys15419 = Object.keys(_col15419); 
                var _len15419 = _keys15419.length;
                while (true) {
                    if (_ind15419 < _len15419) {
                        
                    } else {
                        break;
                    }
                    var tid = _keys15419[_ind15419]; var target = _col15419[tid];
                    if ((target.isVertical) || (!(target.role == "parallel"))) {
                        
                    } else {
                        appendInsertionSocket(
                        	sockets,
                        	target.id,
                        	insertionSocket,
                        	operation
                        );
                    }
                    _ind15419++;
                }
                var _ind15426 = 0;
                var _col15426 = graph.nodes;
                var _keys15426 = Object.keys(_col15426); 
                var _len15426 = _keys15426.length;
                while (true) {
                    if (_ind15426 < _len15426) {
                        
                    } else {
                        break;
                    }
                    var nid = _keys15426[_ind15426]; var node = _col15426[nid];
                    if (lastParallel(graph, node)) {
                        appendInsertionSocket(
                        	sockets,
                        	node.id,
                        	insertionSocket,
                        	operation
                        );
                    }
                    _ind15426++;
                }
            } else {
                var _ind11756 = 0;
                var _col11756 = graph.edges;
                var _keys11756 = Object.keys(_col11756); 
                var _len11756 = _keys11756.length;
                while (true) {
                    if (_ind11756 < _len11756) {
                        
                    } else {
                        break;
                    }
                    var tid = _keys11756[_ind11756]; var target = _col11756[tid];
                    if (downRole(target)) {
                        appendInsertionSocket(
                        	sockets,
                        	target.id,
                        	insertionSocket,
                        	operation
                        );
                    } else {
                        var straightExit = Utils.canInsertInHorizontal(
                        	graph,
                        	target
                        )
                        if (straightExit) {
                            appendInsertionSocket(
                            	sockets,
                            	target.id,
                            	insertionSocket,
                            	operation
                            );
                        }
                    }
                    _ind11756++;
                }
            }
        }
    }
    return sockets;
}

function buildBackMenu(editor, x, y) {
    var menu = []
    if (getClipboardType() == "free") {
        menu.push(
            { type: "item", text: tr("MES_PASTE"),
              code: function() {
                 pasteFree(editor, x, y)
            }}
        );
    }
    if (self.readonly) {
        
    } else {
        menu.push(
            { type: "item", text: tr("MES_BACKGROUND"),
              code: function(cx, cy) {
                 changeBackground(cx, cy)
              }
            }
        );
    }
    return menu
}

function buildBlockMenu() {
    var menu = [];
    var block = self.storage.selection.block;
    if (block) {
        block.oldIds = {};
        if (block.top) {
            menu.push(
                { type: "item", text: tr("MES_COPY"),
                  code: function() {
                    copyBlock(true, false); 
                  }
                }
            );
            if (self.readonly) {
                
            } else {
                menu.push(
                    { type: "item", text: tr("MES_CUT"),
                      code: function() { copyBlock(true, true); }
                    }
                );
                menu.push(
                    { type: "item", text: tr("MES_DELETE"),
                      code: function() { copyBlock(false, true); }
                    }
                );
                menu.push(
                    { type: "separator" }
                );
                var idsMap = getSelectedIds(self)
                var ids = Object.keys(idsMap)
                menu.push(
                    { type: "item", text: tr("MES_FORMAT"),
                      code: function(x, y){
                        changeFormat(x, y, ids);
                    }}
                );
            }
        }
    }
    return menu;
}

function buildBoxesForFree(editor) {
    var free = editor.storage.free
    var _ind17080 = 0;
    var _col17080 = free.set;
    var _keys17080 = Object.keys(_col17080); 
    var _len17080 = _keys17080.length;
    while (true) {
        if (_ind17080 < _len17080) {
            
        } else {
            break;
        }
        var id = _keys17080[_ind17080]; var node = _col17080[id];
        var fields = Drakon.fitItem(node, render)
        node.tb = fields.tb
        node.tb2 = fields.tb2
        _ind17080++;
    }
}

function buildBranchPointers(editor, addressNode) {
    var graph = editor.storage.graph;
    var allHeaders = findManyNodesBy(graph, "type", "branch");
    var isNotMe = function(node) {
    	return getText(node) != getText(addressNode);
    }
    var byX = function(left, right) {
    	if (left.x < right.x) { return -1; }
    	if (left.x > right.x) { return 1; }
    	return 0;
    };
    var headers = allHeaders.filter(isNotMe);
    headers.sort(byX);
    var commands = headers.map(function(node) {
    	return makePointToCommand(editor, addressNode.id, node);
    });
    return commands;
}

function buildCallout(render, content, id, x, y, commList) {
    content.h0x = Config.FREE_WIDTH + 20
    content.h0y = Config.FREE_HEIGHT + 40
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"callout",
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_HEIGHT,
    	content
    );
}

function buildCircle(render, content, id, x, y, commList) {
    var type = "f_circle"
    pushInsertFree(
    	render,
    	commList,
    	id,
    	type,
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_WIDTH,
    	content
    );
}

function buildCloud(render, content, id, x, y, commList) {
    var type = "f_cloud"
    pushInsertFree(
    	render,
    	commList,
    	id,
    	type,
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_WIDTH / 2,
    	content
    );
}

function buildDb(render, content, id, x, y, commList) {
    var type = "f_db"
    pushInsertFree(
    	render,
    	commList,
    	id,
    	type,
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_WIDTH,
    	content
    );
}

function buildExpandMenu(editor, item) {
    var menu = [
        { type: "item", text: tr("MES_ADD_LINE"),
          image: "expand.png",
          code: function(){
            expandBolt(editor, item.id);
        }}
    ];
    return menu;
}

function buildFormatMenu(editor, ids) {
    var menu = []
    menu.push(
        { type: "item", text: tr("MES_FORMAT"),
          code: function(x, y){
            changeFormat(x, y, ids);
        }}
    );
    return menu
}

function buildFreeBlockMenu(editor, ids, allIds) {
    var menu = []
    menu.push(
        { type: "item", text: tr("MES_COPY"), code: function(){
            copyFree(editor, ids, true, false)
        }}
    );
    if (self.readonly) {
        
    } else {
        menu.push(
            { type: "item", text: tr("MES_CUT"), code: function(){
                copyFree(editor, ids, true, true)
            }}
        );
        menu.push(
            { type: "separator" }
        );
        menu.push(
            { type: "item", text: tr("MES_DELETE"), code: function(){
                deleteFreeItems(editor, ids);
            }}
        );
        menu.push(
            { type: "separator" }
        );
        menu.push(
            { type: "item", text: tr("MES_FORMAT"),
              code: function(x, y){
                changeFormat(x, y, allIds);
            }}
        );
    }
    return menu
}

function buildFreeBuilders() {
    gFreeBuilders = {}
    gFreeBuilders["gdur-left"] = function(r, c, id, x, y, list) {
    	buildGdur(r, c, id, x, y, list, false)
    }
    gFreeBuilders["gdur-right"] = function(r, c, id, x, y, list) {
    	buildGdur(r, c, id, x, y, list, true)
    }
    gFreeBuilders.f_line = function(r, c, id, x, y, list) {
    	buildLine(r, c, id, x, y, list)
    }
    gFreeBuilders.f_arrow = function(r, c, id, x, y, list) {
    	buildLine(r, c, id, x, y, list, "arrow")
    }
    gFreeBuilders.f_label = buildLabel
    gFreeBuilders.callout = buildCallout
    gFreeBuilders.f_shelf = buildShelf
    gFreeBuilders.f_rounded = buildRounded
    gFreeBuilders.f_ptr_right = buildPtrRight
    gFreeBuilders.f_ptr_left = buildPtrLeft
    gFreeBuilders.f_more = buildMore
    gFreeBuilders.f_circle = buildCircle
    gFreeBuilders.f_cloud = buildCloud
    gFreeBuilders.f_db = buildDb
}

function buildGdur(render, content, id, x, y, commList, right) {
    content.right = right
    content.h0x = 60
    content.h0y = 80
    content.h1x = 60
    content.h1y = 80
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"gdur",
    	x,
    	y,
    	Config.DEF_ICON_WIDTH_S,
    	Config.MIN_ICON_HEIGHT,
    	content
    );
}

function buildIconMenu(editor, item) {
    if (self.readonly) {
        var graph = editor.storage.graph;
        var menu = [];
        addFindReferences(menu, item)
        addFollowLink(editor, item, menu)
        if (canCopyOne(graph, item)) {
            menu.push(
                { type: "item", text: tr("MES_COPY"), code: function(){
                    copyOne(editor, item.id, false);
                }}
            );
        }
        menu.push(
            { type: "item", text: tr("MES_COPY_TEXT"), code: function(){
                copyText(editor, item.content);
            }}
        );
        return menu
    } else {
        return buildIconMenuCore(editor, item)
    }
}

function buildIconMenuCore(editor, item) {
    var _sw165250000_ = 0;
    var _sw165010000_ = 0;
    var graph = editor.storage.graph;
    var menu = [];
    addFindReferences(menu, item)
    addMarkCompleted(editor, item, menu)
    addFollowLink(editor, item, menu)
    var canDelete = canDeleteItem(editor, item);
    if (canCopyOne(graph, item)) {
        menu.push(
            { type: "item", text: tr("MES_COPY"), code: function(){
                copyOne(editor, item.id, false);
            }}
        );
        if (canDelete) {
            menu.push(
                { type: "item", text: tr("MES_CUT"), code: function(){
                    copyOne(editor, item.id, true);
                }}
            );
        }
        if (getClipboardType() == "case") {
            if (item.type == "case") {
                menu.push(
                    { type: "item", text: tr("MES_PASTE"),
                      code: function(){
                        pasteCase(editor, item.id);
                    }}
                );
            }
        } else {
            if (((getClipboardType() == "branch") && (item.type == "branch")) && (!(isEndBranch(graph, item)))) {
                menu.push(
                    { type: "item", text: tr("MES_PASTE"),
                      code: function(){
                        pasteBranch(editor, item.id);
                    }}
                );
            }
        }
        menu.push(
            { type: "separator" }
        );
    }
    if (canDelete) {
        menu.push(
            { type: "item", text: tr("MES_DELETE"), code: function(){
                deleteItem(editor, item.id);
            }}
        );
        menu.push(
            { type: "separator" }
        );
    }
    menu.push(
        { type: "item", text: tr("MES_COPY_TEXT"), code: function(){
            copyText(editor, item.content);
        }}
    );
    if (getClipboardType() == "text") {
        menu.push(
            { type: "item", text: tr("MES_PASTE_TEXT"), code: function(){
                pasteText(editor, item.id);
            }}
        );
    }
    _sw165250000_ = item.type;
    if (_sw165250000_ === "address") {
        
    } else {
        if (hasUpperText(item)) {
            menu.push(
                { type: "item", text: tr("MES_CHANGE_UPPER"), code: function(){
                    startEditUpperText(item.id);
                }}
            );
        }
        menu.push(
            { type: "item", text: tr("MES_CHANGE_TEXT"), code: function(){
                startEditText(item.id);
            }}
        );
    }
    _sw165010000_ = item.type;
    if (_sw165010000_ === "question") {
        menu.push(
            { type: "item", text: tr("MES_SWAP_YES_NO"), code: function(){
                swapYesNo(editor, item.id);
            }}
        );
        if (userId) {
            menu.push(
                { type: "separator" }
            );
            menu.push(
                { type: "item", text: tr("MES_CHANGE_YES_NO"), code: function(){
                    changeYesNo()
                }}
            );
        }
    } else {
        if (_sw165010000_ === "case") {
            menu.push(
                { type: "item", text: tr("MES_INSERT_CASE"), image: "case.png",
                  code: function(){
                    insertAndEdit(editor, item.id, "case");
                }}
            );
        } else {
            if (_sw165010000_ === "address") {
                menu = menu.concat(
                	buildBranchPointers(editor, item)
                );
            } else {
                if ((_sw165010000_ === "branch") && (!(isEndBranch(graph, item)))) {
                    menu.push(
                    	createInsertBranchMenuItem(
                    		editor, item
                    ));
                    if (isLastBranch(graph, item)) {
                        menu.push(
                        	createInsertEndBranchMenuItem(
                        		editor, item
                        ));
                    }
                }
            }
        }
    }
    if (item.role === "header") {
        if (getParameters(editor)) {
            
        } else {
            menu.push(
                { type: "item", text: tr("MES_ADD_PARAMS"), 
                  image: "params-1.png",
                  code: function() {
                    insertAndEdit(editor, null, "params");
                }}
            );
        }
        if (isSilhouette(editor.storage.graph)) {
            menu.push(
                { type: "item", text: tr("MES_TRANS_TO_PRIM"), 
                  image: "primitive.png",
                  code: function() {
                    toPrimitive(editor);
                }}
            );
        } else {
            menu.push(
                { type: "item", text: tr("MES_TRANS_TO_SILH"),
                  image: "silhouette.png",
                  code: function() {
                    toSilhouette(editor);
                }}
            );
        }
    }
    addEditLink(editor, item, menu)
    menu.push(
        { type: "separator" }
    );
    menu.push(
        { type: "item", text: tr("MES_FORMAT"),
          code: function(x, y){
            changeFormat(x, y, [item.id]);
        }}
    );
    return menu;
}

function buildInsertMenu(editor, item) {
    var graph = editor.storage.graph;
    var menu = [];
    if (getClipboardType() == "block") {
        menu.push(
            { type: "item", text: tr("MES_PASTE"), code: function(){
                pasteBlock(editor, item.id);
            }},
            { type: "separator" }
        );
    }
    var menu2 = [
        { type: "item", text: tr("BUT_ACTION"), 
          image: "action.png",
          code: function(){
            insertAndEdit(editor, item.id, "action");
        }},
        { type: "item", text: tr("BUT_QUESTION"),
          image: "question.png",
          code: function(){
            insertAndEdit(editor, item.id, "question");
        }},
        { type: "item", text: tr("BUT_SELECT"),
          image: "select.png",
          code: function(){
            insertAndEdit(editor, item.id, "select");
        }},
        { type: "item", text: tr("BUT_FOREACH"),
          image: "foreach.png",
          code: function(){
            insertAndEdit(editor, item.id, "foreach");
        }},
        { type: "item", text: tr("BUT_INSERTION"),
          image: "insertion.png",
          code: function(){
            insertAndEdit(editor, item.id, "insertion");
        }},
        { type: "item", text: tr("BUT_COMMENT"),
          image: "comment.png",
          code: function(){
            insertAndEdit(editor, item.id, "comment");
        }}
    ];
    menu = menu.concat(menu2);
    if (isBolt(graph, item)) {
        menu.push(createBoltMenuItem(editor, item));
    }
    return menu;
}

function buildInsertionSockets(graph, insertionSocket) {
    var parts = insertionSocket.split("-");
    var operation;
    var socketType;
    if ((parts.length == 2) && (parts[0] == "clip")) {
        operation = "paste";
        socketType = parts[1];
    } else {
        operation = "insert";
        socketType = insertionSocket;
    }
    return buildAddSockets(
    	graph,
    	socketType,
    	operation
    );
}

function buildLabel(render, content, id, x, y, commList) {
    content.txt = "Text"
    content.lineThickness = 0
    content.align = "center"
    content.padding = 0
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"f_label",
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_HEIGHT - Config.SIZE_SNAP,
    	content
    );
}

function buildLine(render, content, id, x, y, commList, arrowEnd) {
    content.arrowEnd = arrowEnd
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"f_line",
    	x,
    	y,
    	100,
    	0,
    	content
    );
}

function buildMacroLoop(render, cont, cont2) {
    var graph = new Utils.Manhattan();
    var upper = makeDummyItem(1, render, "loopbegin", cont);
    var lower = makeDummyItem(2, render, "loopend", cont2);
    var width = Math.max(upper.w, lower.w);
    upper.w = width;
    lower.w = width;
    lower.y = upper.h + lower.h + Config.METRE * 3;
    graph.addItem(upper);
    graph.addItem(lower);
    graph.addItem(makeDummyLine(
    	3,
    	true,
    	1,
    	2,
    	"down"
    ));
    return {
    	graph: graph,
    	first: 1,
    	last: 2
    };
}

function buildMacroParallel(render) {
    var id = 5;
    var right = Config.METRE * 5;
    var bottom = Config.METRE * 10;
    var qitem = makeDummyJunction(1, 0, 0);
    var jRightUp = makeDummyJunction(2, right, 0);
    var jRightDown = makeDummyJunction(3, right, bottom);
    var jLeftDown = makeDummyJunction(4, 0, bottom);
    var graph = new Utils.Manhattan();
    graph.addItem(qitem);
    graph.addItem(jRightUp);
    graph.addItem(jRightDown);
    graph.addItem(jLeftDown);
    graph.addItem(makeDummyLine(
    	id++,
    	false,
    	qitem.id,
    	jRightUp.id,
    	"parallel"
    ));
    graph.addItem(makeDummyLine(
    	id++,
    	true,
    	jRightUp.id,
    	jRightDown.id,
    	"par-down"
    ));
    graph.addItem(makeDummyLine(
    	id++,
    	false,
    	jLeftDown.id,
    	jRightDown.id,
    	null
    ));
    graph.addItem(makeDummyLine(
    	id++,
    	true,
    	qitem.id,
    	jLeftDown.id,
    	"par-down"
    ));
    return {
    	graph: graph,
    	first: qitem.id,
    	last: jLeftDown.id
    };
}

function buildMacroQuestion(render, cont, flag1) {
    var id = 5;
    var qitem = makeDummyItem(1, render, "question", cont);
    qitem.flag1 = flag1;
    var right = qitem.w + Config.METRE * 2;
    var bottom = qitem.h + Config.METRE * 4;
    var jRightUp = makeDummyJunction(2, right, 0);
    var jRightDown = makeDummyJunction(3, right, bottom);
    var jLeftDown = makeDummyJunction(4, 0, bottom);
    var graph = new Utils.Manhattan();
    graph.addItem(qitem);
    graph.addItem(jRightUp);
    graph.addItem(jRightDown);
    graph.addItem(jLeftDown);
    graph.addItem(makeDummyLine(
    	id++,
    	false,
    	qitem.id,
    	jRightUp.id,
    	null
    ));
    graph.addItem(makeDummyLine(
    	id++,
    	true,
    	jRightUp.id,
    	jRightDown.id,
    	"down"
    ));
    graph.addItem(makeDummyLine(
    	id++,
    	false,
    	jLeftDown.id,
    	jRightDown.id,
    	"left"
    ));
    graph.addItem(makeDummyLine(
    	id++,
    	true,
    	qitem.id,
    	jLeftDown.id,
    	"down"
    ));
    return {
    	graph: graph,
    	first: qitem.id,
    	last: jLeftDown.id
    };
}

function buildMacroSelect(render, selectCont, caseConts) {
    var i;
    var count = caseConts.length;
    var id = 2;
    var caseHeight = 0;
    var cases = [];
    i = 0;
    while (true) {
        if (i < count) {
            
        } else {
            break;
        }
        var caseCont = caseConts[i];
        var dummyCase = makeDummyItem(id, render, "case", caseCont);
        dummyCase.group = 1;
        id += 10;
        caseHeight = Math.max(caseHeight, dummyCase.h);
        cases.push(dummyCase);
        i++;
    }
    var graph = new Utils.Manhattan();
    var select = makeDummyItem(1, render, "select", selectCont);
    select.group = 1;
    var topLine = select.h + Config.METRE;
    var caseLine = topLine + Config.METRE + caseHeight;
    var bottomLine = caseLine + caseHeight + 
    	Config.METRE * 3;
    var case0 = cases[0];
    var skewerWidth = Math.max(select.w, case0.w);
    case0.y = caseLine;
    case0.h = caseHeight;
    case0.w = skewerWidth;
    select.w = skewerWidth;
    graph.addItem(select);
    graph.addItem(case0);
    var upJoint = 3;
    var downJoint = 4;
    addDummyJunction(graph,  upJoint, 0, topLine, 1);
    addDummyJunction(graph,  downJoint, 0, bottomLine, null);
    addDummyLine(graph, 5, true, 1, upJoint, null);
    addDummyLine(graph, 6, true, upJoint, 2, null);
    addDummyLine(graph, 7, true, 2, downJoint, "down");
    var x = select.w + Config.METRE;
    i = 1;
    while (true) {
        if (i < count) {
            
        } else {
            break;
        }
        var thisCase = cases[i];
        x += thisCase.w;
        thisCase.h = caseHeight;
        thisCase.y = caseLine;
        thisCase.x = x;
        var upJoint2 = thisCase.id + 1;
        var downJoint2 = thisCase.id + 2;
        addDummyJunction(graph,  upJoint2, x, topLine, 1);
        addDummyJunction(graph,  downJoint2, x, bottomLine, null);
        graph.addItem(thisCase);
        addDummyLine(graph, id++, false, upJoint, upJoint2, null);
        addDummyLine(graph, id++, true, upJoint2, thisCase.id, null);
        addDummyLine(graph, id++, true, thisCase.id, downJoint2, "down");
        addDummyLine(graph, id++, false, downJoint, downJoint2, "left");
        upJoint = upJoint2;
        downJoint = downJoint2;
        x += thisCase.w + Config.METRE;
        i++;
    }
    return {
    	graph: graph,
    	first: 1,
    	last: 4
    };
}

function buildMacroSimple(render, type, content) {
    var graph = new Utils.Manhattan();
    var item = makeDummyItem(1, render, type, content);
    graph.addItem(item);
    return {
    	graph: graph,
    	first: 1,
    	last: 1
    };
}

function buildMenuAt(x, y) {
    var _sw164270000_ = 0;
    var id;
    var menu;
    var item = null
    var ids = getSelectedIds(this);
    var idList = Object.keys(ids);
    _sw164270000_ = idList.length;
    if (_sw164270000_ === 0) {
        var draggable = findVisualItem(
        	x,
        	y
        );
        if (draggable) {
            id = draggable.id;
        } else {
            id = null;
        }
        if (id) {
            var foundItem = getAnyItem(self.storage, id)
            item = {
            	type: foundItem.type,
            	content: Utils.copyObject(foundItem.content)
            }
            if (foundItem.free) {
                menu = buildMenuForFree(self, id)
            } else {
                if (isMind()) {
                    menu = buildMenuForMind(self, id);
                } else {
                    menu = buildMenuForItem(self, id);
                }
            }
        } else {
            menu = buildBackMenu(self, x, y)
        }
    } else {
        if (_sw164270000_ === 1) {
            id = idList[0];
            if (id) {
                var foundItem = getAnyItem(self.storage, id)
                item = {
                	type: foundItem.type,
                	content: Utils.copyObject(foundItem.content)
                }
                if (foundItem.free) {
                    menu = buildMenuForFree(self, id)
                } else {
                    if (isMind()) {
                        menu = buildMenuForMind(self, id);
                    } else {
                        menu = buildMenuForItem(self, id);
                    }
                }
            } else {
                menu = buildBackMenu(self, x, y)
            }
        } else {
            if (isMind()) {
                menu = buildFormatMenu(self, idList)
            } else {
                var selection = analyzeSelection(self)
                if (selection.greens.length > 1) {
                    menu = buildBlockMenu();
                } else {
                    if (selection.frees.length == 0) {
                        menu = buildFormatMenu(self, idList)
                    } else {
                        menu = buildFreeBlockMenu(
                        	self,
                        	selection.frees,
                        	idList
                        )
                    }
                }
            }
        }
    }
    return {
    	menu: menu,
    	item: item
    };
}

function buildMenuForFree(editor, itemId) {
    var item = getAnyItem(editor.storage, itemId)
    var menu = []
    addMarkCompleted(editor, item, menu)
    addFollowLink(editor, item, menu)
    menu.push(
        { type: "item", text: tr("MES_COPY"), code: function(){
            copyFree(editor, [itemId], true, false)
        }}
    );
    if (self.readonly) {
        
    } else {
        menu.push(
            { type: "item", text: tr("MES_CUT"), code: function(){
                copyFree(editor, [itemId], true, true)
            }}
        );
        menu.push(
            { type: "separator" }
        );
        menu.push(
            { type: "item", text: tr("MES_DELETE"), code: function(){
                deleteFreeItems(editor, [item.id]);
            }}
        );
    }
    menu.push(
        { type: "separator" }
    );
    menu.push(
        { type: "item", text: tr("MES_COPY_TEXT"), code: function(){
            copyText(editor, item.content);
        }}
    );
    if ((getClipboardType() == "text") && (!(self.readonly))) {
        menu.push(
            { type: "item", text: tr("MES_PASTE_TEXT"), code: function(){
                pasteText(editor, item.id);
            }}
        );
    }
    if (hasUpperText(item)) {
        menu.push(
            { type: "item", text: tr("MES_CHANGE_UPPER"), code: function(){
                startEditUpperText(item.id);
            }}
        );
    }
    menu.push(
        { type: "item", text: tr("MES_CHANGE_TEXT"), code: function(){
            startEditText(item.id);
        }}
    );
    if (self.readonly) {
        
    } else {
        addEditLink(editor, item, menu)
        menu.push(
            { type: "separator" }
        );
        menu.push(
            {   type: "item", text: tr("MES_TO_FRONT"),
                code: function(){
                   toFront(editor, itemId);
            }}
        )
        menu.push(
            {   type: "item", text: tr("MES_TO_BACK"),
                code: function(){
                   toBack(editor, itemId);
            }}
        )
        menu.push(
            { type: "separator" }
        );
        menu.push(
            {   type: "item", text: tr("MES_FORMAT"),
                code: function(x, y){
                   changeFormat(x, y, [item.id]);
            }}
        );
    }
    return menu
}

function buildMenuForItem(editor, itemId) {
    var _sw20430000_ = 0;
    var _sw116440000_ = 0;
    var item = editor.storage.graph.getItem(
    	itemId
    );
    var graph = editor.storage.graph;
    var menu = null;
    if (self.readonly) {
        if ((item.type == "junction") || (item.isLine)) {
            
        } else {
            menu = buildIconMenu(
            	editor,
            	item
            );
        }
    } else {
        _sw20430000_ = item.type;
        if (_sw20430000_ === "horizontal") {
            if (Utils.canInsertInHorizontal(graph, item)) {
                menu = buildInsertMenu(
                	editor,
                	item
                );
                var expand = buildExpandMenu(
                	editor,
                	item
                );
                menu.push(
                    { type: "separator" }
                );
                menu = menu.concat(expand)
            } else {
                var branch = getBranchForEdge(graph, item);
                menu = [];
                if (branch) {
                    _sw116440000_ = branch.type;
                    if (_sw116440000_ === "case") {
                        if (getClipboardType() == "case") {
                            menu.push(
                                { type: "item", text: tr("MES_PASTE"),
                                  code: function(){
                                    pasteCase(editor, branch.id);
                                }}
                            );
                        }
                        menu.push(createInsertCaseMenuItem(
                        	editor,
                        	branch
                        ));
                    } else {
                        if (_sw116440000_ === "branch") {
                            
                        } else {
                            throw "Unexpected switch value: " + _sw116440000_;
                        }
                        if (getClipboardType() == "branch") {
                            menu.push(
                                { type: "item", text: tr("MES_PASTE"),
                                  code: function(){
                                    pasteBranch(editor, branch.id);
                                }}
                            );
                        }
                        menu.push(createInsertBranchMenuItem(
                        	editor,
                        	branch
                        ));
                    }
                } else {
                    if (item.role == "parallel") {
                        menu.push(
                            { type: "item", text: tr("MES_NEW_PATH"),
                        	image: "par.png",
                              code: function(){
                                insertPathInside(editor, item.id);
                            }},
                            { type: "item", text: tr("MES_DELETE_PATH"),
                              code: function() {
                                deletePath(editor, item.id);
                            }}
                        );
                    }
                }
            }
        } else {
            if (_sw20430000_ === "junction") {
                if (lastParallel(graph, item)) {
                    menu = [
                        { type: "item", text: tr("MES_NEW_PATH"),
                    	image: "par.png",
                          code: function(){
                            insertPathOutside(editor, item.id);
                        }},
                        { type: "item", text: tr("MES_DELETE_PATH"),
                          code: function() {
                            deletePath(editor, item.left);
                        }}
                    ];
                } else {
                    if (middleParallel(graph, item)) {
                        menu = [
                            { type: "item", text: tr("MES_NEW_PATH"),
                        	image: "par.png",
                              code: function(){
                                insertPathInside(editor, item.right);
                            }},
                            { type: "item", text: tr("MES_DELETE_PATH"),
                              code: function() {
                                deletePath(editor, item.left);
                            }}
                        ];
                    } else {
                        if (item.left) {
                            var leftEdge = graph.getEdge(item.left);
                            if (isRightHand(graph, leftEdge)) {
                                menu = buildExpandMenu(
                                	editor,
                                	leftEdge
                                );
                            } else {
                                if (item.up) {
                                    var upEdge = graph.getEdge(item.up);
                                    if (isBolt(graph, upEdge)) {
                                        menu = [createBoltMenuItem(editor, upEdge)];
                                    }
                                } else {
                                    if (item.down) {
                                        var downEdge = graph.getEdge(item.down);
                                        if (isBolt(graph, downEdge)) {
                                            menu = [createBoltMenuItem(editor, downEdge)];
                                        }
                                    }
                                }
                            }
                        } else {
                            if (item.up) {
                                var upEdge = graph.getEdge(item.up);
                                if (isBolt(graph, upEdge)) {
                                    menu = [createBoltMenuItem(editor, upEdge)];
                                }
                            } else {
                                if (item.down) {
                                    var downEdge = graph.getEdge(item.down);
                                    if (isBolt(graph, downEdge)) {
                                        menu = [createBoltMenuItem(editor, downEdge)];
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if (_sw20430000_ === "vertical") {
                    if (downRole(item)) {
                        menu = buildInsertMenu(
                        	editor,
                        	item
                        );
                    }
                } else {
                    menu = buildIconMenu(
                    	editor,
                    	item
                    );
                }
            }
        }
    }
    return menu;
}

function buildMenuForMind(editor, itemId) {
    var item = editor.storage.graph.getItem(
    	itemId
    );
    if ((item.isLine) || (item.type == "junction")) {
        return buildMenuForMindJunction(editor, itemId)
    } else {
        return buildMenuForMindIcon(editor, itemId)
    }
}

function buildMenuForMindIcon(editor, itemId) {
    var item = editor.storage.graph.getItem(
    	itemId
    );
    var graph = editor.storage.graph;
    var menu = [];
    addFindReferences(menu, item)
    if (editor.readonly) {
        
    } else {
        addMarkCompleted(editor, item, menu)
    }
    addFollowLink(editor, item, menu)
    if (editor.readonly) {
        
    } else {
        var actions = getMindActions(editor, item)
        if (actions.length > 0) {
            var _ind21629 = 0;
            var _col21629 = actions;
            var _len21629 = _col21629.length;
            while (true) {
                if (_ind21629 < _len21629) {
                    
                } else {
                    break;
                }
                var action = _col21629[_ind21629];
                addMindMenuAction(action, menu)
                _ind21629++;
            }
            menu.push({ type: "separator" })
        }
    }
    menu.push(
        { type: "item", text: tr("MES_COPY"), code: function(){
            copyMind(item.id, false);
        }}
    );
    if (editor.readonly) {
        
    } else {
        var deleteAction = findMindDelete(item)
        if (deleteAction) {
            menu.push(
                { type: "item", text: tr("MES_CUT"), code: function(){
                    copyMind(item.id, true);
                }}
            );
        }
        if ((actions.length > 0) && (getClipboardType() == "mind")) {
            menu.push(
                { type: "item", text: tr("MES_PASTE"), 
                  code: function(x, y) {
                    pasteMind(x, y, actions);
                }}
            );
        }
        if (deleteAction) {
            menu.push({ type: "separator" })
            menu.push(
              {
                type: "item", text: tr("MES_DELETE"),
                code: function(){mindAction(deleteAction, itemId, null)}
              }
            )
        }
    }
    menu.push({ type: "separator" })
    menu.push(
        { type: "item", text: tr("MES_COPY_TEXT"), code: function(){
            copyText(editor, item.content);
        }}
    );
    if (getClipboardType() == "text") {
        menu.push(
            { type: "item", text: tr("MES_PASTE_TEXT"), code: function(){
                pasteText(editor, item.id);
            }}
        );
    }
    if (hasUpperText(item)) {
        menu.push(
            { type: "item", text: tr("MES_CHANGE_UPPER"), code: function(){
                startEditUpperText(item.id);
            }}
        );
    }
    menu.push(
        { type: "item", text: tr("MES_CHANGE_TEXT"), code: function(){
            startEditText(item.id);
        }}
    );
    addEditLink(editor, item, menu)
    if (editor.readonly) {
        
    } else {
        menu.push(
            { type: "item", text: tr("MES_TURN_INTO"),
              code: function(x, y){
                turnInto(x, y, item.id);
            }}
        );
        menu.push(
            { type: "separator" }
        );
        menu.push(
            { type: "item", text: tr("MES_FORMAT"),
              code: function(x, y){
                changeFormat(x, y, [item.id]);
            }}
        );
    }
    return menu
}

function buildMenuForMindJunction(editor, itemId) {
    var menu = [];
    if (editor.readonly) {
        
    } else {
        var item = editor.storage.graph.getItem(
        	itemId
        );
        var graph = editor.storage.graph;
        var actions = getMindActions(editor, item)
        if (actions.length > 0) {
            var _ind21688 = 0;
            var _col21688 = actions;
            var _len21688 = _col21688.length;
            while (true) {
                if (_ind21688 < _len21688) {
                    
                } else {
                    break;
                }
                var action = _col21688[_ind21688];
                addMindMenuAction(action, menu)
                _ind21688++;
            }
        }
        if ((actions.length > 0) && (getClipboardType() == "mind")) {
            var subtree = getClipboard("mind")
            if (subtree) {
                var _ind21960 = 0;
                var _col21960 = actions;
                var _len21960 = _col21960.length;
                while (true) {
                    if (_ind21960 < _len21960) {
                        
                    } else {
                        break;
                    }
                    var action = _col21960[_ind21960];
                    addMindPasteAction(action, subtree, menu)
                    _ind21960++;
                }
            }
        }
    }
    return menu
}

function buildMindSockets(graph, insertionSocket) {
    var parts = insertionSocket.split("-");
    var operation, socketType
    var sockets = []
    if (parts[1] == "clip") {
        operation = "paste"
        socketType = ""
    } else {
        operation = "insert"
        socketType = parts[1]
    }
    var _ind22225 = 0;
    var _col22225 = graph.edges;
    var _keys22225 = Object.keys(_col22225); 
    var _len22225 = _keys22225.length;
    while (true) {
        if (_ind22225 < _len22225) {
            
        } else {
            break;
        }
        var eid = _keys22225[_ind22225]; var edge = _col22225[eid];
        var actions = getMindActions(self, edge)
        if (actions.length == 0) {
            
        } else {
            appendSingleMindSocket(
            	sockets,
            	edge,
            	operation,
            	socketType,
            	actions
            )
        }
        _ind22225++;
    }
    var _ind22197 = 0;
    var _col22197 = graph.nodes;
    var _keys22197 = Object.keys(_col22197); 
    var _len22197 = _keys22197.length;
    while (true) {
        if (_ind22197 < _len22197) {
            
        } else {
            break;
        }
        var nid = _keys22197[_ind22197]; var node = _col22197[nid];
        var actions = getMindActions(self, node)
        if (actions.length == 0) {
            
        } else {
            if (node.type == "junction") {
                appendSingleMindSocket(
                	sockets,
                	node,
                	operation,
                	socketType,
                	actions
                )
            } else {
                appendNodeMindSockets(
                	graph,
                	sockets,
                	node,
                	operation,
                	socketType,
                	actions
                )
            }
        }
        _ind22197++;
    }
    return sockets
}

function buildMore(render, content, id, x, y, commList, subtype) {
    content.subtype = subtype
    content.lineThickness = 2
    var size = Items.newMore(content)
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"f_more",
    	x,
    	y,
    	size.w,
    	size.h,
    	content
    );
}

function buildMoveCommands(pgraph, moved, commands) {
    var _ind2306 = 0;
    var _col2306 = moved;
    var _keys2306 = Object.keys(_col2306); 
    var _len2306 = _keys2306.length;
    while (true) {
        if (_ind2306 < _len2306) {
            
        } else {
            break;
        }
        var id = _keys2306[_ind2306]; var _ = _col2306[id];
        var item = pgraph.graph.getItem(id);
        if (id in commands) {
            var fields = commands[id].fields;
            fields.x = item.x;
            fields.y = item.y;
        } else {
            var command = new Command(
            	"update",
            	"nodes",
            	id,
            	{
            		x: item.x,
            		y: item.y
            	}
            );
            commands[id] = command;
        }
        _ind2306++;
    }
}

function buildPtrLeft(render, content, id, x, y, commList) {
    content.h0x = 20
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"f_ptr_left",
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_HEIGHT,
    	content
    );
}

function buildPtrRight(render, content, id, x, y, commList) {
    content.h0x = 20
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"f_ptr_right",
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_HEIGHT,
    	content
    );
}

function buildRounded(render, content, id, x, y, commList) {
    content.radius = RoundedRadius
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"f_rounded",
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_HEIGHT,
    	content
    );
}

function buildShelf(render, content, id, x, y, commList) {
    pushInsertFree(
    	render,
    	commList,
    	id,
    	"shelf",
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_HEIGHT * 2,
    	content
    );
}

function buildSideMarks(canvas) {
    var graph = canvas.graph;
    if (isFree(graph)) {
        
    } else {
        if (isSilhouette(graph)) {
            canvas.zone = 1;
            var _ind9653 = 0;
            var _col9653 = graph.nodes;
            var _keys9653 = Object.keys(_col9653); 
            var _len9653 = _keys9653.length;
            while (true) {
                if (_ind9653 < _len9653) {
                    
                } else {
                    break;
                }
                var nid = _keys9653[_ind9653]; var node = _col9653[nid];
                if (node.type === "branch") {
                    var newZone = makeNewZone(canvas);
                    stack = [];
                    mark2DownBig(stack, canvas,  node, newZone);
                }
                _ind9653++;
            }
        } else {
            var head = findHead(graph);
            canvas.zone = 2;
            var stack = [];
            mark2DownBig(stack, canvas,  head, 1);
        }
        var _ind3845 = 0;
        var _col3845 = graph.nodes;
        var _keys3845 = Object.keys(_col3845); 
        var _len3845 = _keys3845.length;
        while (true) {
            if (_ind3845 < _len3845) {
                
            } else {
                break;
            }
            var nid = _keys3845[_ind3845]; var node = _col3845[nid];
            if (node.type === "junction") {
                var type = describeJunction(node);
                var edge;
                if (type === "left-down") {
                    edge = graph.getEdge(
                    	node.down
                    );
                    node.mark = edge.upperMark
                } else {
                    if (type === "left-up") {
                        edge = graph.getEdge(
                        	node.up
                        );
                        node.mark = edge.upperMark
                    } else {
                        if (type === "right-down") {
                            edge = graph.getEdge(
                            	node.right
                            );
                            node.mark = edge.lowerMark
                        } else {
                            if (type === "right-up") {
                                edge = graph.getEdge(
                                	node.up
                                );
                                node.mark = edge.lowerMark
                            }
                        }
                    }
                }
            }
            _ind3845++;
        }
        if (Config.SHOW_ZONES) {
            drawMarks(canvas);
        }
    }
}

function buildSockets(editor, graph, initialId) {
    var sockets;
    if ((self.readonly) || (!(initialId in graph.items))) {
        sockets = [];
    } else {
        var id = findTransplantSource(graph, initialId)
        if (id) {
            editor.transplantSource = id;
            var item = graph.getItem(id);
            if (item.isLine) {
                
            } else {
                id = item.up;
            }
            if (item.type === "address") {
                sockets = findAddressSockets(
                	graph,
                	id
                );
            } else {
                if (isShortTExit(graph, item)) {
                    sockets = findTExitSockets(
                    	graph,
                    	item
                    );
                } else {
                    var poisoned = findPoisoned(
                    	graph,
                    	id
                    );
                    var isArrow = leadsToArrow(graph, id);
                    if (isBetweenTs(graph, item)) {
                        sockets = findTsSockets(
                        	graph,
                        	id,
                        	poisoned
                        );
                    } else {
                        if (isBetweenTs2(graph, item)) {
                            sockets = findTs2Sockets(
                            	graph,
                            	id,
                            	poisoned
                            );
                        } else {
                            sockets = findTargetSockets(
                            	graph,
                            	id,
                            	poisoned,
                            	isArrow
                            );
                        }
                    }
                }
            }
        } else {
            sockets = [];
        }
    }
    return sockets;
}

function buildTextBoxes() {
    var editor = self;
    buildBoxesForFree(editor)
    var graph = editor.storage.graph;
    var _ind16616 = 0;
    var _col16616 = graph.nodes;
    var _keys16616 = Object.keys(_col16616); 
    var _len16616 = _keys16616.length;
    while (true) {
        if (_ind16616 < _len16616) {
            
        } else {
            break;
        }
        var id = _keys16616[_ind16616]; var node = _col16616[id];
        var fields = Drakon.fitItem(node, render)
        node.tb = fields.tb
        node.tb2 = fields.tb2
        _ind16616++;
    }
    var free = editor.storage.free
    var _ind17970 = 0;
    var _col17970 = free.list;
    var _len17970 = _col17970.length;
    while (true) {
        if (_ind17970 < _len17970) {
            
        } else {
            break;
        }
        var id = _col17970[_ind17970];
        var item = free.get(id)
        var fields = Drakon.fitItem(item, render)
        item.tb = fields.tb
        item.tb2 = fields.tb2
        _ind17970++;
    }
}

function calculateCommandUndo(storage, command) {
    var _sw167400000_ = 0;
    var _sw28870000_ = 0;
    if (command.type === "insert") {
        _sw28870000_ = command.table;
        if (_sw28870000_ === "nodes") {
            command.fields.isLine = false;
        } else {
            if (_sw28870000_ === "edges") {
                command.fields.isLine = true;
            }
        }
    } else {
        var undo = {}
        var old
        var graph = storage.graph
        var free = storage.free
        _sw167400000_ = command.table;
        if ((_sw167400000_ === "nodes") || (_sw167400000_ === "edges")) {
            old = graph.getItem(command.id)
            if (command.type === "update") {
                takeOldValues(
                	command.fields,
                	old,
                	undo
                )
            } else {
                var _ind1665 = 0;
                var _col1665 = old;
                var _keys1665 = Object.keys(_col1665); 
                var _len1665 = _keys1665.length;
                while (true) {
                    if (_ind1665 < _len1665) {
                        
                    } else {
                        break;
                    }
                    var name = _keys1665[_ind1665]; var value = _col1665[name];
                    undo[name] = value;
                    _ind1665++;
                }
            }
        } else {
            if (_sw167400000_ === "free") {
                old = free.get(command.id)
                if (command.type === "update") {
                    takeOldValues(
                    	command.fields,
                    	old,
                    	undo
                    )
                } else {
                    var _ind1665 = 0;
                    var _col1665 = old;
                    var _keys1665 = Object.keys(_col1665); 
                    var _len1665 = _keys1665.length;
                    while (true) {
                        if (_ind1665 < _len1665) {
                            
                        } else {
                            break;
                        }
                        var name = _keys1665[_ind1665]; var value = _col1665[name];
                        undo[name] = value;
                        _ind1665++;
                    }
                }
            } else {
                if (_sw167400000_ === "diagrams") {
                    
                } else {
                    throw "Unexpected switch value: " + _sw167400000_;
                }
                takeOldValues(
                	command.fields,
                	storage,
                	undo
                )
            }
        }
        command.undo = undo;
    }
}

function calculateUndo(storage, commands) {
    var commands2 = normalizeCommands(commands)
    var _ind18142 = 0;
    var _col18142 = commands2;
    var _len18142 = _col18142.length;
    while (true) {
        if (_ind18142 < _len18142) {
            
        } else {
            break;
        }
        var command = _col18142[_ind18142];
        calculateCommandUndo(storage, command);
        _ind18142++;
    }
    return commands2;
}

function canAddMore(editor, count) {
    var graph = editor.storage.graph;
    var iconCount = getIconCount(graph);
    var total = iconCount + count;
    if (total > Config.MAX_ICONS) {
        showWarningPopup("Cannot add more icons to the diagram");
        return false;
    } else {
        return true;
    }
}

function canBeEdited(id) {
    if (id) {
        var item = getAnyItem(
        	self.storage,
        	id
        );
        if (((item) && (!(item.isLine))) && (!(item.type === "junction"))) {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function canCopyOne(graph, item) {
    var _sw124220000_ = 0;
    if (item.isLine) {
        return false;
    } else {
        _sw124220000_ = item.type;
        if (((((_sw124220000_ === "beginend") || (_sw124220000_ === "end")) || (_sw124220000_ === "address")) || (_sw124220000_ === "loopend")) || (_sw124220000_ === "junction")) {
            return false;
        } else {
            if (_sw124220000_ === "branch") {
                return true
            } else {
                return item.role != "params"
            }
        }
    }
}

function canDeleteBranch(graph, item) {
    var aboveId = graph.getNodeUp(item);
    var above = graph.getNode(aboveId);
    if (above.left) {
        var leftEdge = graph.getEdge(above.left);
        if (leftEdge.role === "rarrow") {
            return false;
        } else {
            if (above.right) {
                return true;
            } else {
                var left = graph.getNode(leftEdge.head)
                if (left.up) {
                    return false;
                } else {
                    return true;
                }
            }
        }
    } else {
        return false;
    }
}

function canDeleteCase(graph, caseNode) {
    var incoming = {};
    var upId = graph.getNodeUp(caseNode);
    var upNode = graph.getNode(upId);
    if (upNode.left) {
        if (upNode.right) {
            var id = graph.getNodeDown(caseNode);
            var can = canDeleteOnIfBranch(
            	graph,
            	id,
            	incoming
            );
            if (can) {
                var visited = {};
                return probeDeleteItem(graph, caseNode, visited);
            } else {
                return false;
            }
        } else {
            var leftId = graph.getNodeLeft(upNode);
            var left = graph.getNode(leftId);
            if (left.left) {
                var id = graph.getNodeDown(caseNode);
                var can = canDeleteOnIfBranch(
                	graph,
                	id,
                	incoming
                );
                if (can) {
                    var visited = {};
                    return probeDeleteItem(graph, caseNode, visited);
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
    } else {
        return false;
    }
}

function canDeleteIfBranch(graph, edgeId, incoming) {
    var edge = graph.getEdge(edgeId);
    var rightNode = graph.getTail(edge);
    if (isDegenerateExit(rightNode)) {
        return true;
    } else {
        var downEdge = graph.getEdge(rightNode.down);
        return canDeleteOnIfBranch(
        	graph,
        	downEdge.tail,
        	incoming
        );
    }
}

function canDeleteItem(editor, item) {
    var _sw24420000_ = 0;
    var graph = editor.storage.graph;
    if (item.isLine) {
        return false;
    } else {
        _sw24420000_ = item.type;
        if ((((_sw24420000_ === "junction") || (_sw24420000_ === "address")) || (_sw24420000_ === "end")) || (_sw24420000_ === "beginend")) {
            return false;
        } else {
            if (_sw24420000_ === "question") {
                return canDeleteQuestion(
                	graph,
                	item
                );
            } else {
                if (_sw24420000_ === "select") {
                    return canDeleteSelect(
                    	graph,
                    	item
                    );
                } else {
                    if (_sw24420000_ === "case") {
                        return canDeleteCase(
                        	graph,
                        	item
                        );
                    } else {
                        if (_sw24420000_ === "branch") {
                            return canDeleteBranch(
                            	graph,
                            	item
                            );
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
    }
}

function canDeleteOnIfBranch(graph, nodeId, incoming) {
    var _sw56170000_ = 0;
    var node = graph.getNode(nodeId);
    if (node.down) {
        var nextNodeId = graph.getNodeDown(
        	node
        );
        _sw56170000_ = node.type;
        if (_sw56170000_ === "junction") {
            if ((node.left) && (!(node.left in incoming))) {
                var leftNodeId = graph.getNodeLeft(
                	node
                );
                var leftNode = graph.getNode(
                	leftNodeId
                );
                if (leftNode.type === "question") {
                    return true;
                } else {
                    return false;
                }
            } else {
                return canDeleteOnIfBranch(
                	graph,
                	nextNodeId,
                	incoming
                );
            }
        } else {
            if (_sw56170000_ === "question") {
                var trunkOk = canDeleteOnIfBranch(
                	graph,
                	nextNodeId,
                	incoming
                );
                if (trunkOk) {
                    return canDeleteIfBranch(
                    	graph,
                    	node.right,
                    	incoming
                    );
                } else {
                    return false;
                }
            } else {
                if (_sw56170000_ === "select") {
                    var trunkOk = canDeleteOnIfBranch(
                    	graph,
                    	nextNodeId,
                    	incoming
                    );
                    if (trunkOk) {
                        return canDeleteSelectCore(
                        	graph,
                        	node,
                        	incoming
                        );
                    } else {
                        return false;
                    }
                } else {
                    return canDeleteOnIfBranch(
                    	graph,
                    	nextNodeId,
                    	incoming
                    );
                }
            }
        }
    } else {
        if (node.right) {
            incoming[node.right] = true;
        }
        return true;
    }
}

function canDeleteQuestion(graph, question) {
    var incoming = {};
    var can = canDeleteIfBranch(
    	graph,
    	question.right,
    	incoming
    );
    if (can) {
        var rightId =graph.getNodeRight(question);
        var right = graph.getNode(rightId);
        if (isDegenerateExit(right)) {
            return true;
        } else {
            var visited = {};
            return probeDeleteItem(graph, right, visited);
        }
    } else {
        return false;
    }
}

function canDeleteSelect(graph, select) {
    var incoming = {};
    var can = canDeleteSelectCore(
    	graph,
    	select,
    	incoming
    );
    if (can) {
        var visited = {};
        return probeDeleteSelect(
        	graph,
        	select,
        	visited
        );
    } else {
        return false;
    }
}

function canDeleteSelectCore(graph, select, incoming) {
    var joints = getSelectJoints(
    	graph,
    	select.id
    );
    var count = joints.length;
    var i;
    i = 1;
    while (true) {
        if (i < count) {
            
        } else {
            return true;
        }
        var joint = joints[i];
        var caseId = graph.getNodeDown(joint);
        var can = canDeleteOnIfBranch(
        	graph,
        	caseId,
        	incoming
        );
        if (can) {
            
        } else {
            return false;
        }
        i++;
    }
}

function canEditText(x, y) {
    var draggable = self.findVisualItem(
    	x,
    	y
    );
    if ((draggable) && (canBeEdited(draggable.id))) {
        return draggable.id;
    } else {
        return null;
    }
}

function canGo(edgeId, sourceEdge) {
    if ((edgeId) && (!(edgeId == sourceEdge))) {
        return true;
    } else {
        return false;
    }
}

function canGuide(item) {
    if (item.type == "f_line") {
        return false
    } else {
        return true
    }
}

function canGuideDrakon(item) {
    if (item.isLine) {
        return false
    } else {
        var type = item.type
        if (((((type == "duration") || (type == "junction")) || (type == "case")) || (type == "branch")) || (type == "address")) {
            return false
        } else {
            return true
        }
    }
}

function canHaveLink(item) {
    if (item.type in gNoLink) {
        return false
    } else {
        return true
    }
}

function canJoinTo(desc) {
    if (((desc === "left-down") || (desc === "left-up")) || (desc === "right-up")) {
        return desc;
    } else {
        return null;
    }
}

function canTransplantFrom(graph, id) {
    if (id) {
        var item = graph.getItem(id);
        if (item.isLine) {
            if (item.isVertical) {
                if (((item.role == "down") && (!(isEdgeOnMainSkewer(graph, item)))) && (!(hasItemsBelow(graph, item)))) {
                    return true;
                } else {
                    return false;
                }
            } else {
                if (((isShortTExit(graph, item)) || (isBetweenTs(graph, item))) || (isBetweenTs2(graph, item))) {
                    return true
                } else {
                    return false;
                }
            }
        } else {
            if (item.type === "address") {
                if (isOnBranchSkewer(graph, id)) {
                    return false;
                } else {
                    return true;
                }
            } else {
                if (item.type === "junction") {
                    var cat = describeJunction(item);
                    if ((cat == "left-up") && (questionOnLeft(graph, item))) {
                        return true;
                    } else {
                        if (item.up) {
                            return canTransplantFrom(graph, item.up);
                        } else {
                            return false;
                        }
                    }
                } else {
                    if (item.up) {
                        return canTransplantFrom(graph, item.up);
                    } else {
                        return false;
                    }
                }
            }
        }
    } else {
        return false;
    }
}

function changeBackground(x, y) {
    var fun = Callbacks.changeBackground
    if (fun) {
        fun(x, y)
    }
}

function changeFormat(x, y, ids) {
    var fun = Callbacks.changeFormat
    if (fun) {
        fun(x, y, ids)
    }
}

function changeMindElementType(id, type) {
    addTrace(
    	"change type",
    	[id, type]
    )
    var fields = {
    	type: type
    }
    if (type == "raction") {
        var graph = self.storage.graph
        var item = graph.getNode(id)
        var content = Utils.copyObject(item.content)
        content.radius = RoundedRadius
        fields.content = content
    }
    var command = new Command(
    	"update",
    	"nodes",
    	id,
    	fields
    )
    var commands = [command]
    applyCommands(
    	self,
    	commands,
    	null
    )
}

function changeMindGrip(grip) {
    var _sw216040000_ = 0;
    if (isMind()) {
        _sw216040000_ = grip.name;
        if (_sw216040000_ === Const.DRN_SIZE_R) {
            grip.name = Const.MIND_SIZE_R
        } else {
            if (_sw216040000_ === Const.DRN_SIZE_L) {
                grip.name = Const.MIND_SIZE_L
            }
        }
    }
}

function changeYesNo() {
    var fun = Callbacks.changeYesNo
    if (fun) {
        fun()
    }
}

function checkGuide(guide, other, min, max) {
    if (guide.edge == other) {
        guide.found = true
        guide.min = Math.min(guide.min, min)
        guide.max = Math.max(guide.max, max)
    }
}

function clearFormat(ids, format) {
    if (ignoreCommand()) {
        
    } else {
        var editor = self
        var makeContent = function(item) {
        	var old = getContent(item)
        	var newContent = removeFormat(old)
        	return newContent
        }
        setContentForManyItems(
        	editor,
        	ids,
        	makeContent
        )
    }
}

function clearPathForSquare(pgraph, x, x2, yUp, dims, downNode, movedNodes) {
    rayTraceRight(
    	pgraph,
    	x,
    	x2,
    	yUp,
    	movedNodes
    );
    rayTraceDown(
    	pgraph,
    	x2,
    	yUp,
    	dims.y + Config.METRE,
    	movedNodes
    );
    if (dims.y > downNode.y) {
        rayTraceDownEx(
        	pgraph,
        	downNode.x,
        	downNode.y,
        	dims.y,
        	downNode.id,
        	movedNodes
        );
    }
}

function clearUndo() {
    self.undo = new Undo();
}

function clickMindSocket(socket) {
    if (socket.type == "paste") {
        var subtree = getClipboard("mind")
        if (subtree) {
            mindPasteAction(
            	socket.action.action,
            	socket.action.itemId,
            	subtree
            )
        }
    } else {
        mindAction(
        	socket.action.action,
        	socket.action.itemId,
        	socket.action.socketType
        )
    }
    redraw()
}

function clickSocket(prim) {
    var _sw122140000_ = 0;
    if (ignoreCommand()) {
        return null
    } else {
        var res;
        var socket =  self.canvas.sockets[prim];
        if (isMind()) {
            clickMindSocket(
            	socket
            )
        } else {
            _sw122140000_ = socket.type;
            if (_sw122140000_ === "liana") {
                res = transplantLiana(self, prim);
            } else {
                if (_sw122140000_ === "insert") {
                    res = insertInSocket(self, prim);
                } else {
                    if (_sw122140000_ === "paste") {
                        res = pasteInSocket(self, prim);
                    } else {
                        res = null;
                    }
                }
            }
        }
        commandDone();
        return res;
    }
}

function clipTypeToSocket(type) {
    var map = {
        "block": "clip-block",
        "case": "clip-case",
        "branch": "clip-branch",
    	"duration": "clip-duration",
    	"mind": "mind-clip"
    }
    return map[type]
}

function cloneDictionary(input) {
    var output = {};
    var _ind4775 = 0;
    var _col4775 = input;
    var _keys4775 = Object.keys(_col4775); 
    var _len4775 = _keys4775.length;
    while (true) {
        if (_ind4775 < _len4775) {
            
        } else {
            break;
        }
        var key = _keys4775[_ind4775]; var value = _col4775[key];
        var clone = cloneNotEmpty(value);
        output[key] = clone;
        _ind4775++;
    }
    return output;
}

function cloneNotEmpty(object) {
    var clone = {};
    var _ind4763 = 0;
    var _col4763 = object;
    var _keys4763 = Object.keys(_col4763); 
    var _len4763 = _keys4763.length;
    while (true) {
        if (_ind4763 < _len4763) {
            
        } else {
            break;
        }
        var key = _keys4763[_ind4763]; var value = _col4763[key];
        if (value === null) {
            
        } else {
            clone[key] = value;
        }
        _ind4763++;
    }
    return clone;
}

function collapseBolt(editor, edgeId) {
    var editing = collapseBoltCore(
    	editor,
    	edgeId
    )
    applyCommands(
    	editor,
    	editing.commandList,
    	null
    )
}

function collapseBoltCore(editor, edgeId) {
    addTrace(
    	"remove line",
    	[edgeId]
    );
    var movedNodes = {};
    var commands = {};
    var pgraph = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    );
    var graph = pgraph.graph;
    var edge = graph.getEdge(edgeId);
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    var delta = tail.y - head.y;
    var leftEdge = graph.getEdge(head.left);
    var rightEdge = graph.getEdge(tail.right);
    pgraph.deletePhysicalItem(
    	head.left
    );
    pgraph.deletePhysicalItem(
    	edgeId
    );
    pgraph.deletePhysicalItem(
    	head.id
    );
    rebuildPhysicsCache(pgraph);
    pgraph.moveDown(
    	tail.id,
    	-delta,
    	movedNodes
    );
    delete movedNodes[tail.id];
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	leftEdge.id
    );
    pushDeleteEdge(
    	commandList,
    	edgeId
    );
    pushDeleteEdge(
    	commandList,
    	rightEdge.id
    );
    pushDeleteNode(
    	commandList,
    	head.id
    );
    pushDeleteNode(
    	commandList,
    	tail.id
    );
    var newEdge = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	newEdge,
    	leftEdge.head,
    	rightEdge.tail,
    	null
    );
    return {
    	commandList: commandList
    }
}

function combineRunCommands(edit, newCommands) {
    var newList = Utils.objectValues(newCommands)
    if (newList.length == 0) {
        
    } else {
        edit.dirty = true
        var newList2 = calculateUndo(
        	self.storage,
        	newList
        )
        performLocalChange(
        	self,
        	newList2,
        	false
        )
        edit.commands = edit.commands.concat(newList2)
    }
}

function commandDone() {
    var fun = Callbacks.commandDone;
    if (fun) {
        fun();
    }
}

function concatAndSaveUndo(editor, commandList1, commandList2, before, after) {
    var commandList = commandList1.concat(
    	commandList2
    )
    commandList = normalizeCommands(commandList)
    addToUndo(editor.undo, before, commandList, after)
}

function connectHor(editor, commList, left, right, role) {
    var id = generateId(editor.storage);
    pushInsertHorizontal(
    	commList,
    	id,
    	left,
    	right,
    	role
    );
}

function connectVer(editor, commList, up, down, role) {
    var id = generateId(editor.storage);
    pushInsertVertical(
    	commList,
    	id,
    	up,
    	down,
    	role
    );
    return id
}

function contEqual(cont1, cont2) {
    if (cont1) {
        if (((cont2) && (cont1.txt == cont2.txt)) && (cont1.txt2 == cont2.txt2)) {
            return true;
        } else {
            return false;
        }
    } else {
        if (cont2) {
            return false;
        } else {
            return true;
        }
    }
}

function convertGroup(idMap, node) {
    if (node.group) {
        if (node.group in idMap) {
            return idMap[node.group];
        } else {
            return node.group;
        }
    } else {
        return null;
    }
}

function copy() {
    if (isMind()) {
        editAction(
        	function(editor, id) { copyMind(id, false) },
        	function() { },
        	function(editor, ids) { copyFree(editor, ids, true, false) }
        )
    } else {
        editAction(
        	function(editor, id) { copyOne(editor, id, false) },
        	function() { copyBlock(true, false) },
        	function(editor, ids) { copyFree(editor, ids, true, false) }
        )
    }
}

function copyAndSort(items, free) {
    var error = null
    if (items) {
        var sorted = Utils.sortLinkedList(items, "next")
        var _ind16779 = 0;
        var _col16779 = sorted;
        var _len16779 = _col16779.length;
        while (true) {
            if (_ind16779 < _len16779) {
                
            } else {
                break;
            }
            var item = _col16779[_ind16779];
            free.add(item.id, item)
            _ind16779++;
        }
        var keys = Object.keys(items)
        if (keys.length == free.list.length) {
            
        } else {
            error = "ERR_FREE_ORDER"
        }
    }
    return error
}

function copyBlock(doCopy, andDelete) {
    addTrace(
    	"copy block",
    	[doCopy, andDelete]
    );
    var right = null;
    var lower = null;
    var selection = copySelection(
    	self.storage.selection
    )
    var gblock = selection.block;
    if ((gblock) && (gblock.top)) {
        var graph = self.storage.graph;
        var render = self.render;
        var edges = {};
        var _ind14221 = 0;
        var _col14221 = gblock.nodes;
        var _keys14221 = Object.keys(_col14221); 
        var _len14221 = _keys14221.length;
        while (true) {
            if (_ind14221 < _len14221) {
                
            } else {
                break;
            }
            var nodeId = _keys14221[_ind14221]; var _ = _col14221[nodeId];
            var node = graph.getNode(nodeId);
            Utils.addNotNilToSet(edges, node.left);
            Utils.addNotNilToSet(edges, node.up);
            Utils.addNotNilToSet(edges, node.right);
            Utils.addNotNilToSet(edges, node.down);
            _ind14221++;
        }
        var topNode = graph.getNode(gblock.top);
        var bottomNode = graph.getNode(gblock.bottom);
        delete edges[topNode.up];
        if (hasLeft(graph, bottomNode)) {
            lower = findBottomNodes(
            	graph,
            	gblock.nodes,
            	bottomNode
            );
            var rid = lower[lower.length - 1];
            right = graph.getNode(rid);
            delete edges[bottomNode.left];
            if (right.right) {
                delete edges[right.right];
            }
        } else {
            delete edges[bottomNode.down];
        }
        var graph2 = copyGraphSection(
        	graph,
        	gblock.nodes,
        	edges,
        	gblock.top
        );
        var subgraph = {
        	graph: graph2,
        	first: gblock.top,
        	last: gblock.bottom
        };
        if (lower) {
            cutOffSilhBottom(
            	subgraph,
            	lower
            );
        }
        if (andDelete) {
            addTrace(
            	"delete subgraph",
            	[gblock.top, gblock.bottom]
            );
            var addressId = null;
            if (lower) {
                edges[topNode.up] = true;
                delete gblock.nodes[bottomNode.id];
                delete edges[bottomNode.up];
                addressId = graph.getNodeUp(bottomNode);
                delete gblock.nodes[addressId];
                if (right.right) {
                    edges[right.right] = true;
                }
            } else {
                edges[topNode.up] = true;
                edges[bottomNode.down] = true;
            }
            var commandList = [];
            pushDeleteSubgraph(
            	commandList,
            	gblock.nodes,
            	edges
            );
            var edgeId = null
            if (lower) {
                var aboveId = graph.getNodeUp(topNode);
                connectVer(
                	self,
                	commandList,
                	aboveId,
                	addressId,
                	"down",
                	null
                );
                if (right.right) {
                    var afterRightId = graph.getNodeRight(right);
                    connectHor(
                    	self,
                    	commandList,
                    	bottomNode.id,
                    	afterRightId,
                    	"sil_floor",
                    	null
                    );
                    delete edges[right.right];
                }
            } else {
                var aboveId = graph.getNodeUp(topNode);
                var belowId = graph.getNodeDown(bottomNode);
                var oldLowEdge = graph.getEdge(bottomNode.down);
                var oldRole = oldLowEdge.role;
                edgeId = connectVer(
                	self,
                	commandList,
                	aboveId,
                	belowId,
                	oldRole,
                	null
                );
            }
            runAndCollapse(
            	self,
            	commandList,
            	edgeId
            )
        }
        if (doCopy) {
            addTrace(
            	"copy subgraph",
            	[gblock.top, gblock.bottom]
            );
            var type = "block";
            var socket = "clip-block";
            copyToClipboard(
            	type,
            	subgraph
            );
            if (self.readonly) {
                
            } else {
                showInsertionSockets(socket);
            }
        }
        commandDone();
    }
}

function copyBranch(render, graph, id) {
    var bgraph = findBranchGraph(graph, id);
    if (bgraph) {
        var nodes = bgraph.nodes;
        var edges = bgraph.edges;
        var graph2 = copyGraphSection(
        	graph,
        	nodes,
        	edges,
        	bgraph.top
        );
        replaceExit(render, bgraph, graph2)
        return {
        	graph: graph2,
        	top: bgraph.top,
        	bottom: bgraph.bottom,
        	rBottom: bgraph.rBottom
        };
    } else {
        return null
    }
}

function copyCoreBranchInfo(output, node) {
    var text = getContent(node).txt || ""
    if (text) {
        var item = {
        	id: node.id,
        	x: node.x,
        	text: text,
        	marked: false
        }
        output.push(item)
    }
}

function copyFree(editor, ids, doCopy, andDelete) {
    var free = editor.storage.free
    if (doCopy) {
        var linkedList = []
        var idSet = Utils.listToSet(ids)
        var _ind17285 = 0;
        var _col17285 = free.list;
        var _len17285 = _col17285.length;
        while (true) {
            if (_ind17285 < _len17285) {
                
            } else {
                break;
            }
            var id = _col17285[_ind17285];
            if (id in idSet) {
                linkedList.push({
                	id: id,
                	next: ""
                })
            }
            _ind17285++;
        }
        setNextPointers(linkedList)
        var items = []
        var _ind17163 = 0;
        var _col17163 = linkedList;
        var _len17163 = _col17163.length;
        while (true) {
            if (_ind17163 < _len17163) {
                
            } else {
                break;
            }
            var node = _col17163[_ind17163];
            var original = free.get(node.id)
            var item = copyStorageItem(original)
            item.next = node.next
            items.push(item)
            _ind17163++;
        }
        var payload = {
        	items: items
        }
        copyToClipboard(
        	"free",
        	payload
        );
    }
    if (andDelete) {
        deleteFreeItems(editor, ids)
    }
}

function copyGraphSection(graph, nodes, edges, startId) {
    var graph2 = copyGraphSectionNoMove(
    	graph,
    	nodes,
    	edges
    );
    var start = graph.getNode(startId);
    moveGraphBy(graph2, -start.x, -start.y);
    return graph2;
}

function copyGraphSectionNoMove(graph, nodes, edges) {
    var graph2 = new Utils.Manhattan();
    var _ind13192 = 0;
    var _col13192 = nodes;
    var _keys13192 = Object.keys(_col13192); 
    var _len13192 = _keys13192.length;
    while (true) {
        if (_ind13192 < _len13192) {
            
        } else {
            break;
        }
        var id = _keys13192[_ind13192]; var _ = _col13192[id];
        var node = graph.getNode(id);
        var node2 = Utils.copyObject(node);
        node2.left = null;
        node2.up = null;
        node2.right = null;
        node2.down = null;
        graph2.addItem(node2);
        _ind13192++;
    }
    var _ind13197 = 0;
    var _col13197 = edges;
    var _keys13197 = Object.keys(_col13197); 
    var _len13197 = _keys13197.length;
    while (true) {
        if (_ind13197 < _len13197) {
            
        } else {
            break;
        }
        var id = _keys13197[_ind13197]; var _ = _col13197[id];
        var edge = graph.getEdge(id);
        var edge2 = Utils.copyObject(edge);
        graph2.addItem(edge2);
        _ind13197++;
    }
    return graph2;
}

function copyMind(itemId, andDelete) {
    var graph = self.storage.graph
    var subtree = Mind.copySubtree(
    	graph,
    	itemId
    )
    copyToClipboard(
    	"mind",
    	subtree
    )
    if (andDelete) {
        deleteMind(itemId)
    }
    showInsertionSockets("mind-clip")
}

function copyOne(editor, id, cut) {
    var _sw128790000_ = 0;
    var subgraph = null;
    var type = "block";
    var graph = editor.storage.graph;
    var render = editor.render;
    var main = graph.getItem(id);
    if (canCopyOne(graph, main)) {
        _sw128790000_ = main.type;
        if (_sw128790000_ === "question") {
            subgraph = buildMacroQuestion(
            	render,
            	main.content,
            	main.flag1
            );
            if (subgraph) {
                copyToClipboard(
                	type,
                	subgraph
                );
                if (self.readonly) {
                    
                } else {
                    if (cut) {
                        deleteItem(editor, id);
                    }
                    var socket = clipTypeToSocket(type)
                    if (socket) {
                        showInsertionSockets(socket);
                    }
                }
            }
        } else {
            if (_sw128790000_ === "select") {
                var cases = findCases(graph, main);
                subgraph = buildMacroSelect(
                	render,
                	main.content,
                	cases
                );
                if (subgraph) {
                    copyToClipboard(
                    	type,
                    	subgraph
                    );
                    if (self.readonly) {
                        
                    } else {
                        if (cut) {
                            deleteItem(editor, id);
                        }
                        var socket = clipTypeToSocket(type)
                        if (socket) {
                            showInsertionSockets(socket);
                        }
                    }
                }
            } else {
                if (_sw128790000_ === "loopbegin") {
                    var lowId = Drakon.findEndLoop(graph, main);
                    var low = graph.getNode(lowId);
                    subgraph = buildMacroLoop(
                    	render,
                    	main.content,
                    	low.content
                    );
                    if (subgraph) {
                        copyToClipboard(
                        	type,
                        	subgraph
                        );
                        if (self.readonly) {
                            
                        } else {
                            if (cut) {
                                deleteItem(editor, id);
                            }
                            var socket = clipTypeToSocket(type)
                            if (socket) {
                                showInsertionSockets(socket);
                            }
                        }
                    }
                } else {
                    if (_sw128790000_ === "case") {
                        subgraph = {
                        	content: main.content
                        };
                        type = "case";
                        if (subgraph) {
                            copyToClipboard(
                            	type,
                            	subgraph
                            );
                            if (self.readonly) {
                                
                            } else {
                                if (cut) {
                                    deleteItem(editor, id);
                                }
                                var socket = clipTypeToSocket(type)
                                if (socket) {
                                    showInsertionSockets(socket);
                                }
                            }
                        }
                    } else {
                        if (_sw128790000_ === "branch") {
                            subgraph = copyBranch(render, graph, id);
                            if (subgraph) {
                                type = "branch";
                                if (subgraph) {
                                    copyToClipboard(
                                    	type,
                                    	subgraph
                                    );
                                    if (self.readonly) {
                                        
                                    } else {
                                        if (cut) {
                                            deleteItem(editor, id);
                                        }
                                        var socket = clipTypeToSocket(type)
                                        if (socket) {
                                            showInsertionSockets(socket);
                                        }
                                    }
                                }
                            }
                        } else {
                            if (_sw128790000_ === "duration") {
                                subgraph = main.content;
                                type = "duration";
                                if (subgraph) {
                                    copyToClipboard(
                                    	type,
                                    	subgraph
                                    );
                                    if (self.readonly) {
                                        
                                    } else {
                                        if (cut) {
                                            deleteItem(editor, id);
                                        }
                                        var socket = clipTypeToSocket(type)
                                        if (socket) {
                                            showInsertionSockets(socket);
                                        }
                                    }
                                }
                            } else {
                                if (main.role == "params") {
                                    
                                } else {
                                    subgraph = buildMacroSimple(
                                    	render,
                                    	main.type,
                                    	main.content
                                    );
                                    if (subgraph) {
                                        copyToClipboard(
                                        	type,
                                        	subgraph
                                        );
                                        if (self.readonly) {
                                            
                                        } else {
                                            if (cut) {
                                                deleteItem(editor, id);
                                            }
                                            var socket = clipTypeToSocket(type)
                                            if (socket) {
                                                showInsertionSockets(socket);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function copyPoints(src, dst) {
    var _ind19114 = 0;
    var _col19114 = src;
    var _len19114 = _col19114.length;
    while (true) {
        if (_ind19114 < _len19114) {
            
        } else {
            break;
        }
        var point = _col19114[_ind19114];
        var copy = {
        	x: point.x,
        	y: point.y,
        	id: point.id
        }
        dst.push(copy)
        _ind19114++;
    }
}

function copySelection(selection) {
    if ((selection) && (selection.ids)) {
        return Utils.copyObjectDeep(selection);
    } else {
        return createSelection();
    }
}

function copyState(editor) {
    var selection = copySelection(
    	editor.storage.selection
    );
    var pan = null;
    return {
    	origin: pan,
    	selection: selection
    };
}

function copyStorageItem(item) {
    var copy = {
    	id:	item.id,
    	type:	item.type,
    	isLine: item.isLine,
    	isVertical: item.isVertical,
    	x:	item.x,
    	y:	item.y,
    	w:	item.w,
    	h:	item.h,
    	a:	item.a,
    	b:	item.b,
    	content:	item.content,
    	head:	item.head,
    	tail:	item.tail,
    	flag1:  item.flag1,
    	role:   item.role,
    	group: item.group,
    	tb: item.tb,
    	free: item.free,
    	next: item.next
    };
    if (item.tb2) {
        copy.tb2 = item.tb2;
    }
    return copy;
}

function copyText(editor, cont) {
    var content = {
    	content: cont
    };
    copyToClipboard("text", content);
}

function copyToClipboard(type, subgraph) {
    var fun = Callbacks.copyToClipboard;
    if (fun) {
        fun(type, subgraph);
    }
}

function createBoltMenuItem(editor, edge) {
    return	{type: "item", text: tr("MES_REMOVE_LINE"),
    	      image: "collapse.png",
    		code: function() {
    			collapseBolt(editor, edge.id);
    	}};
}

function createCycle(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var commands = {};
    extendEdge(
    	pgraph,
    	target,
    	0,
    	movedNodes
    );
    var sourceEdge = graph.getEdge(
    	source
    );
    var sourceTail = graph.getTail(
    	sourceEdge
    );
    var sourceHead = graph.getHead(
    	sourceEdge
    );
    var targetEdge = graph.getEdge(
    	target
    );
    var targetTail = graph.getTail(
    	targetEdge
    );
    var dims = findLedgeDimensions(
    	graph,
    	targetTail.id,
    	sourceTail.id
    );
    var x = targetTail.x;
    var x2 = dims.x;
    var y = targetTail.box.top - Config.METRE;
    clearPathForSquare(
    	pgraph,
    	x,
    	x2,
    	y,
    	dims,
    	sourceTail,
    	movedNodes
    );
    if ((isDownLeft(sourceHead)) && (dims.y > sourceHead.y)) {
        var dy = dims.y - sourceHead.y
        pgraph.moveDown(
        	sourceHead.id,
        	dy,
        	movedNodes
        );
    }
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    pushDeleteEdge(
    	commandList,
    	targetEdge.id
    );
    var upperJun = insertJunctionBetween(
    	editor,
    	graph,
    	targetEdge.head,
    	targetEdge.tail,
    	y,
    	commandList
    );
    var arrowId = generateId(editor.storage);
    var upRightId = generateId(editor.storage);
    var upId = generateId(editor.storage);
    pushInsertJunction(
    	commandList,
    	upRightId,
    	x2,
    	y
    );
    pushInsertHorizontal(
    	commandList,
    	arrowId,
    	upperJun,
    	upRightId,
    	"arrow"
    );
    if (isDownLeft(sourceHead)) {
        pushUpdate(
        	commandList,
        	"nodes",
        	sourceHead.id,
        	{
        		x: x2
        	}
        )
        pushInsertVertical(
        	commandList,
        	upId,
        	upRightId,
        	sourceHead.id,
        	null
        );
    } else {
        var downRightId = generateId(editor.storage);
        var rightId = generateId(editor.storage);
        var downLeftId = generateId(editor.storage);
        var downId = generateId(editor.storage);
        pushInsertJunction(
        	commandList,
        	downRightId,
        	x2,
        	dims.y
        );
        pushInsertJunction(
        	commandList,
        	downLeftId,
        	sourceHead.x,
        	dims.y
        );
        pushInsertVertical(
        	commandList,
        	upId,
        	upRightId,
        	downRightId,
        	null
        );
        pushInsertHorizontal(
        	commandList,
        	rightId,
        	downLeftId,
        	downRightId,
        	"right"
        );
        pushInsertDown(
        	commandList,
        	downId,
        	sourceHead.id,
        	downLeftId
        );
    }
    return commandList;
}

function createDiagram(name, type) {
    var storage = new Storage(self.persistence)
    storage.type = type
    storage.version = Config.DIAGRAM_VERSION
    setStorage(self, storage)
    var commList = [];
    var render = self.render;
    var font = getDefault("font")
    if (font) {
        
    } else {
        font = Utils.buildFontString(
        	false,
        	false,
        	Config.FONT_SIZE,
        	Config.FONT_FAMILY
        )
    }
    self.render.setDefaultFont(
    	font
    )
    if (type === "drakon") {
        var cEnd = makeCont(getEnd());
        var header = createHeader(name)
        var footer = makeDummyItem(
        	2,
        	render,
        	"end",
        	cEnd
        );
        var headerY = 100;
        var x = 300;
        var footerY = headerY + header.h + footer.h + 200;
        header.x = x;
        header.y = headerY;
        header.role = "header";
        footer.x = x;
        footer.y = footerY;
        footer.w = Config.MIN_ICON_WIDTH;
        var headerId = generateId(self.storage);
        var footerId = generateId(self.storage);
        var edgeId = generateId(self.storage);
        pushInsertNode(
        	commList,
        	headerId,
        	header
        );
        pushInsertNode(
        	commList,
        	footerId,
        	footer
        );
        pushInsertDown(
        	commList,
        	edgeId,
        	headerId,
        	footerId
        );
    } else {
        if (type === "mind") {
            self.storage.nextId = createMind(
            	render,
            	name,
            	commList
            )
        }
    }
    setNotNullFields(
    	commList,
    	["background", "diaLine"]
    )
    setNotNullFields(
    	commList,
    	["background", "diaLineThickness"]
    )
    commList.push(new Command(
    	"update",
    	"diagrams",
    	"diagram",
    	{font: font}
    ));
    var state = {
    	origin: null,
    	selection: createSelection()
    };
    self.storage.name = name;
    executeCommands(
    	self,
    	commList,
    	state,
    	false,
    	false,
    	new ActionInfo("create diagram", [name])
    );
    persistChanges(commList, false)
}

function createGraph(obj) {
    var graph = new Utils.Manhattan();
    var _ind13042 = 0;
    var _col13042 = obj.nodes;
    var _keys13042 = Object.keys(_col13042); 
    var _len13042 = _keys13042.length;
    while (true) {
        if (_ind13042 < _len13042) {
            
        } else {
            break;
        }
        var id = _keys13042[_ind13042]; var node = _col13042[id];
        graph.addItem(node);
        _ind13042++;
    }
    var _ind13045 = 0;
    var _col13045 = obj.edges;
    var _keys13045 = Object.keys(_col13045); 
    var _len13045 = _keys13045.length;
    while (true) {
        if (_ind13045 < _len13045) {
            
        } else {
            break;
        }
        var id = _keys13045[_ind13045]; var edge = _col13045[id];
        graph.addItem(edge);
        _ind13045++;
    }
    return graph;
}

function createHeader(name) {
    var cName = makeHeaderCont(name);
    var header = makeDummyItem(
    	1,
    	render,
    	"duration",
    	cName
    )
    header.type = "beginend"
    header.w = Math.max(Config.DEF_ICON_WIDTH_S, header.w)
    return header
}

function createInsertBranchMenuItem(editor, item) {
    return { 
        type: "item", text: tr("MES_INSERT_BRANCH"),
        image: "branch.png",
        code: function(){
            insertAndEdit(editor, item.id, "branch");
        }};
}

function createInsertCaseMenuItem(editor, item) {
    return {
      type: "item", text: tr("MES_INSERT_CASE"),
      image: "case.png",
      code: function(){
    	insertAndEdit(editor, item.id, "case");
    }};
}

function createInsertEndBranchMenuItem(editor, item) {
    return { 
        type: "item", text: tr("MES_INSERT_END_BRANCH"),
        image: "end.png",
        code: function(){
            insertAndEdit(editor, item.id, "end_branch");
        }};
}

function createItemDraggable(editor, itemId, x, y) {
    var url
    var item = getAnyItem(editor.storage, itemId)
    var link = Items.getLinkHandle(item)
    if (link) {
        url = link.link
        var box = Utils.boxFromPoint(
        	link.x,
        	link.y,
        	Config.GRIP_TOUCH,
        	Config.GRIP_TOUCH
        )
        if (Utils.hitBox(box, x, y)) {
            var result = new Draggable(
            	itemId,
            	Const.LINK,
            	null
            )
            result.data = url
            return result
        } else {
            if ((item.type === "insertion") && (hitText(item, x, y))) {
                if (link) {
                    var result = new Draggable(
                    	itemId,
                    	Const.LINK,
                    	null
                    )
                    result.data = url
                    return result
                } else {
                    var result = new Draggable(
                    	itemId,
                    	Const.SUB,
                    	null
                    )
                    result.data = url
                    return result
                }
            } else {
                return new Draggable(
                	itemId,
                	Const.DRN_MOVE,
                	null
                );
            }
        }
    } else {
        if (item.content) {
            url = item.content.txt
        } else {
            url = undefined
        }
        if ((item.type === "insertion") && (hitText(item, x, y))) {
            if (link) {
                var result = new Draggable(
                	itemId,
                	Const.LINK,
                	null
                )
                result.data = url
                return result
            } else {
                var result = new Draggable(
                	itemId,
                	Const.SUB,
                	null
                )
                result.data = url
                return result
            }
        } else {
            return new Draggable(
            	itemId,
            	Const.DRN_MOVE,
            	null
            );
        }
    }
}

function createMind(render, name, commList) {
    var header = createHeader(name)
    header.id = "1"
    header.x = 100
    header.y = 100
    header.role = "header"
    pushInsertNode(
    	commList,
    	header.id,
    	header
    )
    return 2
}

function createMindHor(render, name, commList) {
    var cName = makeHeaderCont(name)
    var id = 1
    var header = makeDummyItem(
    	id++,
    	render,
    	"beginend",
    	cName
    )
    var sub1 = makeDummyItem(
    	id++,
    	render,
    	"action",
    	makeRCont()
    )
    var sub2 = makeDummyItem(
    	id++,
    	render,
    	"action",
    	makeRCont()
    )
    var sub3 = makeDummyItem(
    	id++,
    	render,
    	"action",
    	makeRCont()
    )
    header.y = 100
    var midY = header.y + header.h +
    	Config.METRE
    var subY = midY + sub1.h + 
    	Config.METRE
    sub1.y = subY
    sub2.y = subY
    sub3.y = subY
    header.role = "header"
    header.x = 100
    sub1.x = header.x - sub1.w * 2 -
    	Config.METRE
    sub2.x = header.x
    sub3.x = header.x + sub1.w * 2 +
    	Config.METRE
    pushInsertNode(
    	commList,
    	header.id,
    	header
    )
    pushInsertNode(
    	commList,
    	sub1.id,
    	sub1
    )
    pushInsertNode(
    	commList,
    	sub2.id,
    	sub2
    )
    pushInsertNode(
    	commList,
    	sub3.id,
    	sub3
    )
    var j1 = String(id++)
    var j2 = String(id++)
    var j3 = String(id++)
    pushInsertJunction(
    	commList,
    	j1,
    	sub1.x,
    	midY
    )
    pushInsertJunction(
    	commList,
    	j2,
    	sub2.x,
    	midY
    )
    pushInsertJunction(
    	commList,
    	j3,
    	sub3.x,
    	midY
    )
    pushInsertVertical(
    	commList,
    	id++,
    	header.id,
    	j2,
    	null
    )
    pushInsertVertical(
    	commList,
    	id++,
    	j1,
    	sub1.id,
    	null
    )
    pushInsertVertical(
    	commList,
    	id++,
    	j2,
    	sub2.id,
    	null
    )
    pushInsertVertical(
    	commList,
    	id++,
    	j3,
    	sub3.id,
    	null
    )
    pushInsertHorizontal(
    	commList,
    	id++,
    	j1,
    	j2,
    	"bridge"
    )
    pushInsertHorizontal(
    	commList,
    	id++,
    	j2,
    	j3,
    	"bridge"
    )
    return id
}

function createPhysicalGraph(graph, render) {
    var expands
    if (isMind()) {
        expands = Mind.getSoftExpanders()
    } else {
        expands = getSoftExpanders()
    }
    var pgraph = new PhysicalGraph(
    	Items,
    	graph,
    	render,
    	expands
    );
    return pgraph;
}

function createSelection() {
    var simplified = isMind()
    return new Drakon.Selection(simplified)
}

function createTask(itemId) {
    var task = new Mind.ME()
    task.graph(self.storage.graph)
    task.itemId(itemId)
    task.render(self.render)
    task.nextId(self.storage.nextId)
    task.items(Items)
    return task
}

function cut() {
    if (ignoreCommand()) {
        
    } else {
        if (isMind()) {
            editAction(
            	function(editor, id) { copyMind(id, true) },
            	function() { },
            	function(editor, ids) { copyFree(editor, ids, true, true) }
            )
        } else {
            editAction(
            	function(editor, id) { copyOne(editor, id, true) },
            	function() { copyBlock(true, true) },
            	function(editor, ids) { copyFree(editor, ids, true, true) }
            )
        }
    }
}

function cutOffSilhBottom(subgraph, lower) {
    var graph = subgraph.graph;
    var map = {};
    var id = graph.getMaxId() + 1;
    var prev = null;
    var _ind14357 = 0;
    var _col14357 = lower;
    var _len14357 = _col14357.length;
    while (true) {
        if (_ind14357 < _len14357) {
            
        } else {
            break;
        }
        var lowNodeId = _col14357[_ind14357];
        var lowNode = graph.getNode(lowNodeId);
        var address = graph.getNodeUpEx(lowNode);
        var above = graph.getNodeUpEx(address);
        var x = lowNode.x;
        var y = lowNode.y;
        graph.removeItem(address.up);
        graph.removeItem(address.down);
        if (lowNode.right) {
            graph.removeItem(lowNode.right);
        }
        graph.removeItem(lowNode.id);
        graph.removeItem(address.id);
        map[lowNodeId] = id;
        var junc = makeDummyJunction(id++, x, y);
        graph.addItem(junc);
        graph.addItem(makeDummyLine(
        	id++,
        	true,
        	above.id,
        	junc.id,
        	"down"
        ));
        if (prev) {
            graph.addItem(makeDummyLine(
            	id++,
            	false,
            	prev.id,
            	junc.id,
            	"left"
            ));
        }
        prev = junc;
        _ind14357++;
    }
    subgraph.last = map[subgraph.last];
}

function darkenSocket(prim) {
    self.canvas.render.setItemProperty(prim, "active", false);
    self.dirty = true;
}

function defaultBuilder(render, content, id, type, x, y, commList) {
    pushInsertFree(
    	render,
    	commList,
    	id,
    	type,
    	x,
    	y,
    	Config.FREE_WIDTH,
    	Config.FREE_HEIGHT,
    	content
    );
}

function deleteAddressLiana(editor, graph, edge, commandList) {
    var tail = graph.getTail(edge);
    var below = graph.getEdge(tail.down);
    pushDeleteEdge(
    	commandList,
    	edge.id
    );
    deleteLiana(
    	editor,
    	graph,
    	below,
    	commandList
    );
    pushDeleteNode(
    	commandList,
    	tail.id
    );
    var pgraph = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    );
    return commandList;
}

function deleteArrow(graph, node, plan) {
    plan.edges[node.up] = true;
    plan.nodes[node.id] = true;
    var upRightId = graph.getNodeUp(node);
    var upRight = graph.getNode(upRightId);
    plan.edges[upRight.left] = true;
    plan.nodes[upRight.id] = true;
    var leftId = graph.getNodeLeft(upRight);
    var left = graph.getNode(leftId);
    if (leftId in plan.nodes) {
        
    } else {
        pokeVer(graph, left, plan);
    }
}

function deleteBranch(editor, id) {
    addTrace(
    	"delete branch",
    	[id]
    );
    var graph = editor.storage.graph;
    var bgraph = findBranchGraph(graph, id);
    var commandList = [];
    var nodes = bgraph.nodes;
    var edges = bgraph.edges;
    var right, leftBottom, rightBottom
    var above = graph.getNode(bgraph.top);
    var left = graph.getNodeLeftEx(above);
    var bottom = graph.getNode(bgraph.bottom);
    if (bgraph.isLastUp) {
        right = null
        rightBottom = null
    } else {
        edges[above.right] = true
        right = graph.getNodeRightEx(above)
        if (bgraph.isLast) {
            rightBottom = null
        } else {
            rightBottom = goDownToEnd(graph, right.id)
            edges[rightBottom.left] = true
        }
    }
    edges[above.left] = true
    if (bgraph.exit) {
        leftBottom = null
    } else {
        leftBottom = graph.getNodeLeftEx(bottom)
        edges[bottom.left] = true
    }
    pushDeleteSubgraph(
    	commandList,
    	nodes,
    	edges
    );
    if (right) {
        connectHor(
        	editor,
        	commandList,
        	left.id, right.id,
        	null, null
        );
        if (rightBottom) {
            connectHor(
            	editor,
            	commandList,
            	leftBottom.id, rightBottom.id,
            	"sil_floor", null
            );
        }
    }
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function deleteComplex(editor, id) {
    addTrace(
    	"complex delete",
    	[id]
    );
    var graph = editor.storage.graph;
    var commandList = [];
    var plan = makeDeletionPlan(
    	editor,
    	id
    );
    var pgraph = createPhysicalGraph(
    	graph,
    	editor.render
    );
    var graph2 = pgraph.graph;
    var _ind5901 = 0;
    var _col5901 = plan.edges;
    var _keys5901 = Object.keys(_col5901); 
    var _len5901 = _keys5901.length;
    while (true) {
        if (_ind5901 < _len5901) {
            
        } else {
            break;
        }
        var edgeId = _keys5901[_ind5901]; var edge = _col5901[edgeId];
        pushDeleteEdge(commandList, edgeId);
        _ind5901++;
    }
    var _ind5904 = 0;
    var _col5904 = plan.nodes;
    var _keys5904 = Object.keys(_col5904); 
    var _len5904 = _keys5904.length;
    while (true) {
        if (_ind5904 < _len5904) {
            
        } else {
            break;
        }
        var nodeId = _keys5904[_ind5904]; var node = _col5904[nodeId];
        pushDeleteNodeEx(graph, commandList, nodeId);
        _ind5904++;
    }
    var newEdgeIds = []
    var _ind5891 = 0;
    var _col5891 = plan.newEdges;
    var _keys5891 = Object.keys(_col5891); 
    var _len5891 = _keys5891.length;
    while (true) {
        if (_ind5891 < _len5891) {
            
        } else {
            break;
        }
        var oldId = _keys5891[_ind5891]; var newEdge = _col5891[oldId];
        if ((newEdge.up in plan.nodes) || (newEdge.down in plan.nodes)) {
            
        } else {
            var edgeId = generateId(editor.storage);
            newEdgeIds.push(edgeId)
            if (newEdge.dir === "up") {
                var downNode = graph.getNode(newEdge.down);
                var downEdge = graph.getEdge(downNode.up);
                pushInsertVertical(
                	commandList,
                	edgeId,
                	newEdge.up,
                	newEdge.down,
                	downEdge.role
                );
            } else {
                var leftNode = graph.getNode(newEdge.up);
                var edge = graph.getEdge(leftNode.right);
                pushInsertHorizontal(
                	commandList,
                	edgeId,
                	newEdge.up,
                	newEdge.down,
                	edge.role
                );
            }
        }
        _ind5891++;
    }
    var singleEdgeId = null
    if (newEdgeIds.length == 1) {
        singleEdgeId = newEdgeIds[0]
    }
    runAndCollapse(
    	editor,
    	commandList,
    	singleEdgeId
    )
}

function deleteDuration(editor, id) {
    addTrace(
    	"delete duration",
    	[id]
    );
    var graph = editor.storage.graph;
    var node = graph.getNode(id);
    var commandList = [];
    pushDeleteEdge(commandList, node.right);
    pushDeleteNode(commandList, id);
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function deleteFreeItems(editor, frees) {
    addTrace(
    	"delete free items",
    	frees
    );
    var free = editor.storage.free
    var frees = Utils.listToSet(frees)
    var notDeleted = function(id) {
    	return !(id in frees)
    }
    var makeElement = function(id) {
    	return { id: id, next: "" }
    }
    var remaining = free.list
    	.filter(notDeleted)
    	.map(makeElement)
    setNextPointers(remaining)
    var commandList = []
    var _ind17057 = 0;
    var _col17057 = frees;
    var _keys17057 = Object.keys(_col17057); 
    var _len17057 = _keys17057.length;
    while (true) {
        if (_ind17057 < _len17057) {
            
        } else {
            break;
        }
        var id = _keys17057[_ind17057]; var _ = _col17057[id];
        var deleteCommand = new Command(
        	"delete",
        	"free",
        	id,
        	null
        )
        commandList.push(deleteCommand)
        _ind17057++;
    }
    var _ind17062 = 0;
    var _col17062 = remaining;
    var _len17062 = _col17062.length;
    while (true) {
        if (_ind17062 < _len17062) {
            
        } else {
            break;
        }
        var node = _col17062[_ind17062];
        var old = free.get(node.id)
        if (old.next == node.next) {
            
        } else {
            pushUpdate(
            	commandList,
            	"free",
            	node.id,
            	{ next: node.next }
            )
        }
        _ind17062++;
    }
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function deleteItem(editor, id) {
    var _sw55540000_ = 0;
    var graph = editor.storage.graph;
    if (id) {
        var item = graph.getItem(id);
        if (canDeleteItem(editor, item)) {
            if (item.role === "params") {
                deleteParams(editor, id);
            } else {
                _sw55540000_ = item.type;
                if (_sw55540000_ === "duration") {
                    deleteDuration(editor, id);
                } else {
                    if (((((_sw55540000_ === "question") || (_sw55540000_ === "select")) || (_sw55540000_ === "loopbegin")) || (_sw55540000_ === "loopend")) || (_sw55540000_ === "case")) {
                        deleteComplex(editor, id);
                    } else {
                        if (_sw55540000_ === "branch") {
                            deleteBranch(editor, id);
                        } else {
                            deleteSimpleItem(editor, id);
                        }
                    }
                }
            }
        }
    }
}

function deleteJunctionBetween(editor, graph, center, commandList) {
    if ((center.up) && (center.down)) {
        var up = graph.getEdge(center.up);
        var down = graph.getEdge(center.down);
        pushDeleteEdge(
        	commandList,
        	center.up
        );
        pushDeleteEdge(
        	commandList,
        	center.down
        );
        pushDeleteNode(
        	commandList,
        	center.id
        );
        var newLeft = generateId(editor.storage);
        pushInsertVertical(
        	commandList,
        	newLeft,
        	up.head,
        	down.tail,
        	down.role
        );
    }
}

function deleteLastPath(editor, edge, left, right) {
    addTrace(
    	"delete last path",
    	[edge.id]
    );
    var graph = editor.storage.graph;
    var rightDown = goDownToEnd(graph, right.id);
    var leftDown = graph.getNodeLeftEx(rightDown);
    var uuId = graph.getNodeUp(left);
    var udId = graph.getNodeDown(left);
    var duId = graph.getNodeUp(leftDown);
    var ddId = graph.getNodeDown(leftDown);
    var nodes = {};
    var edges = {};
    nodes[left.id] = true;
    nodes[leftDown.id] = true;
    graph.enumerateManhattan(
    	right.id,
    	nodes,
    	edges
    );
    edges[left.up] = true;
    edges[left.down] = true;
    edges[leftDown.up] = true;
    edges[leftDown.down] = true;
    var commandList = [];
    pushDeleteSubgraph(
    	commandList,
    	nodes,
    	edges
    );
    var lowEdge = graph.getEdge(leftDown.down);
    if (udId == leftDown.id) {
        connectVer(
        	editor,
        	commandList,
        	uuId,
        	ddId,
        	lowEdge.role,
        	null
        );
    } else {
        connectVer(
        	editor,
        	commandList,
        	uuId,
        	udId,
        	"down",
        	null
        );
        connectVer(
        	editor,
        	commandList,
        	duId,
        	ddId,
        	lowEdge.role,
        	null
        );
    }
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function deleteLiana(editor, graph, edge, commandList) {
    var newHor = null
    var sGraph = editor.storage.graph;
    var tail = graph.getTail(edge);
    pushDeleteEdge(
    	commandList,
    	edge.id
    );
    if (tail.left) {
        var leftEdge = graph.getEdge(tail.left);
        var leftNode = graph.getNode(leftEdge.head);
        if (tail.right) {
            pushDeleteEdge(
            	commandList,
            	tail.left
            );
            var rightEdge = sGraph.getEdge(tail.right);
            pushDeleteEdge(
            	commandList,
            	tail.right
            );
            newHor = generateId(editor.storage);
            pushInsertHorizontal(
            	commandList,
            	newHor,
            	leftEdge.head,
            	rightEdge.tail,
            	rightEdge.role
            );
            pushDeleteNode(
            	commandList,
            	tail.id
            );
        } else {
            if (tail.down) {
                
            } else {
                pushDeleteEdge(
                	commandList,
                	tail.left
                );
                deleteJunctionBetween(
                	editor,
                	graph,
                	leftNode,
                	commandList
                );
                pushDeleteNode(
                	commandList,
                	tail.id
                );
            }
        }
    } else {
        if (tail.right) {
            var rightEdge = graph.getEdge(tail.right);
            var rightNode = graph.getNode(rightEdge.tail);
            var rightType = describeJunction(rightNode);
            pushDeleteEdge(
            	commandList,
            	tail.right
            );
            if (rightType === "left-up") {
                pushDeleteArrow(
                	editor,
                	graph,
                	rightNode,
                	commandList
                );
            } else {
                deleteJunctionBetween(
                	editor,
                	graph,
                	rightNode,
                	commandList
                );
            }
            pushDeleteNode(
            	commandList,
            	tail.id
            );
        } else {
            Utils.throwError("Bad liana");
        }
    }
    return newHor
}

function deleteMiddlePath(editor, edge, left, right) {
    addTrace(
    	"delete middle path",
    	[edge.id]
    );
    var graph = editor.storage.graph;
    var rightDown = goDownToEnd(graph, right.id);
    var leftDown = graph.getNodeLeftEx(rightDown);
    var right2 = graph.getNodeRightEx(right);
    var right2Down = goDownToEnd(graph, right2.id);
    var nodes = {};
    var edges = {};
    nodes[left.id] = true;
    nodes[leftDown.id] = true;
    nodes[right2.id] = true;
    nodes[right2Down.id] = true;
    graph.enumerateManhattan(
    	right.id,
    	nodes,
    	edges
    );
    delete nodes[left.id];
    delete nodes[leftDown.id];
    delete nodes[right2.id];
    delete nodes[right2Down.id];
    var commandList = [];
    pushDeleteSubgraph(
    	commandList,
    	nodes,
    	edges
    );
    connectHor(
    	editor,
    	commandList,
    	left.id,
    	right2.id,
    	"parallel",
    	null
    );
    connectHor(
    	editor,
    	commandList,
    	leftDown.id,
    	right2Down.id,
    	null,
    	null
    );
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function deleteMind(itemId) {
    var graph = self.storage.graph
    var item = graph.getItem(itemId)
    var action = findMindDelete(item)
    if (action) {
        mindAction(action, itemId, null)
    }
}

function deleteNodeAndUp(pgraph, id, newHor) {
    var graph = pgraph.graph
    var node = graph.getNode(id);
    var leftId = null
    var rightId = null
    if (node.left) {
        leftId = graph.getNodeLeft(node)
        pgraph.deletePhysicalItem(node.left);
    }
    if (node.up) {
        pgraph.deletePhysicalItem(node.up);
    }
    if (node.right) {
        rightId = graph.getNodeRight(node)
        pgraph.deletePhysicalItem(node.right)
    }
    if (node.down) {
        pgraph.deletePhysicalItem(node.down);
    }
    pgraph.deletePhysicalItem(id);
    if (newHor) {
        var line = makeDummyLine(
        	newHor,
        	false,
        	leftId,
        	rightId,
        	null
        )
        pgraph.insertPhysicalItem(line)
    }
    rebuildPhysicsCache(pgraph);
}

function deleteParams(editor, id) {
    addTrace(
    	"delete parameters",
    	[id]
    );
    var graph = editor.storage.graph;
    var node = graph.getNode(id);
    var commandList = [];
    pushDeleteEdge(commandList, node.left);
    pushDeleteNode(commandList, id);
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function deletePath(editor, edgeId) {
    var graph = editor.storage.graph;
    var edge = graph.getEdge(edgeId);
    var left = graph.getHead(edge);
    var right = graph.getTail(edge);
    if (right.right) {
        deleteMiddlePath(editor, edge, left, right);
    } else {
        if (left.left) {
            deleteRightPath(editor, edge, left, right);
        } else {
            deleteLastPath(editor, edge, left, right);
        }
    }
}

function deleteRight(graph, node, plan) {
    if (isArrowStart(graph, node)) {
        deleteArrow(
        	graph,
        	node,
        	plan
        );
    } else {
        if (node.id in plan.nodes) {
            plan.edges[node.right] = true;
            var rightId =graph.getNodeRight(node);
            var right = graph.getNode(rightId);
            deleteRight(graph, right, plan);
        }
    }
}

function deleteRightPath(editor, edge, left, right) {
    addTrace(
    	"delete right path",
    	[edge.id]
    );
    var graph = editor.storage.graph;
    var rightDown = goDownToEnd(graph, right.id);
    var leftDown = graph.getNodeLeftEx(rightDown);
    var nodes = {};
    var edges = {};
    nodes[left.id] = true;
    nodes[leftDown.id] = true;
    graph.enumerateManhattan(
    	right.id,
    	nodes,
    	edges
    );
    delete nodes[left.id];
    delete nodes[leftDown.id];
    var commandList = [];
    pushDeleteSubgraph(
    	commandList,
    	nodes,
    	edges
    );
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function deleteSelection() {
    if (ignoreCommand()) {
        
    } else {
        addTrace(
        	"delete selection",
        	[]
        );
        if (isMind()) {
            editAction(
            	function(editor, itemId) {deleteMind(itemId)},
            	function() {  },
            	deleteFreeItems
            )
        } else {
            editAction(
            	deleteItem,
            	function() { copyBlock(false, true) },
            	deleteFreeItems
            )
        }
    }
}

function deleteSimpleItem(editor, id) {
    addTrace(
    	"delete one item",
    	[id]
    );
    var graph = editor.storage.graph;
    var render = editor.render;
    var item = graph.getItem(id);
    var commandList = [];
    var up = graph.getNeighbourUp(id);
    var down = graph.getNeighbourDown(id);
    var downEdge = graph.getEdge(item.down);
    pushDeleteEdge(commandList, item.up);
    pushDeleteEdge(commandList, item.down);
    pushDeleteNodeEx(graph, commandList, id);
    var edgeId = generateId(editor.storage);
    pushInsertVertical(
    	commandList,
    	edgeId,
    	up,
    	down,
    	downEdge.role
    );
    runAndCollapse(
    	editor,
    	commandList,
    	edgeId
    )
}

function describeJunction(node) {
    if (node.up) {
        if (node.left) {
            if (node.right) {
                if (node.down) {
                    return "cross"
                } else {
                    return "up-t"
                }
            } else {
                if (node.down) {
                    return "left-t"
                } else {
                    return "left-up"
                }
            }
        } else {
            if (node.right) {
                if (node.down) {
                    return "right-t"
                } else {
                    return "right-up"
                }
            } else {
                if (node.down) {
                    Utils.throwError("vertical")
                } else {
                    return "lowest"
                }
            }
        }
    } else {
        if (node.left) {
            if (node.right) {
                if (node.down) {
                    return "t"
                } else {
                    Utils.throwError("horizontal")
                }
            } else {
                if (node.down) {
                    return "left-down"
                } else {
                    return "rightmost"
                }
            }
        } else {
            if (node.right) {
                if (node.down) {
                    return "right-down"
                } else {
                    return "leftmost"
                }
            } else {
                if (node.down) {
                    return "highest"
                } else {
                    Utils.throwError("empty")
                }
            }
        }
    }
}

function deselect() {
    deselectAll(self);
    redrawCanvas(self);
}

function deselectAll(editor) {
    editor.storage.selection = createSelection();
}

function detectCycle(graph, origin, targetId) {
    var _sw93010000_ = 0;
    var _sw93220000_ = 0;
    var node, id;
    var counter = 0;
    var verList = graph.getVertical(origin.id)
    var vertical = Utils.listToSet(verList)
    node = graph.getNode(targetId);
    while (true) {
        if (node.id in vertical) {
            counter = 0;
            while (true) {
                id = graph.getNodeUp(node);
                node = graph.getNode(id);
                if (node.id == origin.id) {
                    return false;
                }
                _sw93220000_ = node.type;
                if (_sw93220000_ === "loopbegin") {
                    if (counter === 0) {
                        return true;
                    }
                    counter--;
                } else {
                    if (_sw93220000_ === "loopend") {
                        counter++;
                    }
                }
            }
            break;
        }
        _sw93010000_ = node.type;
        if (_sw93010000_ === "loopend") {
            if (counter === 0) {
                return true;
            }
            counter--;
        } else {
            if (_sw93010000_ === "loopbegin") {
                counter++;
            }
        }
        if (node.down) {
            id = graph.getNodeDown(node);
        } else {
            if (node.left) {
                
            } else {
                return false;
            }
            var leftEdge = graph.getEdge(node.left);
            if (leftEdge.role === "left") {
                
            } else {
                return false;
            }
            id = graph.getNodeLeft(node);
        }
        node = graph.getNode(id);
    }
}

function detectInternalCycle(graph, sourceId, targetId) {
    var origin = findPathOrigin(graph, sourceId);
    var start = findLeftMostOnSurface(
    	graph,
    	origin,
    	targetId
    );
    return detectCycle(
    	graph,
    	start,
    	targetId
    );
}

function detectOuterCycle(graph, sourceId, targetId) {
    var origin = graph.getNode(sourceId);
    var start = findLeftMostOnSurface(
    	graph,
    	origin,
    	targetId
    );
    return detectCycle(
    	graph,
    	start,
    	targetId
    );
}

function diagramToJson() {
    var sane = getDiagramCopy(self)
    return JSON.stringify(sane)
}

function downRole(item) {
    if ((item.role == "down") || (item.role == "par-down")) {
        return true;
    } else {
        return false;
    }
}

function drawBasicItems(storage, canvas) {
    var graph = storage.graph
    var free = storage.free
    var skewers = {}
    if (isDrakon()) {
        var _ind22967 = 0;
        var _col22967 = graph.nodes;
        var _keys22967 = Object.keys(_col22967); 
        var _len22967 = _keys22967.length;
        while (true) {
            if (_ind22967 < _len22967) {
                
            } else {
                break;
            }
            var id = _keys22967[_ind22967]; var item = _col22967[id];
            if ((item.type == "branch") || (item.type == "beginend")) {
                markVerticals(graph, item, skewers)
            }
            _ind22967++;
        }
    }
    var _ind10829 = 0;
    var _col10829 = graph.nodes;
    var _keys10829 = Object.keys(_col10829); 
    var _len10829 = _keys10829.length;
    while (true) {
        if (_ind10829 < _len10829) {
            
        } else {
            break;
        }
        var id = _keys10829[_ind10829]; var item = _col10829[id];
        insertCanvasItem(canvas, item, skewers)
        _ind10829++;
    }
    var _ind10831 = 0;
    var _col10831 = graph.edges;
    var _keys10831 = Object.keys(_col10831); 
    var _len10831 = _keys10831.length;
    while (true) {
        if (_ind10831 < _len10831) {
            
        } else {
            break;
        }
        var id = _keys10831[_ind10831]; var item = _col10831[id];
        insertCanvasItem(canvas, item, skewers)
        _ind10831++;
    }
    var _ind16669 = 0;
    var _col16669 = free.list;
    var _len16669 = _col16669.length;
    while (true) {
        if (_ind16669 < _len16669) {
            
        } else {
            break;
        }
        var id = _col16669[_ind16669];
        var item = free.set[id]
        insertCanvasItem(canvas, item, skewers)
        _ind16669++;
    }
}

function drawDrakonGuides(render, graph, movedId, visibleBox) {
    var item = graph.getItem(movedId)
    if (canGuideDrakon(item)) {
        var topEdge = getTop(item)
        var bottomEdge = getBottom(item)
        var min = getLeft(item)
        var max = getRight(item)
        var g1 = new Guide(topEdge, min, max)
        var g2 = new Guide(bottomEdge, min, max)
        var _ind19378 = 0;
        var _col19378 = graph.nodes;
        var _keys19378 = Object.keys(_col19378); 
        var _len19378 = _keys19378.length;
        while (true) {
            if (_ind19378 < _len19378) {
                
            } else {
                break;
            }
            var id = _keys19378[_ind19378]; var node = _col19378[id];
            if (((id == movedId) || (!(canGuideDrakon(node)))) || (!(Utils.boxesIntersect(visibleBox, node.box)))) {
                
            } else {
                var top = getTop(node)
                var bottom = getBottom(node)
                var left = getLeft(node)
                var right = getRight(node)
                checkGuide(g1, top, left, right)
                checkGuide(g2, bottom, left, right)
            }
            _ind19378++;
        }
        drawHorizontalGuide(render, g1)
        drawHorizontalGuide(render, g2)
    }
}

function drawEdgeMark(canvas, edge, upper) {
    var render = canvas.render;
    var graph = canvas.graph;
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    var x, y, w, h, length;
    var color;
    var shift;
    var zone;
    if (upper) {
        zone = edge.upperMark;
        shift = 3;
    } else {
        zone = edge.lowerMark;
        shift = -3;
    }
    if (zone) {
        color = getZoneColor(canvas, zone);
        if (edge.isVertical) {
            length = (tail.y - head.y) / 2;
            x = head.x + shift;
            y = head.y + length;
            w = 2;
            h = length - 5;
        } else {
            length = (tail.x - head.x) / 2;
            shift = -shift;
            x = head.x + length;
            y = head.y + shift;
            w = length - 5;
            h = 2;
        }
        render.createAction(
        	x, y, w, h,
        	color,
        	null,
        	"line_candies"
        );
    }
}

function drawFreeGuides(editor, visibleBox) {
    if (gDragItems.length == 1) {
        var free = editor.canvas.free
        var movedId = gDragItems[0]
        var movedItem = free.get(movedId)
        if (canGuide(movedItem)) {
            var topE = getTop(movedItem)
            var bottomE = getBottom(movedItem)
            var hcE = movedItem.y
            var leftE = getLeft(movedItem)
            var rightE = getRight(movedItem)
            var vcE = movedItem.x
            var gh0 = new Guide(topE, leftE, rightE)
            var gh1 = new Guide(hcE, leftE, rightE)
            var gh2 = new Guide(bottomE, leftE, rightE)
            var gv0 = new Guide(leftE, topE, bottomE)
            var gv1 = new Guide(vcE, topE, bottomE)
            var gv2 = new Guide(rightE, topE, bottomE)
            var _ind19492 = 0;
            var _col19492 = free.list;
            var _len19492 = _col19492.length;
            while (true) {
                if (_ind19492 < _len19492) {
                    
                } else {
                    break;
                }
                var id = _col19492[_ind19492];
                if (id == movedId) {
                    
                } else {
                    var item = free.set[id]
                    if (canGuide(item)) {
                        var top = getTop(item)
                        var bottom = getBottom(item)
                        var left = getLeft(item)
                        var right = getRight(item)
                        var box = new Utils.Box(left, top, right, bottom)
                        if (Utils.boxesIntersect(visibleBox, box)) {
                            checkGuide(gh0, top, left, right)
                            checkGuide(gh1, item.y, left, right)
                            checkGuide(gh2, bottom, left, right)
                            
                            checkGuide(gv0, left, top, bottom)
                            checkGuide(gv1, item.x, top, bottom)
                            checkGuide(gv2, right, top, bottom)
                        }
                    }
                }
                _ind19492++;
            }
            var render = editor.render
            drawVerticalGuide(render, gv0)
            drawVerticalGuide(render, gv1)
            drawVerticalGuide(render, gv2)
            drawHorizontalGuide(render, gh0)
            drawHorizontalGuide(render, gh1)
            drawHorizontalGuide(render, gh2)
        }
    }
}

function drawHorizontalGuide(render, guide) {
    if (guide.found) {
        var format = getGuideFormat()
        var w = guide.max - guide.min
        render.createLine(
        	guide.min,
        	guide.edge,
        	w,
        	0,
        	format,
        	"guides"
        )
    }
}

function drawMarks(canvas) {
    canvas.zoneColors = {};
    var graph = canvas.graph;
    var _ind3612 = 0;
    var _col3612 = graph.edges;
    var _keys3612 = Object.keys(_col3612); 
    var _len3612 = _keys3612.length;
    while (true) {
        if (_ind3612 < _len3612) {
            
        } else {
            break;
        }
        var id = _keys3612[_ind3612]; var edge = _col3612[id];
        drawEdgeMark(canvas, edge, true);
        drawEdgeMark(canvas, edge, false);
        _ind3612++;
    }
    var _ind3619 = 0;
    var _col3619 = graph.nodes;
    var _keys3619 = Object.keys(_col3619); 
    var _len3619 = _keys3619.length;
    while (true) {
        if (_ind3619 < _len3619) {
            
        } else {
            break;
        }
        var id = _keys3619[_ind3619]; var node = _col3619[id];
        drawNodeMark(canvas, node);
        _ind3619++;
    }
}

function drawMoveAll(render) {
    if (gMoveAllPos) {
        gMoveAllPrim = render.createMoveAll(
        	gMoveAllPos.x,
        	gMoveAllPos.y,
        	"free_candies"
        );
    } else {
        gMoveAllPrim = null
    }
}

function drawNodeMark(canvas, node) {
    if (node.mark) {
        var color = getZoneColor(canvas, node.mark);
        var x = node.x;
        var y = node.y;
        var w = 10;
        var h = 10;
        canvas.render.createAction(
        	x, y, w, h,
        	color,
        	"black",
        	"line_candies"
        );
    }
}

function drawToOtherRender(render) {
    var canvas = new CanvasCache(render);
    drawBasicItems(self.storage, canvas);
}

function drawVerticalGuide(render, guide) {
    if (guide.found) {
        var format = getGuideFormat()
        var h = guide.max - guide.min
        render.createLine(
        	guide.edge,
        	guide.min,
        	0,
        	h,
        	format,
        	"guides"
        )
    }
}

function drill(pgraph, x, top, bottom, movedNodes) {
    var graph = pgraph.graph;
    var box = new Utils.Box(
    	x - Config.METRE,
    	top + Config.METRE / 2,
    	x + Config.METRE,
    	bottom
    );
    while (true) {
        var hit = hitsAnyone(graph, box);
        if (hit) {
            
        } else {
            break;
        }
        var hitItem = graph.getItem(hit);
        if (hitItem.isLine) {
            if ((hitItem.isVertical) || (hitItem.role == "lstick")) {
                
            } else {
                moveHorLineAway(
                	pgraph,
                	hitItem,
                	box,
                	movedNodes
                );
            }
        } else {
            var delta = getIntersectionDelta(
            	box,
            	hitItem
            );
            pgraph.moveRight(
            	hit,
            	delta,
            	movedNodes
            );
        }
    }
}

function dropDown(pgraph, node, bottom, movedNodes) {
    dropDownCore(
    	pgraph,
    	node,
    	bottom,
    	-10000000,
    	movedNodes
    );
}

function dropDownCore(pgraph, node, bottom, minRight, movedNodes) {
    var graph = pgraph.graph;
    var rightEdge;
    var below = findNodesBelowEx(graph, node, bottom);
    var lowest = below[below.length - 1];
    var dims = findLedgeDimensions(
    	graph,
    	node.id,
    	lowest.id
    );
    var nodeRight = node.box.right + Config.METRE;
    rightEdge = Math.max(dims.x, nodeRight);
    rightEdge = Math.max(rightEdge, minRight);
    var scan = new Utils.Box(
    	rightEdge - Config.METRE + 1,
    	node.y,
    	rightEdge,
    	bottom
    );
    var _ind10211 = 0;
    var _col10211 = graph.nodes;
    var _keys10211 = Object.keys(_col10211); 
    var _len10211 = _keys10211.length;
    while (true) {
        if (_ind10211 < _len10211) {
            
        } else {
            break;
        }
        var nid = _keys10211[_ind10211]; var n = _col10211[nid];
        if (Utils.boxesIntersect(scan, n.box)) {
            var delta = scan.right - n.box.left;
            pgraph.moveRight(
            	n.id,
            	delta,
            	movedNodes
            );
        }
        _ind10211++;
    }
    var vDelta = bottom - node.y;
    pgraph.moveDown(
    	node.id,
    	vDelta,
    	movedNodes
    );
}

function editAction(simpleItemAction, blockAction, freeItemAction) {
    var free = self.storage.free
    var selection = analyzeSelection(self)
    if (selection.greens.length == 1) {
        var itemId = selection.greens[0]
        if (free.get(itemId)) {
            freeItemAction(
            	self,
            	[itemId]
            )
        } else {
            simpleItemAction(self, itemId)
        }
        commandDone();
    } else {
        if (selection.greens.length > 1) {
            blockAction(self)
            commandDone();
        } else {
            if (selection.frees.length == 0) {
                
            } else {
                freeItemAction(
                	self,
                	selection.frees
                )
                commandDone();
            }
        }
    }
}

function editLink(editor, item, x, y) {
    var fun = Callbacks.editLink
    if (fun) {
        var content = Utils.copyObject(getContent(item))
        fun(item.id, content, x, y)
    }
}

function endVisualDrag() {
    if ((self.readonly) || (!(self.dragOn))) {
        
    } else {
        self.dragOn = false
        self.render.clearGuides()
        var updates = []
        if (gDragStartItem) {
            addTrace(
            	"move items",
            	[gDragStartItem]
            );
            var cgraph = self.canvas.graph
            var _ind12170 = 0;
            var _col12170 = self.changedNodes;
            var _keys12170 = Object.keys(_col12170); 
            var _len12170 = _keys12170.length;
            while (true) {
                if (_ind12170 < _len12170) {
                    
                } else {
                    break;
                }
                var nodeId = _keys12170[_ind12170]; var _ = _col12170[nodeId];
                if (nodeId in cgraph.nodes) {
                    
                } else {
                    updates = []
                    break;
                }
                var node = cgraph.getNode(
                	nodeId
                );
                var change = new Command(
                	"update",
                	"nodes",
                	node.id,
                	{
                		x: node.x,
                		y: node.y
                	}
                );
                updates.push(change);
                _ind12170++;
            }
        } else {
            addTrace(
            	"move free items",
            	gDragItems
            );
            var free = self.canvas.free
            var ofree = self.storage.free
            var _ind16849 = 0;
            var _col16849 = gDragItems;
            var _len16849 = _col16849.length;
            while (true) {
                if (_ind16849 < _len16849) {
                    
                } else {
                    break;
                }
                var id = _col16849[_ind16849];
                var item = free.get(id)
                var oitem = ofree.get(id)
                if ((item.x == oitem.x) && (item.y == oitem.y)) {
                    
                } else {
                    var change = new Command(
                    	"update",
                    	"free",
                    	id,
                    	{
                    		x: item.x,
                    		y: item.y
                    	}
                    );
                    updates.push(change);
                }
                _ind16849++;
            }
            gDragItems = []
        }
        submitCommands(self, updates, false)
        var ids = getSelectedIds(self);
        rebuildGrips(self, ids);
    }
}

function endsWithRightTurn(graph, nodeId) {
    var node = graph.getNode(nodeId);
    if (node.down) {
        var downEdge = graph.getEdge(
        	node.down
        );
        return endsWithRightTurn(
        	graph,
        	downEdge.tail
        );
    } else {
        if (node.left) {
            return false;
        } else {
            if (node.right) {
                var edge = graph.getEdge(node.right);
                if (edge.role === "right") {
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        }
    }
}

function executeCommands(editor, commands, state, isUndo, redraw) {
    self.dragOn = false
    performLocalChange(
    	editor,
    	commands,
    	isUndo
    )
    persistAndRedraw(
    	editor,
    	state,
    	redraw
    )
}

function expandBolt(editor, edgeId) {
    addTrace(
    	"add line",
    	[edgeId]
    );
    var pgraph = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    );
    var commandList = expandBoltCore(editor, pgraph, edgeId);
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function expandBoltCore(editor, pgraph, edgeId) {
    var movedNodes = {};
    var commands = {};
    var graph = pgraph.graph;
    var edge = graph.getEdge(edgeId);
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    var width = tail.x - head.box.right;
    var minWidth = Config.METRE * 4;
    var actWidth;
    if (width < minWidth) {
        var delta = minWidth - width;
        pgraph.moveRight(
        	tail.id,
        	delta,
        	movedNodes
        );
        actWidth = minWidth;
    } else {
        actWidth = width;
    }
    var half = Math.floor(actWidth / Config.METRE / 2)
    	* Config.METRE;
    var x = head.box.right + half;
    pgraph.deletePhysicalItem(
    	edgeId
    );
    var fakeNode = generateId(editor.storage);
    var fakeEdge = generateId(editor.storage);
    pgraph.insertPhysicalItem({
    	id: fakeNode,
    	x: x,
    	y: head.y,
    	type: "junction",
    	isLine: false
    });
    pgraph.insertPhysicalEdge(
    	fakeEdge,
    	fakeNode,
    	tail.id,
    	false,
    	null
    );
    rebuildPhysicsCache(pgraph);
    pgraph.moveDown(
    	tail.id,
    	minWidth,
    	movedNodes
    );
    delete movedNodes[fakeNode];
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	edgeId
    );
    var leftEdge = generateId(editor.storage);
    var rightEdge = generateId(editor.storage);
    var boltEdge = generateId(editor.storage);
    var newTop = generateId(editor.storage);
    var newBottom = generateId(editor.storage);
    var bottom = head.y + minWidth;
    pushInsertJunction(
    	commandList,
    	newTop,
    	x,
    	head.y
    );
    pushInsertJunction(
    	commandList,
    	newBottom,
    	x,
    	bottom
    );
    pushInsertDown(
    	commandList,
    	boltEdge,
    	newTop,
    	newBottom
    );
    pushInsertHorizontal(
    	commandList,
    	leftEdge,
    	head.id,
    	newTop,
    	null
    );
    pushInsertHorizontal(
    	commandList,
    	rightEdge,
    	newBottom,
    	tail.id,
    	null
    );
    return commandList;
}

function expandBranchAddress(pgraph, id, maxH, commands) {
    var node = pgraph.graph.getNode(id)
    var deltaH = maxH - node.h
    var newY = node.y - deltaH
    if (deltaH >= 0) {
        var upDownBox = new Utils.Box(
        	node.x - node.w,
        	node.y,
        	node.x + node.w,
        	node.y
        )
        var movedNodes = {}
        pgraph.pushObjects(
            upDownBox,
            {},
            -(deltaH * 2 + node.h),
            "vertical",
            movedNodes
        );
        buildMoveCommands(
        	pgraph,
        	movedNodes,
        	commands
        );
    }
    var ownCommand = getOrCreateUpdate(
    	commands,
    	id
    )
    ownCommand.fields.h = maxH
    ownCommand.fields.y = newY
}

function expandBranchHeader(pgraph, id, maxH, commands) {
    var node = pgraph.graph.getNode(id)
    var deltaH = maxH - node.h
    var newY = node.y + deltaH
    if (deltaH > 0) {
        var upDownBox = new Utils.Box(
        	node.x - node.w,
        	node.y + node.h,
        	node.x + node.w,
        	node.y + node.h
        )
        var movedNodes = {}
        pgraph.pushObjects(
            upDownBox,
            {},
            deltaH * 2,
            "vertical",
            movedNodes
        );
        buildMoveCommands(
        	pgraph,
        	movedNodes,
        	commands
        );
    }
    var ownCommand = getOrCreateUpdate(
    	commands,
    	id
    )
    ownCommand.fields.h = maxH
    ownCommand.fields.y = newY
}

function extendEdge(pgraph, edgeId, h, movedNodes) {
    var graph = pgraph.graph;
    var edge = graph.getEdge(edgeId);
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    var height = getEdgeHeight(head, tail);
    var minHeight = (Config.METRE + h) * 2;
    if (height < minHeight) {
        var delta = minHeight - height;
        pgraph.moveDown(
        	tail.id,
        	delta,
        	movedNodes
        );
    }
}

function findAbove(graph, item) {
    if (item.up) {
        return graph.getNodeUp(item)
    } else {
        return null
    }
}

function findAddressSockets(graph, id) {
    var sockets = [];
    var edge = graph.getEdge(id);
    var _ind10491 = 0;
    var _col10491 = graph.edges;
    var _keys10491 = Object.keys(_col10491); 
    var _len10491 = _keys10491.length;
    while (true) {
        if (_ind10491 < _len10491) {
            
        } else {
            break;
        }
        var tid = _keys10491[_ind10491]; var target = _col10491[tid];
        if (((downRole(target)) && (target.upperMark === edge.lowerMark)) && (!(detectInternalCycle(graph, 
edge.tail, target.tail)))) {
            appendSocket(
            	sockets,
            	target.id,
            	"leftInnerLine"
            );
        }
        _ind10491++;
    }
    return sockets;
}

function findArrowStart(graph, rightUpId) {
    var rightUp = graph.getNode(rightUpId);
    var rightDown = graph.getNodeDownEx(rightUp);
    var leftDown = graph.getNodeLeftEx(rightDown);
    if (leftDown.type == "question") {
        return rightDown.id;
    } else {
        if (leftDown.left) {
            return null;
        } else {
            return leftDown.id;
        }
    }
}

function findBelow(graph, item) {
    if (item.down) {
        return graph.getNodeDown(item)
    } else {
        return null
    }
}

function findBottomNodes(graph, nodes, node) {
    var result = [];
    while (true) {
        result.push(node.id);
        if (node.right) {
            
        } else {
            break;
        }
        var nextId = graph.getNodeRight(node);
        if (nextId in nodes) {
            
        } else {
            break;
        }
        node = graph.getNode(nextId);
    }
    return result;
}

function findBranchGraph(graph, id) {
    var nodes = {};
    var edges = {};
    var branch = graph.getNode(id);
    var above = graph.getNodeUpEx(branch);
    var left = graph.getNodeLeftEx(above);
    var bottom = goDownToEnd(graph, branch.id);
    nodes[above.id] = true
    var isLast, rBottom, exit
    var leftBottom, rightBottom
    var rBottom
    if (above.right) {
        var right = graph.getNodeRightEx(above)
        rightBottom = goDownToEnd(graph, right.id)
        isLast = (rightBottom.type == "end")
        exit = false
        if (isLast) {
            rBottom = goRightToEnd(graph, bottom.id);
        } else {
            nodes[rightBottom.id] = true;
            rBottom = graph.getNodeLeftEx(rightBottom);
        }
        leftBottom = graph.getNodeLeftEx(bottom)
        nodes[leftBottom.id] = true
    } else {
        rightBottom = null
        isLast = true
        exit = (bottom.type == "end")
        if (exit) {
            rBottom = goRightToEnd(graph, bottom.id);
            leftBottom = null
        } else {
            rBottom = goRightToEnd(graph, bottom.id);
            leftBottom = graph.getNodeLeftEx(bottom)
            nodes[leftBottom.id] = true
        }
    }
    graph.enumerateManhattan(
    	id,
    	nodes,
    	edges
    );
    if (leftBottom) {
        delete nodes[leftBottom.id];
        delete edges[bottom.left];
    }
    if (rightBottom) {
        delete nodes[rightBottom.id];
        delete edges[rightBottom.left];
    }
    return {
    	nodes: nodes,
    	edges: edges,
    	top: above.id,
    	bottom: bottom.id,
    	rBottom: rBottom.id,
    	isLast: isLast,
    	exit: exit,
    	isLastUp: !(above.right)
    };
}

function findBranchLeft(graph, header) {
    var left = header.box.left
    var node = header
    while (true) {
        if (node.down) {
            
        } else {
            break;
        }
        node = graph.getNodeDownEx(node)
        if (node.type == "junction") {
            
        } else {
            left = Math.min(left, node.box.left)
            if (node.left) {
                var timer = graph.getNodeLeftEx(node)
                left = Math.min(left, timer.box.left)
            }
        }
    }
    return left
}

function findCases(graph, select) {
    var result = [];
    var jointId = graph.getNodeDown(select);
    while (true) {
        var joint = graph.getNode(jointId);
        var caseId = graph.getNodeDown(joint);
        var caseNode = graph.getNode(caseId);
        result.push(caseNode.content);
        if (joint.right) {
            
        } else {
            break;
        }
        jointId = graph.getNodeRight(joint);
    }
    return result;
}

function findClosest(editor, referenceItem, criteria) {
    var finder = new MinDistFinder(
    	referenceItem,
    	referenceItem.id,
    	criteria
    )
    var graph = editor.storage.graph
    var _ind20120 = 0;
    var _col20120 = graph.items;
    var _keys20120 = Object.keys(_col20120); 
    var _len20120 = _keys20120.length;
    while (true) {
        if (_ind20120 < _len20120) {
            
        } else {
            break;
        }
        var id = _keys20120[_ind20120]; var item = _col20120[id];
        finder.check(id, item)
        _ind20120++;
    }
    var free = editor.storage.free
    var _ind20129 = 0;
    var _col20129 = free.set;
    var _keys20129 = Object.keys(_col20129); 
    var _len20129 = _keys20129.length;
    while (true) {
        if (_ind20129 < _len20129) {
            
        } else {
            break;
        }
        var id = _keys20129[_ind20129]; var item = _col20129[id];
        finder.check(id, item)
        _ind20129++;
    }
    return finder.found
}

function findCornerSocket(graph, edge, target) {
    var result = null;
    if (isArrowStart(graph, target)) {
        
    } else {
        var tail = graph.getTail(edge);
        var desc = describeJunction(target);
        var roof = goUpToEnd(graph, edge.head);
        if (target.y > roof.y) {
            if (desc === "left-up") {
                var leftEdge = graph.getEdge(target.left);
                var upEdge = graph.getEdge(target.up);
                if (target.mark === edge.upperMark) {
                    if (((target.y > tail.y) && (!(detectOuterCycle(graph, 
edge.tail, target.id)))) && (!(upEdge.role == "par-down"))) {
                        if (leftEdge.role === "sil_floor") {
                            result = "leftOuterCornerSil";
                        } else {
                            result = "leftOuterCorner";
                        }
                    }
                } else {
                    if (((((target.mark === edge.lowerMark) && (target.x < tail.x)) && (!(detectInternalCycle(graph, 
edge.tail, target.id)))) && (!(upEdge.role == "par-down"))) && (!(leftEdge.role === "sil_floor"))) {
                        result = "leftInnerCorner";
                    }
                }
            } else {
                if (desc === "left-down") {
                    var vertical = graph.getEdge(
                    	target.down
                    );
                    if (downRole(vertical)) {
                        if (target.mark === edge.upperMark) {
                            if ((target.y > tail.y) && (!(detectOuterCycle(graph, 
edge.tail, target.id)))) {
                                result = "topOuterCorner";
                            }
                        } else {
                            if ((target.mark === edge.lowerMark) && (!(detectInternalCycle(graph, 
edge.tail, target.id)))) {
                                result = "topInnerCorner";
                            }
                        }
                    }
                } else {
                    if (((desc === "right-up") && (target.mark === edge.upperMark)) && (target.x > tail.x)) {
                        var rightEdge = graph.getEdge(target.right);
                        if (((rightEdge.role === "right") && (isUnderCase(graph, tail.id))) && (isUnderCase(graph, target.id))) {
                            result = "rightCorner";
                        }
                    }
                }
            }
        }
    }
    return result;
}

function findCycleStartCandidates(graph, node, mark) {
    var candidates = [];
    var count = 0;
    while (true) {
        if (count < 0) {
            break;
        }
        if (node.up) {
            var edge = graph.getEdge(node.up);
            if (((downRole(edge)) && (edge.upperMark === mark)) && (count === 0)) {
                candidates.push(edge.id);
            }
            node = graph.getNode(edge.head);
        } else {
            if (hasLeft(graph, node)) {
                
            } else {
                break;
            }
            node = leftToEndNoDuration(graph, node.id)
        }
        if (node.type === "loopbegin") {
            count--;
        } else {
            if (node.type === "loopend") {
                count++;
            }
        }
    }
    return candidates;
}

function findDiagramBox(graph) {
    var left = Number.MAX_VALUE
    var right = -Number.MAX_VALUE
    var top = Number.MAX_VALUE
    var bottom = -Number.MAX_VALUE
    var box = findDiagramBoxCore(
    	graph,
    	left,
    	top,
    	right,
    	bottom
    )
    var border = Config.METRE;
    left = getRidOfMinMax(box.left, 0)
    right = getRidOfMinMax(box.right, 300)
    top = getRidOfMinMax(box.top, 0)
    bottom = getRidOfMinMax(box.bottom, 300)
    return new Utils.Box(
    	left - border,
    	top - border,
    	right + border,
    	bottom + border
    );
}

function findDiagramBoxCore(graph, left, top, right, bottom) {
    var _ind18696 = 0;
    var _col18696 = graph.nodes;
    var _keys18696 = Object.keys(_col18696); 
    var _len18696 = _keys18696.length;
    while (true) {
        if (_ind18696 < _len18696) {
            
        } else {
            break;
        }
        var id = _keys18696[_ind18696]; var node = _col18696[id];
        var box = node.box;
        left = Math.min(left, box.left)
        top = Math.min(top, box.top)
        right = Math.max(right, box.right)
        bottom = Math.max(bottom, box.bottom)
        _ind18696++;
    }
    return new Utils.Box(
    	left,
    	top,
    	right,
    	bottom
    );
}

function findDistance(item1, item2) {
    var dx = item2.x - item1.x
    var dy = item2.y - item1.y
    return Math.sqrt(dx * dx + dy * dy)
}

function findDownSocket(graph, edge, target, tJoint, isArrow) {
    var result = null;
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    var targetHead = graph.getHead(target);
    var targetTail = graph.getTail(target);
    var origin = findPathOrigin(graph, tail.id);
    if (tJoint) {
        if (((((target.upperMark === edge.lowerMark) && (!(isNakedCorner(graph, target)))) && (!(targetHead.y < origin.y))) && (!(detectInternalCycle(graph, 
edge.tail, target.tail)))) && (!(isNextToCorner(graph, targetTail)))) {
            result = "leftInnerLine";
        }
    } else {
        if (target.upperMark === edge.lowerMark) {
            if (((((isNakedCorner(graph, target)) || (targetHead.y < origin.y)) || (detectInternalCycle(graph, 
edge.tail, target.tail))) || (isArrow == "sq")) || (isNextToCorner(graph, targetTail))) {
                
            } else {
                result = "leftInnerLine";
            }
        } else {
            if (target.lowerMark === edge.upperMark) {
                if ((((targetHead.x > head.x) && (!(endsWithRightTurn(graph, target.tail)))) && (!(isInCycleBody(graph, target.id)))) && (!(isArrow))) {
                    var targetCeiling = goUpToEnd(graph, target.head);
                    if (tail.y > targetCeiling.y) {
                        result = "rightLine";
                    }
                }
            } else {
                if (((((target.upperMark === edge.upperMark) && (targetTail.y > tail.y)) && (!(isNakedCorner(graph, target)))) && (!(detectOuterCycle(graph, 
edge.tail, target.tail)))) && (!(isNextToCorner(graph, targetTail)))) {
                    if (isArrow) {
                        if (isArrow == "sq") {
                            result = "shortCycleDown";
                        }
                    } else {
                        result = "leftOuterLine";
                    }
                }
            }
        }
    }
    return result;
}

function findDraggable(x, y) {
    var prim = findSocket(x, y);
    if (prim) {
        return new Draggable(
        	prim,
        	Const.DRN_SOCKET,
        	null
        );
    } else {
        var i
        var length = self.grips.length
        i = length - 1;
        while (true) {
            if (i >= 0) {
                
            } else {
                var itemId = findFreeItem(
                	self,
                	x,
                	y
                );
                if (itemId) {
                    return createItemDraggable(
                    	self,
                    	itemId,
                    	x,
                    	y
                    )
                } else {
                    itemId = 
                      self.canvas.pgraph.findPhysicalItem(
                    	x,
                    	y
                    );
                    if (itemId) {
                        return createItemDraggable(
                        	self,
                        	itemId,
                        	x,
                        	y
                        )
                    } else {
                        return null;
                    }
                }
                break;
            }
            var grip = self.grips[i]
            if (Utils.hitBox(grip.touchBox, x, y)) {
                return new Draggable(
                	grip.id,
                	grip.type,
                	Utils.copyObject(grip.dims)
                );
            }
            i--;
        }
    }
}

function findEdgeAbove(commandList, nodeId) {
    var _ind18294 = 0;
    var _col18294 = commandList;
    var _len18294 = _col18294.length;
    while (true) {
        if (_ind18294 < _len18294) {
            
        } else {
            return null
        }
        var command = _col18294[_ind18294];
        if ((((command.type == "insert") && (command.table == "edges")) && (command.fields.tail == nodeId)) && (command.fields.role == "down")) {
            return command.id
        }
        _ind18294++;
    }
}

function findFreeItem(editor, x, y) {
    var free = editor.storage.free
    var i
    i = free.list.length - 1;
    while (true) {
        if (i >= 0) {
            
        } else {
            return null
        }
        var id = free.list[i]
        var item = free.set[id]
        if (hitFreeItem(item, x, y)) {
            return id
        }
        i--;
    }
}

function findFreeItemsBox(free, left, top, right, bottom) {
    var _ind18708 = 0;
    var _col18708 = free.set;
    var _keys18708 = Object.keys(_col18708); 
    var _len18708 = _keys18708.length;
    while (true) {
        if (_ind18708 < _len18708) {
            
        } else {
            break;
        }
        var id = _keys18708[_ind18708]; var item = _col18708[id];
        var box = getBox(item, null)
        left = Math.min(box.left, left)
        top = Math.min(box.top, top)
        right = Math.max(box.right, right)
        bottom = Math.max(box.bottom, bottom)
        _ind18708++;
    }
    return new Utils.Box(
    	left,
    	top,
    	right,
    	bottom
    );
}

function findGripAllPoint(grips) {
    var count = grips.length
    var LARGE = 10000000
    var top = LARGE
    var left = LARGE
    var right = -LARGE
    var i
    if (count == 0) {
        return null
    } else {
        i = 0;
        while (true) {
            if (i < count) {
                
            } else {
                break;
            }
            var grip = grips[i]
            left = Math.min(left, grip.x)
            right = Math.max(right, grip.x)
            top = Math.min(top, grip.y)
            i++;
        }
        var xavg = (left + right) / 2
        return new Utils.Point(
        	xavg,
        	top - 30
        )
    }
}

function findHead(graph) {
    var _ind3695 = 0;
    var _col3695 = graph.nodes;
    var _keys3695 = Object.keys(_col3695); 
    var _len3695 = _keys3695.length;
    while (true) {
        if (_ind3695 < _len3695) {
            
        } else {
            Utils.throwError(
             "Head not found");
            break;
        }
        var id = _keys3695[_ind3695]; var node = _col3695[id];
        if (node.role === "header") {
            return node;
        }
        _ind3695++;
    }
}

function findInsertedEdge(commandList) {
    var _ind11924 = 0;
    var _col11924 = commandList;
    var _len11924 = _col11924.length;
    while (true) {
        if (_ind11924 < _len11924) {
            
        } else {
            Utils.throwError(
             "down edge not found");
            break;
        }
        var command = _col11924[_ind11924];
        if (((command.type == "insert") && (command.table == "edges")) && (downRole(command.fields))) {
            return command.id;
        }
        _ind11924++;
    }
}

function findItemsToDrag(editor, id) {
    gShouldMoveAll = true
    var selection = getSelectedIds(editor)
    if ((id) && (!(id in selection))) {
        gShouldMoveAll = false
        return [id]
    } else {
        return getAllFreeSelected(editor, selection)
    }
}

function findLedgeDimensions(graph, source, target) {
    var min = -1000000;
    var result = new Utils.Point(min, min);
    var srcNode = graph.getNode(source);
    var leftX = srcNode.x;
    recordDimension(srcNode, result);
    if (source == target) {
        recordDimension(srcNode, result);
    } else {
        if (srcNode.right) {
            scanRight(leftX, graph, srcNode, target, result);
        } else {
            if (srcNode.down) {
                scanDown(leftX, graph, srcNode, target, result);
            } else {
                scanLeft(leftX, graph, srcNode, target, result);
            }
        }
    }
    result.y += Config.METRE;
    result.x += Config.METRE;
    return result;
}

function findLedgeFromOrigin(graph, nodeId, targetId) {
    var origin = findPathOrigin(graph, nodeId);
    var below = graph.getNodeDown(origin);
    if (below == targetId) {
        return new Utils.Point(
        	origin.box.right,
        	origin.box.bottom
        );
    } else {
        return findLedgeDimensions(
        	graph,
        	below,
        	targetId
        );
    }
}

function findLeft(graph, item) {
    if (item.left) {
        return graph.getNodeLeft(item)
    } else {
        return null
    }
}

function findLeftMostOnSurface(graph, source, targetId) {
    var x = 100000000;
    var found = null;
    var visitor = function(node) {
    	if (node.x < x) {
    		x = node.x;
    		found = node;
    	}
    };
    scanSurface(
    	graph,
    	source,
    	targetId,
    	visitor
    );
    return found;
}

function findLeftSkewerEdge(pgraph, id) {
    var graph = pgraph.graph;
    var node = graph.getNode(id);
    var x = node.x;
    var vertical = graph.getVertical(id);
    var _ind15207 = 0;
    var _col15207 = vertical;
    var _len15207 = _col15207.length;
    while (true) {
        if (_ind15207 < _len15207) {
            
        } else {
            break;
        }
        var iid = _col15207[_ind15207];
        var item = graph.getItem(iid);
        if (((item.isLine) || (item.type == "beginend")) || (item.type == "end")) {
            
        } else {
            var duration = Drakon.getDuration(graph, item);
            var left;
            if (duration) {
                left = duration.box.left;
            } else {
                left = item.box.left
            }
            x = Math.min(x, left);
        }
        _ind15207++;
    }
    if (x == node.x) {
        x = node.x - Config.DEF_ICON_WIDTH;
    }
    return x;
}

function findLeftSocket(graph, edge, target) {
    var result = null;
    var tail = graph.getTail(edge);
    var targetTail = graph.getTail(target);
    if (tail.y < targetTail.y) {
        if (target.upperMark === edge.lowerMark) {
            result = "onInnerFloor";
        } else {
            if (target.upperMark === edge.upperMark) {
                result = "onOuterFloor";
            }
        }
    }
    return result;
}

function findLowerNodes(graph, leftBottom) {
    var result = [];
    var floor0 = leftBottom;
    while (true) {
        var floor1 = graph.getNodeUpEx(floor0);
        result.push(floor0);
        result.push(floor1);
        if (floor0.right) {
            
        } else {
            break;
        }
        floor0 = graph.getNodeRightEx(floor0);
    }
    return result;
}

function findManyNodesBy(graph, property, value) {
    var result = [];
    var _ind10244 = 0;
    var _col10244 = graph.nodes;
    var _keys10244 = Object.keys(_col10244); 
    var _len10244 = _keys10244.length;
    while (true) {
        if (_ind10244 < _len10244) {
            
        } else {
            break;
        }
        var id = _keys10244[_ind10244]; var node = _col10244[id];
        if (node[property] === value) {
            result.push(node);
        }
        _ind10244++;
    }
    return result;
}

function findMindDelete(item) {
    var graph = self.storage.graph
    var result = null
    if ((item.isLine) || (item.type == "junction")) {
        
    } else {
        if (item.up) {
            var above = graph.getNodeUpEx(item)
            if (above.type == "junction") {
                var type = describeJunction(above)
                if (type === "left-down") {
                    var left = graph.getNodeLeftEx(above)
                    var leftType = describeJunction(left)
                    if (leftType == "up-t") {
                        result = "mdh02"
                    } else {
                        result = "mdh03"
                    }
                } else {
                    if (type === "right-down") {
                        var right = graph.getNodeRightEx(above)
                        var rightType = describeJunction(right)
                        if (rightType == "up-t") {
                            result = "mdh04"
                        } else {
                            result = "mdh05"
                        }
                    } else {
                        result = "mdh06"
                    }
                }
            } else {
                result = "mdh01"
            }
        } else {
            if (item.left) {
                var leftmost = goLeftToEnd(
                	graph,
                	item.id
                )
                if (leftmost.up) {
                    if (leftmost.down) {
                        result = "mdv03"
                    } else {
                        var upJ = graph.getNodeUpEx(leftmost)
                        var aboveEdge = graph.getEdge(upJ.right)
                        if (aboveEdge.role == "link") {
                            result = "mdv01"
                        } else {
                            var upperSibling = graph.getNodeRightEx(upJ)
                            if (upperSibling.role == "header") {
                                result = "mdv01"
                            } else {
                                result = "mdv02"
                            }
                        }
                    }
                }
            }
        }
    }
    return result
}

function findNextOnWall(graph, src) {
    var node = src.node;
    var edge = src.edge.id;
    if (canGo(node.right, edge)) {
        var rightEdge = graph.getEdge(node.right);
        if (rightEdge.role === "left") {
            
        } else {
            return grabForward(
            	graph,
            	node.right
            );
        }
    } else {
        if (canGo(node.down, edge)) {
            return grabForward(
            	graph,
            	node.down
            );
        } else {
            if (canGo(node.left, edge)) {
                return grabBack(
                	graph,
                	node.left
                );
            } else {
                if (canGo(node.up, edge)) {
                    return grabBack(
                    	graph,
                    	node.up
                    );
                }
            }
        }
    }
    Utils.throwError(
     "Invalid op");
}

function findNodeByRole(graph, role) {
    var _ind9460 = 0;
    var _col9460 = graph.nodes;
    var _keys9460 = Object.keys(_col9460); 
    var _len9460 = _keys9460.length;
    while (true) {
        if (_ind9460 < _len9460) {
            
        } else {
            return null;
        }
        var id = _keys9460[_ind9460]; var node = _col9460[id];
        if (node.role === role) {
            return node;
        }
        _ind9460++;
    }
}

function findNodesBelow(graph, nodeId, bottom) {
    var id = nodeId;
    var result = [];
    while (true) {
        var node = graph.getNode(id);
        if (node.y > bottom) {
            break;
        }
        result.push(node);
        if (node.down) {
            id = graph.getNodeDown(node);
        } else {
            if (node.left) {
                
            } else {
                break;
            }
            id = graph.getNodeLeft(node);
        }
    }
    return result;
}

function findNodesBelowEx(graph, node, bottom) {
    var result = traverseRightSide(
    	graph,
    	node.id,
    	node.x,
    	bottom
    );
    if (result.length == 0) {
        return [node];
    } else {
        return result;
    }
}

function findPathOrigin(graph, nodeId) {
    var node = graph.getNode(nodeId);
    var upId = graph.getNodeUp(node);
    return findPathOriginUp(graph, upId);
}

function findPathOriginLeft(graph, nodeId) {
    var id = nodeId;
    var node;
    while (true) {
        node = graph.getNode(id);
        if (node.down) {
            return node;
        }
        if (node.left) {
            
        } else {
            id = graph.getNodeUp(node);
            return findPathOriginUp(graph, id);
        }
        id = graph.getNodeLeft(node);
    }
}

function findPathOriginUp(graph, nodeId) {
    var id = nodeId;
    var node;
    while (true) {
        node = graph.getNode(id);
        if (hasLeft(graph, node)) {
            break;
        }
        id = graph.getNodeUp(node);
    }
    id = graph.getNodeLeft(node);
    return findPathOriginLeft(graph, id);
}

function findPoisoned(graph, id) {
    var edge = graph.getEdge(id);
    var result = {};
    if (edge.isVertical) {
        var center = graph.getTail(edge);
        if ((center.left) && (!(questionOnLeft(graph, center)))) {
            result[center.left] = true;
            var leftArm = graph.getEdge(center.left);
            var leftNode = graph.getHead(leftArm);
            result[leftNode.id] = true;
            Utils.addNotNilToSet(result, leftNode.down);
            if (((isUpT(center)) || (isUpT(leftNode))) || (!(leftNode.type === "junction"))) {
                
            } else {
                Utils.addNotNilToSet(result, leftNode.up);
            }
        }
        if (center.right) {
            result[center.right] = true;
            var rightArm = graph.getEdge(center.right);
            var rightNode = graph.getTail(rightArm);
            result[rightNode.id] = true;
            Utils.addNotNilToSet(result, rightNode.down);
            if ((isUpT(center)) || (isUpT(rightNode))) {
                
            } else {
                Utils.addNotNilToSet(result, rightNode.up);
            }
        }
        var leg = graph.getVertical(id);
        var legSet = Utils.listToSet(leg);
        Utils.mergeSets(result, legSet);
    }
    return result;
}

function findRight(graph, item) {
    if (item.right) {
        return graph.getNodeRight(item)
    } else {
        return null
    }
}

function findRightEdge(graph, nodeId, bottom) {
    var id = nodeId;
    var result = [];
    while (true) {
        var node = graph.getNode(id);
        if (node.y > bottom) {
            break;
        }
        result.push(node);
        if (node.down) {
            
        } else {
            break;
        }
        id = graph.getNodeDown(node);
    }
    return result;
}

function findRightSocket(graph, edge, target) {
    var result = null;
    var tail = graph.getTail(edge);
    var targetTail = graph.getTail(target);
    if ((tail.y < targetTail.y) && (target.upperMark === edge.upperMark)) {
        result = "onOuterFloor";
    }
    return result;
}

function findSecondBranch(graph, cross) {
    var rightId =graph.getNodeRight(cross);
    var bottom = goDownToEnd(graph, rightId);
    return bottom.id;
}

function findSiblingAddresses(graph, junction, nextBranchId, found) {
    var result = [];
    while (true) {
        var aboveId = graph.getNodeUp(junction);
        result.push(aboveId);
        if (junction.right) {
            
        } else {
            break;
        }
        var rightId =graph.getNodeRight(junction);
        if (rightId == nextBranchId) {
            break;
        }
        junction = graph.getNode(rightId);
    }
    return result;
}

function findSilSocket(graph, edge, target) {
    var result = null;
    var tail = graph.getTail(edge);
    var targetTail = graph.getTail(target);
    if (target.upperMark === edge.upperMark) {
        result = "onOuterSilFloor";
    }
    return result;
}

function findSocket(x, y) {
    var _ind12228 = 0;
    var _col12228 = self.canvas.sockets;
    var _keys12228 = Object.keys(_col12228); 
    var _len12228 = _keys12228.length;
    while (true) {
        if (_ind12228 < _len12228) {
            
        } else {
            return null;
        }
        var prim = _keys12228[_ind12228]; var socket = _col12228[prim];
        if (Utils.hitBox(socket.box, x, y)) {
            return prim;
        }
        _ind12228++;
    }
}

function findSourceHorizontal(graph, edge) {
    var _sw182680000_ = 0;
    var left = graph.getHead(edge);
    var right = graph.getTail(edge);
    if (right.type == "junction") {
        var rightType = describeJunction(right)
        _sw182680000_ = left.type;
        if (_sw182680000_ === "junction") {
            var leftType = describeJunction(left)
            if ((rightType == "left-up") && ((leftType == "right-t") || (leftType == "up-t"))) {
                return right.id;
            } else {
                if (((rightType == "left-t") && (leftType == "right-up")) || ((rightType == "left-up") && (leftType == "right-up"))) {
                    return left.id;
                } else {
                    if (((leftType == "right-t") && (rightType == "left-down")) && (edge.role == "arrow")) {
                        return findArrowStart(graph, right.id);
                    } else {
                        return null;
                    }
                }
            }
        } else {
            if (_sw182680000_ === "question") {
                if (rightType === "left-up") {
                    return right.id
                } else {
                    if (rightType === "left-t") {
                        return edge.id
                    } else {
                        return null;
                    }
                }
            } else {
                return null;
            }
        }
    } else {
        return null;
    }
}

function findSourceJunction(graph, node) {
    var type = describeJunction(node);
    if (type === "up-t") {
        var upId = graph.getNodeUp(node);
        var up = graph.getNode(upId);
        if (up.type == "address") {
            return upId;
        } else {
            return null;
        }
    } else {
        if (type === "right-t") {
            var rightId = graph.getNodeRight(node);
            var right = graph.getNode(rightId);
            if (right.type == "junction") {
                if (describeJunction(right) == "left-up") {
                    return rightId;
                } else {
                    var rightEdge = graph.getEdge(node.right);
                    if (rightEdge.role == "arrow") {
                        return findArrowStart(graph, rightEdge.tail);
                    } else {
                        return null;
                    }
                }
            } else {
                return null;
            }
        } else {
            if (type === "left-t") {
                var leftId = graph.getNodeLeft(node);
                var left = graph.getNode(leftId);
                if ((left.type == "junction") && (describeJunction(left) == "right-up")) {
                    return leftId;
                } else {
                    return null;
                }
            } else {
                if (type === "left-down") {
                    var leftEdge = graph.getEdge(node.left);
                    if (leftEdge.role == "arrow") {
                        return findArrowStart(graph, node.id);
                    } else {
                        return null;
                    }
                } else {
                    if (type === "left-up") {
                        if (questionOnLeft(graph, node)) {
                            return node.id;
                        } else {
                            var leftEdge = graph.getEdge(node.left);
                            if (leftEdge.role) {
                                if (leftEdge.role == "sil_floor") {
                                    return graph.getNodeUp(node);
                                } else {
                                    var upId = graph.getNodeUp(node);
                                    var up = graph.getNode(upId);
                                    var leftUpEdge = graph.getEdge(up.left);
                                    if (leftUpEdge.role == "arrow") {
                                        var left = graph.getNode(leftEdge.head);
                                        if (left.left) {
                                            return null;
                                        } else {
                                            return left.id;
                                        }
                                    } else {
                                        return null;
                                    }
                                }
                            } else {
                                return null;
                            }
                        }
                    } else {
                        return null;
                    }
                }
            }
        }
    }
}

function findSourceVertical(graph, edge) {
    var up = graph.getHead(edge);
    var down = graph.getTail(edge);
    if ((up.type == "junction") && (down.type == "junction")) {
        var upType = describeJunction(up);
        var downType = describeJunction(down);
        if ((upType == "left-down") && (downType == "left-up")) {
            var roof = graph.getEdge(up.left);
            if (roof.role == "arrow") {
                return findArrowStart(graph, up.id);
            } else {
                return null;
            }
        } else {
            return null;
        }
    } else {
        if (up.type == "address") {
            return up.id;
        } else {
            if (down.type == "address") {
                return down.id;
            } else {
                return null;
            }
        }
    }
}

function findTExitSocket(graph, sourceEdge, targetEdge) {
    if (targetEdge.upperMark == sourceEdge.lowerMark) {
        var head = graph.getHead(sourceEdge);
        var tail = graph.getTail(sourceEdge);
        var targetHead = graph.getHead(targetEdge);
        var targetTail = graph.getTail(targetEdge);
        if ((isNakedCorner(graph, targetEdge)) || (targetHead.y < head.y)) {
            return null
        } else {
            var rightDown = graph.getNodeDown(tail)
            if ((detectInternalCycle(graph, 
rightDown, targetEdge.tail)) || (isNextToCorner(graph, targetTail))) {
                return null
            } else {
                return "leftInnerLineEx";
            }
        }
    } else {
        return null
    }
}

function findTExitSockets(graph, edge) {
    var sockets = []
    var _ind18346 = 0;
    var _col18346 = graph.edges;
    var _keys18346 = Object.keys(_col18346); 
    var _len18346 = _keys18346.length;
    while (true) {
        if (_ind18346 < _len18346) {
            
        } else {
            break;
        }
        var targetId = _keys18346[_ind18346]; var targetEdge = _col18346[targetId];
        if ((targetEdge.role == "down") || (targetEdge.role == "par-down")) {
            joinType = findTExitSocket(
            	graph,
            	edge,
            	targetEdge
            );
            if (joinType) {
                appendSocket(
                	sockets,
                	targetId,
                	joinType
                );
            }
        }
        _ind18346++;
    }
    return sockets
}

function findTargetSockets(graph, id, poisoned, isArrow) {
    var _sw39540000_ = 0;
    var sockets = [];
    var edge = graph.getEdge(id);
    var tJoint = isFromTJoint(graph, edge);
    var _ind3404 = 0;
    var _col3404 = graph.items;
    var _keys3404 = Object.keys(_col3404); 
    var _len3404 = _keys3404.length;
    while (true) {
        if (_ind3404 < _len3404) {
            
        } else {
            break;
        }
        var iid = _keys3404[_ind3404]; var item = _col3404[iid];
        var joinType = null;
        if (item.id in poisoned) {
            
        } else {
            if (item.isLine) {
                _sw39540000_ = item.role;
                if ((_sw39540000_ === "down") || (_sw39540000_ === "par-down")) {
                    joinType = findDownSocket(
                    	graph,
                    	edge,
                    	item,
                    	tJoint,
                    	isArrow
                    );
                } else {
                    if (_sw39540000_ === "left") {
                        if ((tJoint) || (isArrow)) {
                            
                        } else {
                            joinType = findLeftSocket(
                            	graph,
                            	edge,
                            	item
                            );
                        }
                    } else {
                        if (_sw39540000_ === "sil_floor") {
                            if ((tJoint) || (isArrow)) {
                                
                            } else {
                                joinType = findSilSocket(
                                	graph,
                                	edge,
                                	item
                                );
                            }
                        } else {
                            if (((_sw39540000_ === "right") && (!(tJoint))) && (!(isArrow))) {
                                joinType = findRightSocket(
                                	graph,
                                	edge,
                                	item
                                );
                            }
                        }
                    }
                }
            } else {
                if ((((item.type === "junction") && (item.mark)) && (!(tJoint))) && (!(isArrow))) {
                    joinType = findCornerSocket(
                    	graph,
                    	edge,
                    	item
                    );
                }
            }
        }
        if (joinType) {
            appendSocket(
            	sockets,
            	item.id,
            	joinType
            );
        }
        _ind3404++;
    }
    if ((tJoint) || (isArrow)) {
        
    } else {
        findUpCycle(
        	graph,
        	edge,
        	sockets
        );
    }
    return sockets;
}

function findTopMost(editor) {
    var found = null
    var minY = 1000000000
    var graph = editor.storage.graph
    var _ind20091 = 0;
    var _col20091 = graph.items;
    var _keys20091 = Object.keys(_col20091); 
    var _len20091 = _keys20091.length;
    while (true) {
        if (_ind20091 < _len20091) {
            
        } else {
            break;
        }
        var id = _keys20091[_ind20091]; var item = _col20091[id];
        if (item.y < minY) {
            found = id
            minY = item.y
        }
        _ind20091++;
    }
    var free = editor.storage.free
    var _ind20100 = 0;
    var _col20100 = free.set;
    var _keys20100 = Object.keys(_col20100); 
    var _len20100 = _keys20100.length;
    while (true) {
        if (_ind20100 < _len20100) {
            
        } else {
            break;
        }
        var id = _keys20100[_ind20100]; var item = _col20100[id];
        if (item.y < minY) {
            found = id
            minY = item.y
        }
        _ind20100++;
    }
    return found
}

function findTransplantSource(graph, id) {
    var otherId;
    var item = graph.getItem(id);
    if (canTransplantFrom(graph, id)) {
        return id;
    } else {
        if (item.isLine) {
            if (item.isVertical) {
                otherId = findSourceVertical(graph, item)
            } else {
                otherId = findSourceHorizontal(graph, item)
            }
            if ((otherId) && (canTransplantFrom(graph, otherId))) {
                return otherId;
            } else {
                return null;
            }
        } else {
            if (item.type == "junction") {
                otherId = findSourceJunction(graph, item)
                if ((otherId) && (canTransplantFrom(graph, otherId))) {
                    return otherId;
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }
    }
}

function findTs2Sockets(graph, id) {
    var sockets = [];
    var edge = graph.getEdge(id);
    var head = graph.getNode(edge.head)
    var below = graph.getNodeDownEx(head)
    appendSocket(
    	sockets,
    	below.id,
    	"leftOuterCornerTs"
    )
    return sockets;
}

function findTsSockets(graph, id) {
    var sockets = [];
    var edge = graph.getEdge(id);
    var lowerHead = goLeftToEnd(graph, edge.head)
    var lower = graph.getEdge(lowerHead.down)
    var upperTail = graph.getNode(edge.head)
    var upper = graph.getEdge(upperTail.up)
    appendSocket(
    	sockets,
    	upper.id,
    	"leftInnerLineTs"
    )
    appendSocket(
    	sockets,
    	lower.id,
    	"leftOuterLineTs"
    )
    return sockets;
}

function findUpCycle(graph, edge, sockets) {
    var tail = graph.getTail(edge);
    var tailType = describeJunction(tail);
    if (tailType === "right-up") {
        
    } else {
        var split = findPathOrigin(graph, edge.tail);
        var candidates = findCycleStartCandidates(
        	graph,
        	split,
        	edge.upperMark
        );
        var _ind6198 = 0;
        var _col6198 = candidates;
        var _len6198 = _col6198.length;
        while (true) {
            if (_ind6198 < _len6198) {
                
            } else {
                break;
            }
            var candidate = _col6198[_ind6198];
            if (hasDoubleEntry(graph, split, candidate)) {
                
            } else {
                appendSocket(
                	sockets,
                	candidate,
                	"createCycle"
                );
            }
            _ind6198++;
        }
    }
}

function findVisualItem(x, y) {
    var item = findDraggable(x, y)
    if ((item) && (!(item.type == Const.DRN_SOCKET))) {
        return item
    } else {
        return null
    }
}

function fireSocket(prim) {
    self.canvas.render.setItemProperty(prim, "active", true);
    self.dirty = true;
}

function fitItemType(render, type, width, cont) {
    var item = {
    	isLine: false,
    	type: type,
    	content: cont,
    	x: 0,
    	y: 0,
    	w: width
    };
    var size = Drakon.fitItem(item, render);
    return size;
}

function followLink(editor, itemId) {
    addTrace(
    	"followLink",
    	[itemId]
    )
    var item = getAnyItem(editor.storage, itemId)
    var content = getContent(item)
    if (content.link) {
        var fun = Callbacks.followLink
        if (fun) {
            fun(content.link)
        }
    }
}

function generateId(storage) {
    var id = storage.nextId
    storage.nextId++
    return String(id)
}

function getAllFreeSelected(editor, selection) {
    var selectedFree = []
    var _ind19165 = 0;
    var _col19165 = selection;
    var _keys19165 = Object.keys(_col19165); 
    var _len19165 = _keys19165.length;
    while (true) {
        if (_ind19165 < _len19165) {
            
        } else {
            break;
        }
        var id = _keys19165[_ind19165]; var _ = _col19165[id];
        var item = getAnyItem(editor.storage, id)
        if (item.free) {
            selectedFree.push(id)
        }
        _ind19165++;
    }
    return selectedFree
}

function getAnyItem(storage, id) {
    var item = storage.free.get(id)
    if (item) {
        
    } else {
        item = storage.graph.getItem(id)
    }
    return item
}

function getBottom(node) {
    return node.y + node.h
}

function getBox(item, render) {
    var callback = Items.getItemCallback(item.type);
    return callback.makeBox(
    	item,
    	item.x,
    	item.y,
    	render
    );
}

function getBranchForEdge(graph, item) {
    var left;
    if (item.isLine) {
        left = graph.getHead(item);
    } else {
        left = item;
    }
    if (left.down) {
        var leftDownId = graph.getNodeDown(left);
        var leftDown = graph.getNode(leftDownId);
        if ((leftDown.type == "case") || (leftDown.type == "branch")) {
            return leftDown;
        } else {
            return null;
        }
    } else {
        return null;
    }
}

function getClipboard(type) {
    if (getClipboardType() == type) {
        var fun = Callbacks.getClipboard;
        if (fun) {
            return fun();
        } else {
            return null;
        }
    } else {
        return null;
    }
}

function getClipboardType() {
    var fun = Callbacks.getClipboardType;
    if (fun) {
        return fun();
    } else {
        return null;
    }
}

function getContent(node) {
    return node.content || new Utils.Content("", "");
}

function getDefault(key) {
    var result = null
    var fun = Callbacks.getDefault
    if (fun) {
        result = fun(key)
    }
    return result
}

function getDefaultFont() {
    var defaultFont = self.storage.font
    defaultFont = defaultFont || getDefault("font")
    var size
    var family
    if (defaultFont) {
        var parsed = Utils.parseFontString(defaultFont)
        size = parsed.size
        family = parsed.family
    } else {
        size = Config.FONT_SIZE
        family = Config.FONT_FAMILY
    }
    return {
    	size: size,
    	family: family
    }
}

function getDiagramAsItems() {
    var sane = getDiagramCopy(self)
    var output = {
    	name: sane.name,
    	items: []
    }
    setNotEmpty(
    	self.storage,
    	"background",
    	output
    )
    setNotEmpty(
    	self.storage,
    	"diaLine",
    	output
    )
    setNotEmpty(
    	self.storage,
    	"diaLineThickness",
    	output
    )
    setNotEmpty(
    	self.storage,
    	"font",
    	output
    )
    addItemsSubset(sane.nodes, output.items)
    addItemsSubset(sane.edges, output.items)
    addItemsSubset(sane.free, output.items)
    return output
}

function getDiagramCopy(editor) {
    var storage = editor.storage
    var free = storage.free
    var nodes = storage.graph.nodes
    var edges = storage.graph.edges
    var output = {
    	name: storage.name,
    	type: storage.type,
    	nodes: cloneDictionary(nodes),
    	edges: cloneDictionary(edges)
    }
    output.background = storage.background
    output.diaLine = storage.diaLine
    output.diaLineThickness = storage.diaLineThickness
    output.font = storage.font
    output.version = storage.version
    if (free.list.length == 0) {
        
    } else {
        output.free = cloneDictionary(free.set)
    }
    var sane = Utils.sanitizeDiagram(output)
    setNotEmpty(
    	storage,
    	"background",
    	sane
    )
    setNotEmpty(
    	storage,
    	"diaLine",
    	sane
    )
    setNotEmpty(
    	storage,
    	"diaLineThickness",
    	sane
    )
    setNotEmpty(
    	storage,
    	"font",
    	sane
    )
    return sane
}

function getEdgeHeight(head, tail) {
    return tail.box.top - head.box.bottom;
}

function getEnd() {
    if (gUserSettings.end) {
        return gUserSettings.end
    } else {
        return tr("DIA_END")
    }
}

function getFont() {
    return self.storage.font
}

function getFonts(diagram) {
    var fonts = {}
    if (diagram.nodes) {
        var _ind17864 = 0;
        var _col17864 = diagram.nodes;
        var _keys17864 = Object.keys(_col17864); 
        var _len17864 = _keys17864.length;
        while (true) {
            if (_ind17864 < _len17864) {
                
            } else {
                break;
            }
            var nid = _keys17864[_ind17864]; var item = _col17864[nid];
            rememberFont(item, fonts)
            _ind17864++;
        }
    }
    if (diagram.free) {
        var _ind17880 = 0;
        var _col17880 = diagram.free;
        var _keys17880 = Object.keys(_col17880); 
        var _len17880 = _keys17880.length;
        while (true) {
            if (_ind17880 < _len17880) {
                
            } else {
                break;
            }
            var id = _keys17880[_ind17880]; var free = _col17880[id];
            rememberFont(free, fonts)
            _ind17880++;
        }
    }
    if (diagram.font) {
        fonts[diagram.font] = true
    } else {
        var font = Utils.buildFontString(
        	false,
        	false,
        	Config.FONT_SIZE_1,
        	Config.FONT_FAMILY_1
        )
        fonts[font] = true
        if (diagram.type == "drakon") {
            var bfont = Utils.buildFontString(
            	false,
            	true,
            	Config.FONT_SIZE_1,
            	Config.FONT_FAMILY_1
            )
            fonts[bfont] = true
        }
    }
    return Object.keys(fonts)
}

function getFontsForItems(ids) {
    var fonts = {}
    var _ind22514 = 0;
    var _col22514 = ids;
    var _len22514 = _col22514.length;
    while (true) {
        if (_ind22514 < _len22514) {
            
        } else {
            break;
        }
        var id = _col22514[_ind22514];
        var item = getAnyItem(
        	self.storage,
        	id
        )
        var content = getContent(item)
        var font = content.font || self.storage.font
        fonts[font] = true
        _ind22514++;
    }
    var result = Object.keys(fonts)
    return result
}

function getFormat(ids) {
    var editor = self
    var hasDr = false
    var hasComment = false
    var hasLine = false
    var lineOnly = true
    var names = gFormatNames
    var result = {}
    var filled = {}
    var _ind17660 = 0;
    var _col17660 = ids;
    var _len17660 = _col17660.length;
    while (true) {
        if (_ind17660 < _len17660) {
            
        } else {
            break;
        }
        var id = _col17660[_ind17660];
        var item = getAnyItem(
        	editor.storage,
        	id
        )
        var content = getContent(item)
        if (item.free) {
            
        } else {
            hasDr = true
        }
        if (((item.type == "comment") || (item.type == "insertion")) || (item.type == "shelf")) {
            hasComment = true
        }
        if ((item.isLine) || (item.type == "f_line")) {
            hasLine = true
        } else {
            lineOnly = false
        }
        accumulateFormat(
        	names,
        	result,
        	filled,
        	content
        )
        _ind17660++;
    }
    result.allowTransparent = !hasDr
    result.hasLine = hasLine
    result.lineOnly = lineOnly
    if ((hasComment) && (ids.length == 1)) {
        result.allowSecondary = true
    } else {
        result.allowSecondary = false
    }
    return result
}

function getGuideFormat() {
    return {
    	lineThickness: 1,
    	lineColor: "#800000" //Items.getDiaLine()
    }
}

function getHardExpanders() {
    if (self.storage.type == "drakon") {
        return {
        	left: hardLeft,
        	up: hardUp,
        	right: hardRight,
        	down: hardDown
        };
    } else {
        var returnNull = function(a, b) {
        	return b
        }
        return {
        	left: returnNull,
        	up: returnNull,
        	right: returnNull,
        	down: returnNull
        };
        /*
        return {
        	left: hardLeftMind,
        	up: hardUpMind,
        	right: hardRightMind,
        	down: hardDownMind
        };
        */
    }
}

function getIconCount(graph) {
    var result = 0;
    var _ind14515 = 0;
    var _col14515 = graph.nodes;
    var _keys14515 = Object.keys(_col14515); 
    var _len14515 = _keys14515.length;
    while (true) {
        if (_ind14515 < _len14515) {
            
        } else {
            break;
        }
        var id = _keys14515[_ind14515]; var node = _col14515[id];
        if (node.type == "junction") {
            
        } else {
            result++;
        }
        _ind14515++;
    }
    return result;
}

function getIntersectionDelta(box1, hitItem) {
    var box2 = hitItem.box;
    if (hitItem.type == "duration") {
        return box1.right - box2.left;
    } else {
        var m1 = (box1.left + box1.right) / 2;
        var m2 = (box2.left + box2.right) / 2;
        if (m1 > m2) {
            return box1.left - box2.right;
        } else {
            return box1.right - box2.left;
        }
    }
}

function getItem(id) {
    var editor = self
    var item = getAnyItem(
    	editor.storage,
    	id
    )
    if (item) {
        return Utils.copyObjectDeep(item)
    } else {
        return null
    }
}

function getItemRect(id) {
    var editor = self
    var graph = editor.storage.graph
    var item = getAnyItem(editor.storage, id)
    if (item.isLine) {
        var head = graph.getHead(item)
        var tail = graph.getTail(item)
        return new Utils.Box(
        	head.x,
        	head.y,
        	tail.x,
        	tail.y
        )
    } else {
        return Utils.boxFromPoint(
        	item.x,
        	item.y,
        	item.w,
        	item.h
        )
    }
}

function getItemText(editor, id) {
    var item = editor.storage.graph.getItem(id);
    return getText(item);
}

function getLeft(node) {
    return node.x - node.w
}

function getMindActions(editor, item) {
    var _sw219640000_ = 0;
    var graph = editor.storage.graph
    var parent = null
    var type = null
    var action = null
    var result = []
    if (item.isLine) {
        _sw219640000_ = item.role;
        if (_sw219640000_ === "bridge") {
            above = graph.getNode(item.tail)
            var aboveSibling = leftWithDown(graph, above)
            var sibling = graph.getNodeDownEx(aboveSibling)
            result.push({
            	text: "MES_ADD_ITEM",
            	itemId: sibling.id,
            	action: "mih06"
            })
        } else {
            if (_sw219640000_ === "arm") {
                var lowJ = graph.getNode(item.tail)
                var sibling = goRightToEnd(graph, lowJ.id)
                result.push({
                	text: "MES_ADD_ITEM",
                	itemId: sibling.id,
                	action: "miv03"
                })
            }
        }
    } else {
        if (item.type == "junction") {
            type = describeJunction(item)
            parent = Mind.getHorParent(graph, item.id)
            if (type === "right-down") {
                var rightEdge = graph.getEdge(item.right)
                if (rightEdge.role == "bridge") {
                    result.push({
                    	text: "MES_ADD_ITEM",
                    	itemId: parent.id,
                    	action: "mih05"
                    })
                }
            } else {
                if (type === "left-down") {
                    var leftEdge = graph.getEdge(item.left)
                    if (leftEdge.role == "bridge") {
                        result.push({
                        	text: "MES_ADD_ITEM",
                        	itemId: parent.id,
                        	action: "mih03"
                        })
                    }
                } else {
                    if (type === "up-t") {
                        var leftEdge = graph.getEdge(item.left)
                        if (leftEdge.role == "bridge") {
                            var n1 = graph.getNode(leftEdge.head)
                            var sib = graph.getNodeDownEx(n1)
                            result.push({
                            	text: "MES_ADD_ITEM",
                            	itemId: sib.id,
                            	action: "mih06"
                            })
                        }
                    } else {
                        if (type === "right-up") {
                            var upEdge = graph.getEdge(item.up)
                            if (upEdge.role == "arm") {
                                var sibling = goRightToEnd(graph, item.id)
                                result.push({
                                	text: "MES_ADD_ITEM",
                                	itemId: sibling.id,
                                	action: "miv02"
                                })
                            }
                        }
                    }
                }
            }
        } else {
            if (item.up) {
                var above = graph.getNodeUpEx(item)
                if (above.type == "junction") {
                    parent = Mind.getHorParent(graph, above.id)
                    if (above.left) {
                        var aboveSibling = leftWithDown(graph, above)
                        var sibling = graph.getNodeDownEx(aboveSibling)
                        if (above.right) {
                            result.push({
                            	text: "MES_ADD_LEFT_ITEM",
                            	itemId: sibling.id,
                            	action: "mih06"
                            })
                            result.push({
                            	text: "MES_ADD_RIGHT_ITEM",
                            	itemId: item.id,
                            	action: "mih06"
                            })
                        } else {
                            result.push({
                            	text: "MES_ADD_LEFT_ITEM",
                            	itemId: sibling.id,
                            	action: "mih06"
                            })
                            result.push({
                            	text: "MES_ADD_RIGHT_ITEM",
                            	itemId: parent.id,
                            	action: "mih03"
                            })
                        }
                    } else {
                        result.push({
                        	text: "MES_ADD_LEFT_ITEM",
                        	itemId: parent.id,
                        	action: "mih05"
                        })
                        result.push({
                        	text: "MES_ADD_RIGHT_ITEM",
                        	itemId: item.id,
                        	action: "mih06"
                        })
                    }
                } else {
                    result.push({
                    	text: "MES_ADD_LEFT_ITEM",
                    	itemId: above.id,
                    	action: "mih04"
                    })
                    result.push({
                    	text: "MES_ADD_RIGHT_ITEM",
                    	itemId: above.id,
                    	action: "mih02"
                    })
                }
            }
            if (item.left) {
                var leftmost = goLeftToEnd(
                	graph,
                	item.id
                )
                if (leftmost.up) {
                    result.push({
                    	text: "MES_ADD_ITEM_ABOVE",
                    	itemId: item.id,
                    	action: "miv03"
                    })
                }
                if (leftmost.down) {
                    var j1 = graph.getNodeDownEx(leftmost)
                    var sibling = goRightToEnd(graph, j1.id)
                    result.push({
                    	text: "MES_ADD_ITEM_BELOW",
                    	itemId: sibling.id,
                    	action: "miv03"
                    })
                } else {
                    result.push({
                    	text: "MES_ADD_ITEM_BELOW",
                    	itemId: item.id,
                    	action: "miv02"
                    })
                }
            }
            if (item.down) {
                
            } else {
                if (((item.up) || (item.role == "header")) && (!(item.left))) {
                    result.push({
                    	text: "MES_ADD_CHILD",
                    	itemId: item.id,
                    	action: "mih01"
                    })
                }
                if (hasVerticalChildren(graph, item)) {
                    
                } else {
                    if (item.role == "header") {
                        result.push({
                        	text: "MES_ADD_VER_CHILD",
                        	itemId: item.id,
                        	action: "miv04"
                        })
                    } else {
                        result.push({
                        	text: "MES_ADD_VER_CHILD",
                        	itemId: item.id,
                        	action: "miv01"
                        })
                    }
                }
            }
        }
    }
    var mindImages = getMindImages()
    addImagesToMenu(result, mindImages)
    addTypeToMenu(result)
    return result
}

function getMindImages() {
    return {
    	"MES_ADD_LEFT_ITEM": "mind-left.png",
    	"MES_ADD_RIGHT_ITEM": "mind-right.png",
    	"MES_ADD_ITEM_ABOVE": "mind-up.png",
    	"MES_ADD_ITEM_BELOW": "mind-down.png",
    	"MES_ADD_VER_CHILD": "mind-ver2.png",
    	"MES_ADD_CHILD": "mind-hor.png",
    	"MES_PASTE_LEFT_ITEM": "mind-left.png",
    	"MES_PASTE_RIGHT_ITEM": "mind-right.png",
    	"MES_PASTE_ITEM_ABOVE": "mind-up.png",
    	"MES_PASTE_ITEM_BELOW": "mind-down.png",
    	"MES_PASTE_VER_CHILD": "mind-ver2.png",
    	"MES_PASTE_CHILD": "mind-hor.png"
    }
}

function getMindTypes() {
    var types = []
    types.push({
    	image: "rectangle.png",
    	text: "BUT_RECTANGLE",
    	type: "action"
    })
    types.push({
    	image: "rounded.png",
    	text: "BUT_ROUNDED",
    	type: "raction"
    })
    types.push({
    	image: "collection.png",
    	text: "BUT_COLLECTION",
    	type: "collection"
    })
    types.push({
    	image: "f_begin.png",
    	text: "BUT_FBEGIN",
    	type: "beginend"
    })
    types.push({
    	image: "insertion.png",
    	text: "BUT_INSERTION",
    	type: "insertion"
    })
    return types
}

function getOneSelectedItem(selection) {
    if ((selection) && (selection.ids)) {
        var keys = Object.keys(selection.ids);
        if (keys.length == 1) {
            var key = keys[0];
            if (selection.ids[key] == "green") {
                return key;
            } else {
                return null;
            }
        } else {
            return null;
        }
    } else {
        return null;
    }
}

function getOrCreateUpdate(commands, id) {
    if (id in commands) {
        return commands[id];
    } else {
        var command = new Command(
        	"update",
        	"nodes",
        	id,
        	{ }
        );
        commands[id] = command;
        return command;
    }
}

function getParameters(editor) {
    var graph = editor.storage.graph;
    var node = findNodeByRole(graph, "params");
    return node;
}

function getRidOfMinMax(value, defaultValue) {
    if (value === Number.MAX_VALUE) {
        return defaultValue
    } else {
        if (value === -Number.MAX_VALUE) {
            return defaultValue
        } else {
            return value
        }
    }
}

function getRight(node) {
    return node.x + node.w
}

function getRightNodes(graph, node) {
    var result = [];
    while (true) {
        if (node.right) {
            
        } else {
            break;
        }
        var right = graph.getNodeRightEx(node);
        result.push(right.id);
        node = right;
    }
    return result;
}

function getSelectJoints(graph, selectId) {
    var select = graph.getNode(selectId);
    var id = graph.getNodeDown(select);
    var result = [];
    var node;
    while (true) {
        node = graph.getNode(id);
        result.push(node);
        if (node.right) {
            
        } else {
            break;
        }
        id =graph.getNodeRight(node);
    }
    return result;
}

function getSelectedIds(editor) {
    var ids = {};
    var selection = editor.storage.selection;
    if (selection) {
        ids = selection.ids;
    }
    return ids;
}

function getSelectedItem(editor) {
    var selection = editor.storage.selection;
    return getOneSelectedItem(selection);
}

function getSelection() {
    var ids = getSelectedIds(self)
    return Object.keys(ids)
}

function getSoftExpanders() {
    return {
    	horizontal: softLeft,
    	vertical: softUp
    };
}

function getText(node) {
    if (node.content) {
        return node.content.txt;
    } else {
        return "";
    }
}

function getText2(node) {
    if (node.content) {
        return node.content.txt2;
    } else {
        return "";
    }
}

function getTop(node) {
    return node.y - node.h
}

function getVerticalWidth(graph, itemId) {
    var vertical = graph.getVertical(itemId);
    var _ind16054 = 0;
    var _col16054 = vertical;
    var _len16054 = _col16054.length;
    while (true) {
        if (_ind16054 < _len16054) {
            
        } else {
            return Config.DEF_ICON_WIDTH;
        }
        var id = _col16054[_ind16054];
        var item = graph.getItem(id);
        if (Drakon.isWideIcon(item)) {
            return item.w;
        }
        _ind16054++;
    }
}

function getWidthForMindRoot(itemId, action) {
    if (Mind.mustFitSiblings(action)) {
        var graph = self.storage.graph
        var node = graph.getNode(itemId)
        return node.w
    } else {
        return Config.DEF_ICON_WIDTH
    }
}

function getZoneColor(canvas, zone) {
    var color;
    var colors = canvas.zoneColors;
    if (zone in colors) {
        color = colors[zone];
    } else {
        var r = Math.floor(Math.random() * 205) + 51;
        var g = Math.floor(Math.random() * 205) + 51;
        var b = Math.floor(Math.random() * 205) + 51;
        color = "rgb(" + r + ", " + g + ", " + b + ")";
        colors[zone] = color;
    }
    return color;
}

function glueHole(holes, id) {
    var neighbours = holes[id];
    delete holes[id];
    var up, down;
    if (neighbours.up in holes) {
        var ups = glueHole(holes, neighbours.up);
        up = ups.up;
    } else {
        up = neighbours.up;
    }
    if (neighbours.down in holes) {
        var downs = glueHole(holes, neighbours.down);
        down = downs.down;
    } else {
        down = neighbours.down;
    }
    return {
    	up: up,
    	down: down,
    	dir: neighbours.dir
    };
}

function glueHoles(plan, holes) {
    var ids = Object.keys(holes);
    var visited = {};
    var _ind5850 = 0;
    var _col5850 = ids;
    var _len5850 = _col5850.length;
    while (true) {
        if (_ind5850 < _len5850) {
            
        } else {
            break;
        }
        var id = _col5850[_ind5850];
        if (id in holes) {
            var holeInfo = glueHole(
            	holes,
            	id
            );
            visited[id] = holeInfo;
        }
        _ind5850++;
    }
    var _ind7892 = 0;
    var _col7892 = visited;
    var _keys7892 = Object.keys(_col7892); 
    var _len7892 = _keys7892.length;
    while (true) {
        if (_ind7892 < _len7892) {
            
        } else {
            break;
        }
        var id = _keys7892[_ind7892]; var info = _col7892[id];
        plan.newEdges[id] = info;
        _ind7892++;
    }
}

function goDownToEnd(graph, id) {
    var node = graph.getNode(id);
    while (true) {
        if (node.down) {
            
        } else {
            break;
        }
        id = graph.getNodeDown(node);
        node = graph.getNode(id);
    }
    return node;
}

function goLeftToEnd(graph, id) {
    var node = graph.getNode(id);
    while (true) {
        if (node.left) {
            
        } else {
            break;
        }
        id = graph.getNodeLeft(node);
        node = graph.getNode(id);
    }
    return node;
}

function goRightToEnd(graph, id) {
    var node = graph.getNode(id);
    while (true) {
        if (node.right) {
            
        } else {
            break;
        }
        id =graph.getNodeRight(node);
        node = graph.getNode(id);
    }
    return node;
}

function goUpToEnd(graph, id) {
    var node = graph.getNode(id);
    while (true) {
        if (node.up) {
            
        } else {
            break;
        }
        id = graph.getNodeUp(node);
        node = graph.getNode(id);
    }
    return node;
}

function goodForPeriod(node) {
    var _sw149860000_ = 0;
    _sw149860000_ = node.type;
    if ((((((((((_sw149860000_ === "action") || (_sw149860000_ === "select")) || (_sw149860000_ === "question")) || (_sw149860000_ === "shelf")) || (_sw149860000_ === "input")) || (_sw149860000_ === "output")) || (_sw149860000_ === "sinput")) || (_sw149860000_ === "soutput")) || (_sw149860000_ === "insertion")) && (!(node.left))) {
        return true;
    } else {
        return false;
    }
}

function grabBack(graph, edgeId) {
    var edge = graph.getEdge(edgeId);
    var node = graph.getNode(edge.head);
    return {
    	edge: edge,
    	node: node
    };
}

function grabForward(graph, edgeId) {
    var edge = graph.getEdge(edgeId);
    var node = graph.getNode(edge.tail);
    return {
    	edge: edge,
    	node: node
    };
}

function hardDown(pgraph, skewer) {
    var graph = pgraph.graph;
    if (skewer) {
        var result = new Utils.Set();
        var _ind14898 = 0;
        var _col14898 = skewer.list;
        var _len14898 = _col14898.length;
        while (true) {
            if (_ind14898 < _len14898) {
                
            } else {
                break;
            }
            var itemId = _col14898[_ind14898];
            result.add(itemId);
            var item = graph.getItem(itemId);
            if (isCross(item)) {
                var head = graph.getNodeUpEx(item);
                result.add(head.id);
                if (head.right) {
                    var par = graph.getNodeRightEx(head);
                    result.add(head.right);
                    result.add(par.id);
                }
            }
            _ind14898++;
        }
        return result;
    } else {
        return null;
    }
}

function hardDownMind(pgraph, skewer) {
    var graph = pgraph.graph;
    if (skewer) {
        var result = new Utils.Set();
        var sub = false
        pullDownSkewerItem(graph, skewer.list, result)
        addAllSubs(graph, skewer, result)
        return result;
    } else {
        return null;
    }
}

function hardLeft(pgraph, skewer) {
    if (skewer) {
        var result = new Utils.Set();
        hardLeftCore(pgraph, skewer.list, result);
        return result;
    } else {
        return null;
    }
}

function hardLeftCore(pgraph, ids, result) {
    var graph = pgraph.graph;
    var _ind14947 = 0;
    var _col14947 = ids;
    var _len14947 = _col14947.length;
    while (true) {
        if (_ind14947 < _len14947) {
            
        } else {
            break;
        }
        var itemId = _col14947[_ind14947];
        result.add(itemId);
        var item = graph.getItem(itemId);
        if (((((item.isLine) || (!(item.right))) || (!(item.down))) || (item.left)) || (!((item.up) || (item.type == "beginend")))) {
            
        } else {
            var right = getRightNodes(graph, item);
            var _ind14967 = 0;
            var _col14967 = right;
            var _len14967 = _col14967.length;
            while (true) {
                if (_ind14967 < _len14967) {
                    
                } else {
                    break;
                }
                var rightId = _col14967[_ind14967];
                if (rightId in result.map) {
                    
                } else {
                    var vertical = pgraph.getTeam(
                    	rightId,
                    	"horizontal"
                    );
                    hardLeftCore(
                    	pgraph,
                    	vertical.list,
                    	result
                    );
                }
                _ind14967++;
            }
        }
        _ind14947++;
    }
}

function hardLeftMind(pgraph, skewer) {
    return skewer;
}

function hardRight(pgraph, skewer) {
    var graph = pgraph.graph;
    if (skewer) {
        var result = new Utils.Set();
        var _ind14930 = 0;
        var _col14930 = skewer.list;
        var _len14930 = _col14930.length;
        while (true) {
            if (_ind14930 < _len14930) {
                
            } else {
                break;
            }
            var itemId = _col14930[_ind14930];
            result.add(itemId);
            var item = graph.getItem(itemId);
            if (isCross(item)) {
                var leftUp = graph.getNodeLeftEx(item);
                var leftDown = graph.getNodeDownEx(leftUp);
                result.add(leftUp.id);
                result.add(leftDown.id);
                result.add(leftUp.down);
            }
            _ind14930++;
        }
        return result;
    } else {
        return null;
    }
}

function hardRightMind(pgraph, skewer) {
    return skewer;
}

function hardUp(pgraph, skewer) {
    return skewer;
}

function hardUpMind(pgraph, skewer) {
    var graph = pgraph.graph;
    if (skewer) {
        var result = new Utils.Set();
        var sub = false
        var _ind20946 = 0;
        var _col20946 = skewer.list;
        var _len20946 = _col20946.length;
        while (true) {
            if (_ind20946 < _len20946) {
                
            } else {
                break;
            }
            var itemId = _col20946[_ind20946];
            result.add(itemId);
            var item = graph.getItem(itemId);
            if ((item.type == "junction") && (item.down)) {
                var below = graph.getNodeDownEx(item)
                if (below.role == "sub") {
                    result.add(below.id)
                }
            }
            _ind20946++;
        }
        addAllSubs(graph, skewer, result)
        return result;
    } else {
        return null;
    }
}

function hasDoubleEntry(graph, split, edgeId) {
    var edge = graph.getEdge(edgeId);
    var target = graph.getTail(edge);
    var node = split;
    while (true) {
        if (hasLeft(graph, node)) {
            node = leftToEndNoDuration(graph, node.id)
        } else {
            if (node.id == target.id) {
                return false;
            }
            if (node.x < target.x) {
                return true;
            }
            var id = graph.getNodeUp(node);
            node = graph.getNode(id);
        }
    }
}

function hasDrakon() {
    var graph = self.storage.graph;
    var count = Utils.count(graph.items)
    return count > 0
}

function hasItemsBelow(graph, edge) {
    var tail = graph.getTail(edge);
    if (tail.type === "junction") {
        var desc = describeJunction(tail);
        if (desc === "right-t") {
            return true;
        } else {
            if (desc === "left-t") {
                var leftEdge = graph.getEdge(tail.left);
                var leftNode = graph.getHead(leftEdge);
                if (leftNode.type === "junction") {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
    } else {
        return true;
    }
}

function hasLeft(graph, node) {
    if ((node.left) && (!(Drakon.getDuration(graph, node)))) {
        return true;
    } else {
        return false;
    }
}

function hasNodesOnRight(graph, nodeId, plan) {
    var id = nodeId;
    var node;
    while (true) {
        node = graph.getNode(id);
        if (id in plan.nodes) {
            
        } else {
            return true;
        }
        if (node.right) {
            
        } else {
            return false;
        }
        id =graph.getNodeRight(node);
    }
}

function hasPipe(graph, left, top, right, bottom) {
    var x = left;
    while (true) {
        if (x < right) {
            
        } else {
            return false;
        }
        var box = new Utils.Box(
        	x,
        	top,
        	x + Config.METRE + 1,
        	bottom
        );
        if (hitsAnyone(graph, box)) {
            
        } else {
            return true;
        }
        x += Config.SNAP;
    }
}

function hasUpTs(graph, edge) {
    var head = graph.getNode(edge.head)
    var tail = graph.getNode(edge.tail)
    if ((isUpT(head)) || (isUpT(tail))) {
        return true
    } else {
        return false
    }
}

function hasUpperText(item) {
    var _sw159810000_ = 0;
    _sw159810000_ = item.type;
    if ((((_sw159810000_ === "shelf") || (_sw159810000_ === "input")) || (_sw159810000_ === "output")) || (_sw159810000_ === "process")) {
        return true;
    } else {
        return false;
    }
}

function hasValue(data) {
    if ((typeof data == "number") || (data)) {
        return true
    } else {
        return false
    }
}

function hasVerticalChildren(graph, node) {
    if (node.left) {
        var leftEdge = graph.getEdge(node.left)
        if ((leftEdge.role == "link") || (node.role == "header")) {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function headerSize(size) {
    return Config.HEADER_SIZE
}

function hit(pos) {
    var socket = self.findSocket(pos.x, pos.y);
    if (socket) {
        return true;
    } else {
        var item = self.findVisualItem(pos.x, pos.y);
        if (item) {
            return true;
        } else {
            return false;
        }
    }
}

function hitFreeItem(item, x, y) {
    var callback = Items.getItemCallback(item.type)
    if (callback.hit) {
        return callback.hit(item, x, y)
    } else {
        var box = Utils.boxFromPoint(
        	item.x,
        	item.y,
        	item.w,
        	item.h
        )
        return Utils.hitBox(box, x, y)
    }
}

function hitText(item, x, y) {
    var box = Utils.boxFromPoint(
    	item.x,
    	item.y,
    	item.w - Config.ICON_PADDING * 2,
    	item.h - Config.ICON_PADDING
    )
    return Utils.hitBox(box, x, y)
}

function hitsAnyone(graph, box) {
    var _ind4254 = 0;
    var _col4254 = graph.items;
    var _keys4254 = Object.keys(_col4254); 
    var _len4254 = _keys4254.length;
    while (true) {
        if (_ind4254 < _len4254) {
            
        } else {
            return null;
        }
        var iid = _keys4254[_ind4254]; var item = _col4254[iid];
        if (Utils.boxesIntersect(box, item.box)) {
            return item.id;
        }
        _ind4254++;
    }
}

function ignoreCommand() {
    if ((self.readonly) || (self.dragOn)) {
        return true
    } else {
        return false
    }
}

function insertAndEdit(editor, edgeId, type) {
    if (canAddMore(editor, 2)) {
        var id = insertItem(editor, edgeId, type, "");
        if (id) {
            selectItem(editor, id);
            editor.redraw();
            //startEditText(id);
        }
    }
}

function insertBranch(editor, nodeId, cont, addEnd) {
    addTrace(
    	"insert branch",
    	[nodeId, Utils.copyObject(cont)]
    );
    var pgraph = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    );
    var graph = pgraph.graph;
    var sGraph = editor.storage.graph;
    var movedNodes = {};
    var commands = {};
    var branch = graph.getNode(nodeId);
    var above = graph.getNodeUpEx(branch);
    var myRightAddress, lastAbove, lastBelow
    var rightCont
    if (above.right) {
        var rightAbove = graph.getNodeRightEx(above);
        var right = graph.getNodeDownEx(rightAbove);
        var rightBottom = goDownToEnd(graph, right.id);
        var rightType = sGraph.getNode(rightBottom.id).type;
        rightCont = getContent(sGraph.getNode(right.id))
        lastAbove = false
        if (rightBottom.type == "end") {
            lastBelow = true
            var bottom = goDownToEnd(graph, nodeId);
            myRightAddress = goRightToEnd(graph, bottom.id);
        } else {
            lastBelow = false
            myRightAddress = graph.getNodeLeftEx(rightBottom);
        }
    } else {
        rightCont = Utils.copyObject(cont)
        lastAbove = true
        lastBelow = true
        var bottom = goDownToEnd(graph, nodeId);
        myRightAddress = goRightToEnd(graph, bottom.id);
    }
    rightCont = makeCont(rightCont.txt)
    var en = makeDummyItem(
    	1,
    	render,
    	"end",
    	makeCont(getEnd())
    );
    var bra = makeDummyItem(
    	1,
    	editor.render,
    	"branch",
    	cont
    );
    var add = makeDummyItem(
    	1,
    	editor.render,
    	"address",
    	rightCont
    );
    var width = bra.w;
    var oldAdd = graph.getNodeUpEx(
    	myRightAddress
    );
    var dims = findLedgeDimensions(
    	graph,
    	nodeId,
    	oldAdd.id
    );
    var oldBottom = myRightAddress.box.top - Config.METRE;
    if (oldBottom < dims.y) {
        var yDelta = dims.y - oldBottom;
        var bottom = myRightAddress.y + yDelta;
        dropDownCore(
        	pgraph,
        	myRightAddress,
        	bottom,
        	oldAdd.box.right + Config.METRE,
        	movedNodes
        );
    }
    dims = findLedgeDimensions(
    	graph,
    	nodeId,
    	oldAdd.id
    );
    var dimX = Math.max(dims.x, oldAdd.box.right + Config.METRE)
    if (lastAbove) {
        
    } else {
        var branchLeft = findBranchLeft(graph, right)
        var minRight = branchLeft - Config.METRE 
         - width * 2
        if (dimX > minRight) {
            var delta = dimX - minRight;
            pgraph.moveRight(
            	right.id,
            	delta,
            	movedNodes
            );
        }
    }
    var braY = above.y + Config.METRE + bra.h;
    var addY = myRightAddress.y - Config.METRE - add.h;
    var x = dimX + width;
    var id = generateId(editor.storage);
    var topJunId = generateId(editor.storage);
    var botJunId = generateId(editor.storage);
    var addId = generateId(editor.storage);
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    if (lastAbove) {
        
    } else {
        pushDeleteEdge(
        	commandList,
        	above.right
        );
    }
    if (lastBelow) {
        
    } else {
        pushDeleteEdge(
        	commandList,
        	myRightAddress.right
        );
    }
    pushInsertJunction(
    	commandList,
    	topJunId,
    	x, above.y
    );
    pushInsertNodeAt(
    	render,
    	commandList,
    	id,
    	"branch",
    	x, braY,
    	width, bra.h,
    	cont
    );
    connectVer(
    	editor,
    	commandList,
    	topJunId, id,
    	null
    );
    connectHor(
    	editor,
    	commandList,
    	above.id, topJunId,
    	null
    );
    if (addEnd) {
        var enY = braY + bra.h * 2 + en.h
        pushInsertNodeAt(
        	render,
        	commandList,
        	addId,
        	"end",
        	x, enY,
        	en.w, en.h,
        	makeCont(getEnd())
        );
        connectVer(
        	editor,
        	commandList,
        	id, addId,
        	"down"
        );
    } else {
        pushInsertNodeAt(
        	render,
        	commandList,
        	addId,
        	"address",
        	x, addY,
        	width, add.h,
        	rightCont
        );
        pushInsertJunction(
        	commandList,
        	botJunId,
        	x, myRightAddress.y
        );
        connectVer(
        	editor,
        	commandList,
        	id, addId,
        	"down"
        );
        connectVer(
        	editor,
        	commandList,
        	addId, botJunId,
        	null
        );
        connectHor(
        	editor,
        	commandList,
        	myRightAddress.id, botJunId,
        	"sil_floor"
        );
        if (lastAbove) {
            
        } else {
            connectHor(
            	editor,
            	commandList,
            	topJunId, rightAbove.id,
            	null
            );
        }
        if (lastBelow) {
            
        } else {
            connectHor(
            	editor,
            	commandList,
            	botJunId, rightBottom.id,
            	"sil_floor"
            );
        }
    }
    applyCommands(
    	editor,
    	commandList,
    	id
    );
    return id;
}

function insertCanvasItem(canvas, itemData, skewers) {
    var render = canvas.render
    var graph = canvas.graph
    var free = canvas.free
    var item = copyStorageItem(itemData)
    if ((item.type == "vertical") && (item.id in skewers)) {
        item.isSkewer = true
    }
    if (item.free) {
        free.add(item.id, item)
    } else {
        graph.addItem(item)
        canvas.pgraph.insertPhysicalItem(
        	item
        )
    }
    Items.renderItem(graph, render, item, {})
}

function insertCanvasSocket(canvas, socketInfo) {
    var socket = makeAndDrawSocket(
    	canvas.render,
    	canvas.graph,
    	socketInfo.id,
    	socketInfo.type,
    	socketInfo.action
    );
    socket.name = socketInfo.name;
    canvas.sockets[socket.prim] = socket;
}

function insertCase(editor, nodeId, cont) {
    addTrace(
    	"insert case",
    	[nodeId, Utils.copyObject(cont)]
    );
    var id = generateId(editor.storage);
    var pgraph = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    );
    var graph = pgraph.graph;
    var movedNodes = {};
    var commands = {};
    var cas = makeDummyItem(
    	id,
    	editor.render,
    	"case",
    	cont
    );
    var old = graph.getNode(nodeId);
    var oldJunId = graph.getNodeUp(old);
    var oldJun = graph.getNode(oldJunId);
    var bottom = oldJun.y + (cas.h + Config.METRE) * 2;
    var right = old.box.right + cas.w + Config.METRE;
    var delta = right - old.x + cas.w;
    var belowId = graph.getNodeDown(old);
    bottom = Math.max(
    	bottom,
    	old.y + old.h + Config.METRE
    )
    var box;
    var neighbour;
    if (oldJun.right) {
        box = new Utils.Box(
        	old.x,
        	old.box.top,
        	old.x,
        	bottom
        );
        neighbour =graph.getNodeRight(oldJun);
    } else {
        box = new Utils.Box(
        	old.x,
        	oldJun.y,
        	old.x,
        	bottom
        );
        neighbour = null;
    }
    var directionProps = "horizontal";
    var myY = oldJun.y + Config.METRE + cas.h;
    extendEdge(
    	pgraph,
    	old.down,
    	Config.METRE + cas.h,
    	movedNodes
    );
    pgraph.pushObjects(
        box,
        {},
        delta,
        directionProps,
        movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	old.down
    );
    if (oldJun.right) {
        pushDeleteEdge(
        	commandList,
        	oldJun.right
        );
    }
    cas.x = right;
    cas.y = myY;
    pushInsertNode(
    	commandList,
    	id,
    	cas
    );
    var leftJun = insertJunctionBetween(
    	editor,
    	graph,
    	old.id,
    	belowId,
    	bottom,
    	commandList
    );
    var corner = generateId(editor.storage);
    var upId = generateId(editor.storage);
    pushInsertJunction(
    	commandList,
    	corner,
    	right,
    	bottom, null
    );
    pushInsertJunction(
    	commandList,
    	upId,
    	right,
    	oldJun.y, oldJun.group
    );
    connectVer(
    	editor,
    	commandList,
    	id,
    	corner,
    	"down",
    	null
    );
    connectHor(
    	editor,
    	commandList,
    	leftJun,
    	corner,
    	"left",
    	null
    );
    connectHor(
    	editor,
    	commandList,
    	oldJunId,
    	upId,
    	null,
    	null
    );
    connectVer(
    	editor,
    	commandList,
    	upId,
    	id,
    	null,
    	null
    );
    if (oldJun.right) {
        connectHor(
        	editor,
        	commandList,
        	upId,
        	neighbour,
        	null,
        	null
        );
    }
    applyCommands(
    	editor,
    	commandList,
    	id
    )
    return id;
}

function insertDuration(editor, itemId, cont) {
    addTrace(
    	"insert duration",
    	[itemId, Utils.copyObject(cont)]
    );
    var graph = editor.storage.graph;
    var render = editor.render;
    var pgraph = createPhysicalGraph(graph, render);
    var item = makeDummyItem(1, render, "duration", cont);
    var root = graph.getNode(itemId);
    var dx = root.w + item.w + Config.METRE;
    var x = root.x - dx;
    var left = x - item.w;
    var commands = {};
    var movedNodes = {};
    var leftBox = new Utils.Box(
    	root.x,
    	root.y,
    	root.x,
    	root.y
    );
    var leftDelta = -dx - item.w;
    pgraph.pushObjects(
        leftBox,
        {},
        leftDelta,
        "horizontal",
        movedNodes
    );
    var upDownBox = new Utils.Box(
    	x - item.w,
    	root.y,
    	x + item.w,
    	root.y
    );
    pgraph.pushObjects(
        upDownBox,
        {},
        item.h,
        "vertical",
        movedNodes
    );
    pgraph.pushObjects(
        upDownBox,
        {},
        -item.h,
        "vertical",
        movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commList = Utils.objectValues(commands);
    var id = generateId(editor.storage);
    item.x = x;
    item.y = root.y;
    pushInsertNode(
    	commList,
    	id,
    	item
    );
    connectHor(
    	editor,
    	commList,
    	id,
    	itemId,
    	"lstick",
    	null
    );
    applyCommands(
    	editor,
    	commList,
    	id
    );
    return id;
}

function insertForeach(editor, edgeId, cont) {
    var subgraph = buildMacroLoop(
    	editor.render,
    	cont,
    	makeCont("")
    );
    var id = insertSubgraph(editor, edgeId, subgraph, "insert 'for each'");
    return id;
}

function insertFreeItem(x, y, type, subtype) {
    if (ignoreCommand()) {
        
    } else {
        var x = Utils.snapPos(x)
        var y = Utils.snapPos(y)
        var actionName = "Insert free item: \""
         + type + "\""
        addTrace(
        	actionName,
        	[{x:x, y:y, type:type}]
        );
        var editor = self
        var free = editor.storage.free
        var length = free.list.length
        var render  = editor.render
        var id = generateId(editor.storage)
        var commList = []
        var content = makeCont("")
        var builder = gFreeBuilders[type]
        if (builder) {
            builder(
            	render,
            	content,
            	id,
            	x,
            	y,
            	commList,
            	subtype
            )
        } else {
            defaultBuilder(
            	render,
            	content,
            	id,
            	type,
            	x,
            	y,
            	commList
            );
        }
        if (length == 0) {
            
        } else {
            var prevId = free.list[length - 1]
            pushUpdate(
            	commList,
            	"free",
            	prevId,
            	{ next: id }
            )
        }
        applyCommands(
        	editor,
        	commList,
        	id
        );
    }
}

function insertInSocket(editor, prim) {
    var socket = prepareSocketOp(editor, prim);
    var graph = editor.storage.graph;
    var target = graph.getItem(socket.id);
    if (downRole(target)) {
        insertAndEdit(editor, socket.id, socket.action);
    } else {
        if (target.isLine) {
            if (target.isVertical) {
                var below = graph.getNode(target.tail);
                insertAndEdit(editor, below.id, socket.action);
            } else {
                var branch = getBranchForEdge(graph, target);
                if (branch) {
                    insertAndEdit(editor, branch.id, socket.action);
                } else {
                    insertAndEdit(editor, socket.id, socket.action);
                }
            }
        } else {
            insertAndEdit(editor, socket.id, socket.action);
        }
    }
}

function insertItem(editor, edgeId, type, text) {
    var cont = makeCont(text);
    if (type === "question") {
        return insertQuestion(
        	editor,
        	edgeId,
        	cont
        );
    } else {
        if (type === "select") {
            return insertSelect(
            	editor,
            	edgeId,
            	cont
            );
        } else {
            if (type === "case") {
                return insertCase(
                	editor,
                	edgeId,
                	cont
                );
            } else {
                if (type === "branch") {
                    return insertBranch(
                    	editor,
                    	edgeId,
                    	cont,
                    	false
                    );
                } else {
                    if (type === "end_branch") {
                        return insertBranch(
                        	editor,
                        	edgeId,
                        	cont,
                        	true
                        );
                    } else {
                        if (type === "foreach") {
                            return insertForeach(
                            	editor,
                            	edgeId,
                            	cont
                            );
                        } else {
                            if (type === "params") {
                                return insertParams(
                                	editor
                                );
                            } else {
                                if (type === "duration") {
                                    return insertDuration(
                                    	editor,
                                    	edgeId,
                                    	cont
                                    );
                                } else {
                                    if (type === "parallel") {
                                        return insertParallel(
                                        	editor,
                                        	edgeId
                                        );
                                    } else {
                                        if (type === "path") {
                                            return insertPath(
                                            	editor,
                                            	edgeId
                                            );
                                        } else {
                                            return insertSimpleItem(
                                            	editor,
                                            	edgeId,
                                            	type,
                                            	cont
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function insertJunctionBetween(editor, graph, up, down, y, commandList) {
    var upNode = graph.getNode(up);
    var x = upNode.x;
    var upEdge = generateId(editor.storage);
    var downEdge = generateId(editor.storage);
    var id = generateId(editor.storage);
    pushInsertJunction(
    	commandList,
    	id,
    	x,
    	y
    );
    pushInsertDown(
    	commandList,
    	upEdge,
    	up,
    	id
    );
    if (down) {
        var role = "down";
        var downNode = graph.getNode(down);
        if (downNode.up) {
            var edge = graph.getEdge(downNode.up);
            role = edge.role;
        }
        pushInsertVertical(
        	commandList,
        	downEdge,
        	id,
        	down,
        	role
        );
    }
    return id;
}

function insertParallel(editor, edgeId) {
    var subgraph = buildMacroParallel(
    	editor.render
    );
    insertSubgraph(editor, edgeId, subgraph, "insert 'parallel'");
    return null;
}

function insertParams(editor) {
    addTrace(
    	"insert parameters",
    	[]
    );
    var graph = editor.storage.graph;
    var render = editor.render;
    var movedNodes = {};
    var commands = {};
    var pgraph = createPhysicalGraph(graph, render);
    var ibox = makeIconBoxForType(
    	render,
    	"action",
    	null,
    	Config.DEF_ICON_WIDTH_S
    );
    var headerS = findNodeByRole(graph, "header");
    var header = pgraph.graph.getNode(headerS.id);
    var directionProps = "horizontal";
    var fakeSkewer = {};
    fakeSkewer[header.id] = true;
    var w = headerS.w;
    var delta = ibox.size.w + Config.METRE * 2 + w;
    pgraph.pushObjects(
        header.box,
        fakeSkewer,
        delta,
        directionProps,
        movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commList = Utils.objectValues(commands);
    var id = generateId(editor.storage);
    commList.push(new Command(
    	"insert",
    	"nodes",
    	id,
    	{
    		type: "action",
    		x: header.x + delta,
    		y: header.y,
    		w: ibox.size.w,
    		h: ibox.size.h,
    		content: null,
    		role: "params"
    	}
    ));
    connectHor(
    	editor,
    	commList,
    	header.id,
    	id,
    	null,
    	null
    );
    applyCommands(
    	editor,
    	commList,
    	id
    )
    return id;
}

function insertPath(editor, itemId) {
    if (canAddMore(editor, 5)) {
        var graph = editor.storage.graph;
        var item = graph.getItem(itemId);
        if (item.isLine) {
            insertPathInside(editor, itemId);
        } else {
            insertPathOutside(editor, itemId);
        }
    }
    return null;
}

function insertPathInside(editor, edgeId) {
    addTrace(
    	"add inside path",
    	[edgeId]
    );
    var pgraph = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    );
    var movedNodes = {};
    var commands = {};
    var graph = pgraph.graph;
    var edge = graph.getEdge(edgeId);
    var left = graph.getNode(edge.head);
    var right = graph.getNode(edge.tail);
    var rightDown = goDownToEnd(graph, right.id);
    var bottom = rightDown.y;
    if (right.x - left.x < Config.METRE * 3) {
        pgraph.moveRight(
        	right.id,
        	Config.METRE * 4,
        	movedNodes
        );
    }
    var x = right.x - Config.METRE;
    drill(
    	pgraph,
    	x,
    	right.y,
    	bottom,
    	movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    var leftDownId = graph.getNodeLeft(rightDown);
    pushDeleteEdge(
    	commandList,
    	edgeId
    );
    pushDeleteEdge(
    	commandList,
    	rightDown.left
    );
    var upId = generateId(editor.storage);
    var downId = generateId(editor.storage);
    pushInsertJunction(
    	commandList,
    	upId,
    	x,
    	right.y
    );
    pushInsertJunction(
    	commandList,
    	downId,
    	x,
    	rightDown.y
    );
    connectHor(
    	editor,
    	commandList,
    	left.id, upId,
    	"parallel", null
    );
    connectHor(
    	editor,
    	commandList,
    	upId, right.id,
    	"parallel", null
    );
    connectHor(
    	editor,
    	commandList,
    	leftDownId, downId,
    	null, null
    );
    connectHor(
    	editor,
    	commandList,
    	downId, rightDown.id,
    	null, null
    );
    connectVer(
    	editor,
    	commandList,
    	upId, downId,
    	"par-down", null
    );
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function insertPathOutside(editor, nodeId) {
    addTrace(
    	"add outside path",
    	[nodeId]
    );
    var pgraph = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    );
    var movedNodes = {};
    var commands = {};
    var graph = pgraph.graph;
    var up = graph.getNode(nodeId);
    var down = goDownToEnd(graph, nodeId);
    var dims = findLedgeDimensions(
    	graph,
    	up.id,
    	down.id
    );
    var x = up.x;
    var x2 = dims.x;
    var yUp = up.y;
    clearPathForSquare(
    	pgraph,
    	x,
    	x2,
    	yUp,
    	dims,
    	down,
    	movedNodes
    );
    if (dims.y > down.y) {
        var yDelta = dims.y - down.y;
        pgraph.moveDown(
        	down.id,
        	yDelta,
        	movedNodes
        );
    }
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    var upId = generateId(editor.storage);
    var downId = generateId(editor.storage);
    pushInsertJunction(
    	commandList,
    	upId,
    	x2,
    	up.y
    );
    pushInsertJunction(
    	commandList,
    	downId,
    	x2,
    	down.y
    );
    connectVer(
    	editor,
    	commandList,
    	upId, downId,
    	"par-down", null
    );
    connectHor(
    	editor,
    	commandList,
    	up.id, upId,
    	"parallel", null
    );
    connectHor(
    	editor,
    	commandList,
    	down.id, downId,
    	null, null
    );
    applyCommands(
    	editor,
    	commandList,
    	null
    );
}

function insertQuestion(editor, edgeId, cont) {
    var subgraph = buildMacroQuestion(
    	editor.render,
    	cont,
    	1
    );
    var id = insertSubgraph(editor, edgeId, subgraph, "insert 'question'");
    return id;
}

function insertSelect(editor, edgeId, cont) {
    var c1 = makeCont("Case 1");
    var c2 = makeCont("Case 2");
    var c3 = makeCont("Case 3");
    var subgraph = buildMacroSelect(
    	editor.render,
    	cont,
    	[c1, c2, c3]
    );
    var id = insertSubgraph(editor, edgeId, subgraph, "insert 'select'");
    return id;
}

function insertSimpleItem(editor, edgeId, type, cont) {
    var subgraph = buildMacroSimple(
    	editor.render,
    	type,
    	cont
    );
    var id = insertSubgraph(editor, edgeId, subgraph, "insert item");
    return id;
}

function insertSubgraph(editor, edgeId, subgraph, actionName) {
    var graph = editor.storage.graph
    var edge = graph.getEdge(edgeId)
    var before = copyState(editor);
    var after = copyState(editor);
    after.selection = createSelection()
    var commandList1 = []
    if (edge.isVertical) {
        
    } else {
        var pgraph = createPhysicalGraph(
        	editor.storage.graph,
        	editor.render
        );
        commandList1 = expandBoltCore(editor, pgraph, edgeId)
        addTrace(
        	actionName + "-expand-bolt",
        	[edgeId]
        )
        edgeId = findInsertedEdge(commandList1);
        commandList1 = makeUndoAndExecute(
        	editor,
        	commandList1,
        	after,
        	false
        )
    }
    addTrace(
    	actionName,
    	[edgeId]
    );
    var subResult = insertSubgraphOnVertical(
    	editor,
    	edgeId,
    	subgraph
    )
    var commandList2 = makeUndoAndExecute(
    	editor,
    	subResult.commandList,
    	after,
    	true
    )
    concatAndSaveUndo(
    	editor,
    	commandList1,
    	commandList2,
    	before,
    	after
    )
    return subResult.toSelect
}

function insertSubgraphOnVertical(editor, edgeId, subgraph) {
    var graph = editor.storage.graph;
    var render = editor.render;
    var subpgraph = createPhysicalGraph(
    	subgraph.graph,
    	render
    );
    subgraph.pgraph = subpgraph;
    var width = getVerticalWidth(graph, edgeId);
    var subCommands = {};
    Drakon.setSkewerWidth(
    	render,
    	subpgraph,
    	subgraph.first,
    	width,
    	subCommands
    );
    bakeCommands(subgraph.graph, subCommands);
    var subp2 = createPhysicalGraph(
    	subgraph.graph,
    	render
    );
    var box = findDiagramBox(subp2.graph);
    box.left += Config.METRE;
    box.top += Config.METRE;
    box.right -= Config.METRE;
    box.bottom -= Config.METRE;
    var edge = graph.getEdge(edgeId);
    var commands = {};
    var pgraph = createPhysicalGraph(
    	graph,
    	render
    );
    var insertion = makeFreeSpace(
    	editor,
    	pgraph,
    	edge.head,
    	edge.tail,
    	box,
    	commands
    );
    var commList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commList,
    	edgeId
    );
    var subNode = subgraph.graph.getNode(
    	subgraph.first
    );
    var upNode = pgraph.graph.getNode(edge.head);
    var insX = upNode.x;
    var insY = upNode.box.bottom + Config.METRE -
    	subNode.y;
    moveSubgraph(subgraph, insX, insY);
    var newIds = addBlockItems(
    	editor,
    	subgraph,
    	commList
    );
    var idUp = generateId(editor.storage);
    var idDown = generateId(editor.storage);
    pushInsertDown(
    	commList,
    	idUp,
    	edge.head,
    	newIds.first
    );
    pushInsertVertical(
    	commList,
    	idDown,
    	newIds.last,
    	edge.tail,
    	edge.role
    );
    return {
    	commandList: commList,
    	toSelect: newIds.first
    }
}

function isAboveLastCase(graph, edge) {
    var above = graph.getNode(edge.head);
    if (above.type == "junction") {
        var jtype = describeJunction(above);
        if (jtype == "left-down") {
            var below = graph.getNode(edge.tail);
            if (below.type == "case") {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function isArrowStart(graph, node) {
    var jun = describeJunction(node);
    if (jun === "left-up") {
        var upEdge = graph.getEdge(node.up);
        if (upEdge.role) {
            return false;
        } else {
            var leftEdge = graph.getEdge(node.left);
            if (leftEdge.role === "sil_floor") {
                return false;
            } else {
                return true;
            }
        }
    } else {
        return false;
    }
}

function isBetweenTs(graph, item) {
    if (((item.isLine) && (!(item.isVertical))) && (item.role == "left")) {
        var right = graph.getTail(item)
        var left = graph.getHead(item)
        var rightT = describeJunction(right)
        var leftT = describeJunction(left)
        if ((leftT == "up-t") && (rightT == "up-t")) {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function isBetweenTs2(graph, item) {
    if ((item.isLine) && (!(item.isVertical))) {
        var right = graph.getTail(item)
        var left = graph.getHead(item)
        var rightT = describeJunction(right)
        var leftT = describeJunction(left)
        if ((leftT == "right-t") && (rightT == "up-t")) {
            var below = graph.getNodeDownEx(left)
            if (below.type == "junction") {
                var belowT = describeJunction(below)
                if (belowT == "left-up") {
                    var edgeUp = graph.getEdge(left.up)
                    if (edgeUp.role == "par-down") {
                        return false
                    } else {
                        return true
                    }
                } else {
                    return false
                }
            } else {
                return false
            }
        } else {
            return false
        }
    } else {
        return false
    }
}

function isBolt(graph, edge) {
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    if ((downRole(edge)) && (head.type === "junction")) {
        var headType = describeJunction(head);
        if ((headType === "left-down") && (tail.type === "junction")) {
            var tailType = describeJunction(tail);
            if (tailType === "right-up") {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function isCross(item) {
    if (((((item.type == "junction") && (item.left)) && (item.up)) && (item.down)) && (item.right)) {
        return true;
    } else {
        return false;
    }
}

function isCycleStart(graph, node) {
    if (node.right) {
        var rightEdge = graph.getEdge(node.right);
        if (rightEdge.role === "arrow") {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function isDegenerateExit(node) {
    var type = describeJunction(node);
    if ((type === "left-t") || (type === "left-up")) {
        return true;
    } else {
        return false;
    }
}

function isDownLeft(node) {
    if (node.type == "junction") {
        var type = describeJunction(node)
        if (type == "left-down") {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function isDrakon() {
    return self.storage.type == "drakon"
}

function isEdgeOnMainSkewer(graph, edge) {
    var head = graph.getHead(edge);
    return isNodeOnMainSkewer(graph, head);
}

function isEmpty(map) {
    if (map) {
        var keys = Object.keys(map)
        if (keys.length == 0) {
            return true
        } else {
            return false
        }
    } else {
        return true
    }
}

function isEndBranch(graph, item) {
    var bottom = goDownToEnd(graph, item.id)
    if (bottom.type == "end") {
        return true;
    } else {
        return false;
    }
}

function isFree(graph) {
    var nodeIds = Object.keys(graph.nodes)
    return nodeIds.length == 0
}

function isFromTJoint(graph, edge) {
    var tail = graph.getTail(edge);
    if (tail.type === "junction") {
        var type = describeJunction(tail);
        if (type === "left-t") {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function isInCycleBody(graph, edgeId) {
    var _sw92340000_ = 0;
    var edge = graph.getEdge(edgeId);
    var node = graph.getHead(edge);
    while (true) {
        if ((isCycleStart(graph, node)) && (belongsToCycle(graph, node, edgeId))) {
            return true;
        }
        if (node.up) {
            
        } else {
            var count = 0;
            node = graph.getHead(edge);
            while (true) {
                _sw92340000_ = node.type;
                if (_sw92340000_ === "loopbegin") {
                    count--;
                } else {
                    if (_sw92340000_ === "loopend") {
                        count++;
                    }
                }
                if (node.up) {
                    
                } else {
                    break;
                }
                var id = graph.getNodeUp(node);
                node = graph.getNode(id);
            }
            if (count === 0) {
                return false;
            } else {
                return true;
            }
            break;
        }
        var id = graph.getNodeUp(node);
        node = graph.getNode(id);
    }
}

function isLastBranch(graph, item) {
    var aboveId = graph.getNodeUp(item);
    var above = graph.getNode(aboveId);
    if (above.right) {
        return false;
    } else {
        return true;
    }
}

function isMind() {
    if (self.storage) {
        return self.storage.type == "mind"
    } else {
        return false
    }
}

function isMindSocket(socket) {
    return Utils.startsWith(socket, "mind-")
}

function isNakedCorner(graph, edge) {
    var type;
    var gap;
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    var gap = tail.y - head.y - 
      head.h - tail.h;
    if (head.type === "junction") {
        type = describeJunction(head);
        if ((type === "left-down") && (!(gap > Config.METRE))) {
            return true;
        } else {
            return false;
        }
    } else {
        if (tail.type === "junction") {
            type = describeJunction(tail);
            if ((type === "left-up") && (!(gap > Config.METRE))) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
}

function isNextToCorner(graph, tail) {
    if (tail.type == "junction") {
        var type = describeJunction(tail)
        if (type == "left-up") {
            var above = graph.getNodeUpEx(tail)
            var bottom = above.y + above.h
            var distance = tail.y - bottom
            if (distance < Config.METRE * 2) {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    } else {
        return false
    }
}

function isNodeOnMainSkewer(graph, node) {
    if (node.up) {
        var edge = graph.getEdge(node.up);
        return isEdgeOnMainSkewer(graph, edge);
    } else {
        if (node.type === "beginend") {
            return true;
        } else {
            return false;
        }
    }
}

function isOnBranchSkewer(graph, id) {
    var top = goUpToEnd(graph, id);
    if (top.type === "beginend") {
        return true;
    } else {
        var belowId = graph.getNodeDown(top);
        var below = graph.getNode(belowId);
        if (below.type === "branch") {
            return true;
        } else {
            return false;
        }
    }
}

function isRightHand(graph, edge) {
    var head = graph.getHead(edge);
    var tail = graph.getTail(edge);
    if ((((edge.role) || (edge.isVertical)) || (!(head.type === "question"))) || (!(tail.type === "junction"))) {
        return false;
    } else {
        var tailType = describeJunction(tail);
        if (tailType === "left-down") {
            return false;
        } else {
            return true;
        }
    }
}

function isSelected(id) {
    if (id) {
        return id in self.storage.selection.ids;
    } else {
        return false;
    }
}

function isShortTExit(graph, item) {
    if ((item.isLine) && (Utils.canInsertInHorizontal(graph, item))) {
        var right = graph.getTail(item)
        if (right.down) {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function isSilhouette(graph) {
    var _ind9614 = 0;
    var _col9614 = graph.nodes;
    var _keys9614 = Object.keys(_col9614); 
    var _len9614 = _keys9614.length;
    while (true) {
        if (_ind9614 < _len9614) {
            
        } else {
            return false;
        }
        var id = _keys9614[_ind9614]; var node = _col9614[id];
        if (node.type === "branch") {
            return true;
        }
        _ind9614++;
    }
}

function isUnderCase(graph, nodeId) {
    var top = goUpToEnd(graph, nodeId);
    var belowTopId = graph.getNodeDown(top);
    var belowTop = graph.getNode(belowTopId);
    if (belowTop.type === "case") {
        return true;
    } else {
        return false;
    }
}

function isUpT(node) {
    if (((((node.type == "junction") && (node.up)) && (node.left)) && (node.right)) && (!(node.down))) {
        return true;
    } else {
        return false;
    }
}

function kinematicMove(pgraph, id, dx, dy, movedNodes) {
    pgraph.kinematicMove(id, dx, dy);
    movedNodes[id] = true;
}

function lastParallel(graph, node) {
    if (((node.type == "junction") && (node.left)) && (!(node.right))) {
        var edge = graph.getEdge(node.left);
        if (edge.role == "parallel") {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function leadsToArrow(graph, edgeId) {
    var edge = graph.getEdge(edgeId);
    var tail = graph.getTail(edge);
    if (tail.type === "junction") {
        var type = describeJunction(tail);
        if (type === "right-up") {
            var rightId =graph.getNodeRight(tail);
            var right = graph.getNode(rightId);
            var rightType = describeJunction(right);
            if (rightType === "left-up") {
                return "arrow";
            } else {
                return null;
            }
        } else {
            if ((type === "left-up") && (questionOnLeft(graph, tail))) {
                return "sq";
            } else {
                return null;
            }
        }
    } else {
        return null;
    }
}

function leftInnerCorner(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var commands = {};
    var bottom;
    var right;
    extendEdge(
    	pgraph,
    	source,
    	0,
    	movedNodes
    );
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetTail = graph.getNode(target);
    var targetEdge = graph.getEdge(targetTail.up);
    var targetHead = graph.getHead(targetEdge);
    var dims = findLedgeFromOrigin(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    var targetY = targetTail.y;
    if (dims.y > targetY) {
        var vDelta = dims.y - targetY;
        bottom = targetTail.y + vDelta;
        dropDown(
        	pgraph,
        	targetTail,
        	bottom,
        	movedNodes
        );
        targetY = dims.y;
    }
    var sourceY1 = sourceHead.box.bottom + Config.METRE;
    var sourceY2 = sourceTail.box.top - Config.METRE;
    if (targetY > sourceY2) {
        if (source.x < dims.x) {
            var hDelta = dims.x - source.x;
            pgraph.moveRight(
            	sourceHead.id,
            	hDelta,
            	movedNodes
            );
        }
        drill(
        	pgraph,
        	sourceTail.x,
        	sourceTail.y,
        	targetY,
        	movedNodes
        );
        bottom = targetY;
    } else {
        if (targetY < sourceY1) {
            var delta2 = sourceY1 - targetY;
            bottom = targetTail.y + delta2;
            dropDown(
            	pgraph,
            	targetTail,
            	bottom,
            	movedNodes
            );
            bottom = sourceY1;
        } else {
            bottom = targetY;
        }
    }
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var rightJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	bottom,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	target,
    	rightJun,
    	"left"
    );
    return commandList;
}

function leftInnerLine(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var sGraph = editor.storage.graph;
    var movedNodes = {};
    var commands = {};
    var bottom;
    var right;
    extendEdge(
    	pgraph,
    	source,
    	0,
    	movedNodes
    );
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetTail = graph.getTail(targetEdge);
    extendEdge(
    	pgraph,
    	targetEdge.id,
    	0,
    	movedNodes
    );
    var dims = findLedgeFromOrigin(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    var targetY = targetTail.box.top - Config.METRE;
    if (dims.y > targetY) {
        var vDelta = dims.y - targetY;
        bottom = targetTail.y + vDelta;
        dropDown(
        	pgraph,
        	targetTail,
        	bottom,
        	movedNodes
        );
        targetY = dims.y;
    }
    var sourceY1 = sourceHead.box.bottom + Config.METRE;
    var sourceY2 = sourceTail.box.top - Config.METRE;
    if (targetY > sourceY2) {
        if (source.x < dims.x) {
            var hDelta = dims.x - source.x;
            pgraph.moveRight(
            	sourceHead.id,
            	hDelta,
            	movedNodes
            );
        }
        drill(
        	pgraph,
        	sourceTail.x,
        	sourceTail.y,
        	targetY,
        	movedNodes
        );
        bottom = targetY;
    } else {
        if (targetY < sourceY1) {
            var delta2 = sourceY1 - targetY;
            bottom = targetTail.y + delta2;
            dropDown(
            	pgraph,
            	targetTail,
            	bottom,
            	movedNodes
            );
            bottom = sourceY1;
        } else {
            bottom = targetY;
        }
    }
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	target
    );
    var stail = sGraph.getTail(sourceEdge);
    if (stail.type === "address") {
        commandList = deleteAddressLiana(
        	editor,
        	graph,
        	sourceEdge,
        	commandList
        );
    } else {
        deleteLiana(
        	editor,
        	graph,
        	sourceEdge,
        	commandList
        );
    }
    var leftJun = insertJunctionBetween(
    	editor,
    	graph,
    	targetEdge.head,
    	targetEdge.tail,
    	bottom,
    	commandList
    );
    var rightJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	bottom,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	leftJun,
    	rightJun,
    	"left"
    );
    return commandList;
}

function leftInnerLineEx(editor, pgraph, source, target) {
    addTrace(
    	"transplant liana",
    	["leftInnerLineEx", source, target]
    )
    var before = copyState(editor);
    var after = copyState(editor);
    after.selection = createSelection();
    var commandList1 = expandBoltCore(
    	editor,
    	pgraph,
    	source
    )
    commandList1 = makeUndoAndExecute(
    	editor,
    	commandList1,
    	after,
    	false
    )
    var newEdgeId = null
    var _ind18414 = 0;
    var _col18414 = commandList1;
    var _len18414 = _col18414.length;
    while (true) {
        if (_ind18414 < _len18414) {
            
        } else {
            break;
        }
        var command = _col18414[_ind18414];
        if (((command.type == "insert") && (command.table == "edges")) && (command.fields.role == "down")) {
            newEdgeId = command.id
            break;
        }
        _ind18414++;
    }
    var pgraph2 = createPhysicalGraph(
    	editor.storage.graph,
    	editor.render
    )
    var commandList2 = leftInnerLine(
    	editor,
    	pgraph2,
    	newEdgeId,
    	target
    )
    commandList2 = makeUndoAndExecute(
    	editor,
    	commandList2,
    	after,
    	true
    )
    var commandList = commandList1.concat(
    	commandList2
    )
    commandList = normalizeCommands2(commandList)
    addToUndo(editor.undo, before, commandList, after)
    return null
}

function leftInnerLineTs(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var sGraph = editor.storage.graph;
    var movedNodes = {};
    var commands = {};
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetTail = graph.getTail(targetEdge);
    graph.removeItem(source)
    pgraph.rebuildCache()
    pgraph.moveDown(
    	sourceHead.id,
    	Config.METRE,
    	movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	target
    );
    pushDeleteEdge(
    	commandList,
    	source
    );
    var leftJun = insertJunctionBetween(
    	editor,
    	graph,
    	targetEdge.head,
    	targetEdge.tail,
    	sourceTail.y,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	leftJun,
    	sourceTail.id,
    	"left"
    );
    return commandList;
}

function leftOuterCorner(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var commands = {};
    var bottom;
    var right;
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetTail = graph.getNode(target);
    var targetEdge = graph.getEdge(targetTail.up);
    var dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    var targetY = targetTail.y;
    if (dims.y > targetY) {
        var vDelta = dims.y - targetY;
        bottom = targetTail.y + vDelta;
        dropDown(
        	pgraph,
        	targetTail,
        	bottom,
        	movedNodes
        );
    } else {
        bottom = targetY;
    }
    dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    if (dims.lowId == targetTail.id) {
        right = dims.x + Config.METRE;
    } else {
        right = dims.x;
    }
    if (right > sourceTail.x) {
        var hDelta = right - sourceTail.x;
        pgraph.moveRight(
        	sourceTail.id,
        	hDelta,
        	movedNodes
        );
    } else {
        right = sourceTail.x;
    }
    rayTraceDown(
    	pgraph,
    	right,
    	sourceTail.y,
    	bottom + Config.METRE,
    	movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var rightJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	bottom,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	target,
    	rightJun,
    	"left"
    );
    return commandList;
}

function leftOuterCornerSil(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var sGraph = editor.storage.graph;
    var render = editor.render;
    var movedNodes = {};
    var commands = {};
    var commandList = [];
    var bottom;
    var right;
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetTail = graph.getNode(target);
    var targetEdge = graph.getEdge(targetTail.up);
    var dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    var targetY = targetTail.y;
    var neighbourHead = sGraph.getNode(targetEdge.head);
    var addCont = neighbourHead.content;
    var add = makeDummyItem(
    	1,
    	render,
    	"address",
    	addCont
    );
    var width = getVerticalWidth(
    	sGraph,
    	sourceEdge.head
    );
    if (dims.y > targetY) {
        var vDelta = dims.y - targetY;
        bottom = targetTail.y + vDelta;
        var oldAddress = graph.getNode(
        	targetEdge.head
        );
        dropDownCore(
        	pgraph,
        	targetTail,
        	bottom,
        	oldAddress.box.right + Config.METRE,
        	movedNodes
        );
    } else {
        bottom = targetY;
    }
    dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    if (dims.lowId == targetTail.id) {
        right = dims.x + Config.METRE;
    } else {
        right = dims.x;
    }
    if (right > sourceTail.x) {
        var hDelta = right - sourceTail.x;
        pgraph.moveRight(
        	sourceTail.id,
        	hDelta,
        	movedNodes
        );
    } else {
        right = sourceTail.x;
    }
    rayTraceDown(
    	pgraph,
    	right,
    	sourceTail.y,
    	bottom + Config.METRE,
    	movedNodes
    );
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var h = graph.getNode(sourceEdge.head);
    var addX = h.x;
    var le = graph.getNode(target);
    var addY = le.y - Config.METRE - add.h;
    var commands = {};
    makeHorSpace(
        pgraph,
        addX,
        addY,
        width,
        add.h,
        movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList2 = Utils.objectValues(commands);
    commandList = commandList.concat(commandList2);
    var addId = generateId(editor.storage);
    var junId = generateId(editor.storage);
    pushInsertJunction(
    	commandList,
    	junId,
    	addX, le.y
    );
    pushInsertNodeAt(
    	render,
    	commandList,
    	addId,
    	"address",
    	addX, addY,
    	width, add.h,
    	addCont
    );
    connectVer(
    	editor,
    	commandList,
    	sourceEdge.head, addId,
    	"down", null
    );
    connectVer(
    	editor,
    	commandList,
    	addId, junId,
    	null, null
    );
    connectHor(
    	editor,
    	commandList,
    	target, junId,
    	"sil_floor", null
    );
    return commandList;
}

function leftOuterCornerTs(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var sGraph = editor.storage.graph;
    var movedNodes = {};
    var commands = {};
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetNode = graph.getNode(target);
    var eUp = graph.getEdge(sourceHead.up)
    var above = graph.getNodeUpEx(sourceHead)
    graph.removeItem(source)
    pgraph.rebuildCache()
    var dy = targetNode.y - sourceTail.y
    pgraph.moveDown(
    	sourceTail.id,
    	dy,
    	movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	source
    );
    pushDeleteEdge(
    	commandList,
    	sourceHead.up
    )
    pushDeleteEdge(
    	commandList,
    	sourceHead.down
    )
    pushDeleteNode(
    	commandList,
    	sourceHead.id
    );
    var vId = generateId(editor.storage);
    pushInsertVertical(
    	commandList,
    	vId,
    	above.id,
    	target,
    	eUp.role
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	target,
    	sourceTail.id,
    	"left"
    );
    return commandList;
}

function leftOuterLine(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var commands = {};
    var bottom;
    var right;
    extendEdge(
    	pgraph,
    	target,
    	0,
    	movedNodes
    );
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetTail = graph.getTail(targetEdge);
    var dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    var targetY = targetTail.box.top - Config.METRE;
    if (dims.y > targetY) {
        var vDelta = dims.y - targetY;
        bottom = targetTail.y + vDelta;
        dropDown(
        	pgraph,
        	targetTail,
        	bottom,
        	movedNodes
        );
    }
    dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetTail.id
    );
    targetY = targetTail.box.top - Config.METRE;
    right = dims.x;
    if (right > sourceTail.x) {
        var hDelta = right - sourceTail.x;
        pgraph.moveRight(
        	sourceTail.id,
        	hDelta,
        	movedNodes
        );
    } else {
        right = sourceTail.x;
    }
    rayTraceDown(
    	pgraph,
    	right,
    	sourceTail.y,
    	targetY + Config.METRE,
    	movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	target
    );
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var leftJun = insertJunctionBetween(
    	editor,
    	graph,
    	targetEdge.head,
    	targetEdge.tail,
    	targetY,
    	commandList
    );
    var rightJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	targetY,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	leftJun,
    	rightJun,
    	"left"
    );
    return commandList;
}

function leftOuterLineTs(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var commands = {};
    extendEdge(
    	pgraph,
    	target,
    	0,
    	movedNodes
    );
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetTail = graph.getTail(targetEdge);
    graph.removeItem(source)
    pgraph.rebuildCache()
    pgraph.moveDown(
    	sourceTail.id,
    	Config.METRE,
    	movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	target
    );
    pushDeleteEdge(
    	commandList,
    	source
    );
    var leftJun = insertJunctionBetween(
    	editor,
    	graph,
    	targetEdge.head,
    	targetEdge.tail,
    	sourceTail.y,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	leftJun,
    	sourceTail.id,
    	"left"
    );
    return commandList;
}

function leftToEndNoDuration(graph, nodeId) {
    var node = goLeftToEnd(graph, nodeId)
    if (node.type == "duration") {
        return graph.getNodeRightEx(node)
    } else {
        return node
    }
}

function leftWithDown(graph, node) {
    var result = graph.getNodeLeftEx(node)
    if (result.down) {
        return result
    } else {
        return graph.getNodeLeftEx(result)
    }
}

function loadDiagram(diagram) {
    var storage = new Storage(self.persistence);
    storage.name = diagram.name;
    storage.type = diagram.type;
    storage.background = diagram.background
    storage.diaLine = diagram.diaLine
    storage.diaLineThickness = diagram.diaLineThickness
    storage.font = diagram.font
    storage.selection = copySelection(diagram.selection)
    storage.version = diagram.version || 0
    var _ind12247 = 0;
    var _col12247 = diagram.nodes;
    var _keys12247 = Object.keys(_col12247); 
    var _len12247 = _keys12247.length;
    while (true) {
        if (_ind12247 < _len12247) {
            
        } else {
            break;
        }
        var nid = _keys12247[_ind12247]; var it = _col12247[nid];
        var item = copyStorageItem(it);
        item.isLine = false;
        storage.graph.addItem(item);
        _ind12247++;
    }
    var _ind12252 = 0;
    var _col12252 = diagram.edges;
    var _keys12252 = Object.keys(_col12252); 
    var _len12252 = _keys12252.length;
    while (true) {
        if (_ind12252 < _len12252) {
            
        } else {
            break;
        }
        var eid = _keys12252[_ind12252]; var it = _col12252[eid];
        var item = copyStorageItem(it);
        item.isLine = true;
        storage.graph.addItem(item);
        _ind12252++;
    }
    var error = copyAndSort(diagram.free, storage.free)
    if (error) {
        Utils.throwError(error)
    }
    recalculateNextId(storage)
    setStorage(self, storage)
    self.render.setDefaultFont(
    	self.storage.font
    )
}

function makeAndDrawSocket(render, graph, id, type, action) {
    var socket = makeSocket(graph, id, type, action);
    socket.prim = render.addSocket(
    	socket.center.x,
    	socket.center.y
    );
    return socket;
}

function makeCommonWidth(editor, pgraph, srcId, dstId, movedNodes, commands) {
    var graph = pgraph.graph;
    var render = editor.render;
    var srcWidth = getVerticalWidth(
    	graph,
    	srcId
    );
    Drakon.setSkewerWidth(
    	render,
    	pgraph,
    	dstId,
    	srcWidth,
    	commands
    );
}

function makeCont(text) {
    var content = new Utils.Content(text, "")
    var defaultFont = getDefault("font")
    var diagramFont = self.storage.font
    if ((defaultFont) && (!(diagramFont == defaultFont))) {
        content.font = defaultFont
    }
    var shape = getDefault("shape")
    if (shape) {
        var _ind17995 = 0;
        var _col17995 = shape;
        var _keys17995 = Object.keys(_col17995); 
        var _len17995 = _keys17995.length;
        while (true) {
            if (_ind17995 < _len17995) {
                
            } else {
                break;
            }
            var key = _keys17995[_ind17995]; var value = _col17995[key];
            if (hasValue(value)) {
                content[key] = value
            }
            _ind17995++;
        }
    }
    return content
}

function makeDeletionPlan(editor, nodeId) {
    var _sw84040000_ = 0;
    var plan = {
    	nodes: {},
    	edges: {},
    	horHoles: {},
    	verHoles: {},
    	newEdges: {},
    	stairs: {},
    	mainDeletes: [nodeId]
    };
    var graph = editor.storage.graph;
    var node = graph.getNode(nodeId);
    _sw84040000_ = node.type;
    if (_sw84040000_ === "question") {
        planDeleteQuestion(
        	graph,
        	node,
        	plan
        );
    } else {
        if (_sw84040000_ === "select") {
            planDeleteSelect(
            	graph,
            	node,
            	plan
            );
        } else {
            if (_sw84040000_ === "case") {
                planDeleteCase(
                	graph,
                	node,
                	plan
                );
            } else {
                if (_sw84040000_ === "loopbegin") {
                    planDeleteLoop(
                    	graph,
                    	node,
                    	plan
                    );
                } else {
                    if (_sw84040000_ === "loopend") {
                        
                    } else {
                        throw "Unexpected switch value: " + _sw84040000_;
                    }
                    planDeleteLoopEnd(
                    	graph,
                    	node,
                    	plan
                    );
                }
            }
        }
    }
    glueHoles(plan, plan.horHoles);
    glueHoles(plan, plan.verHoles);
    return plan;
}

function makeDummyItem(id, render, type, content) {
    var item = {
    	id: String(id),
    	isLine: false,
    	type: type,
    	content: content,
    	x: 0,
    	y: 0
    };
    adjustFontSize(item)
    var width;
    if (Drakon.isWideIcon(item)) {
        width = Config.DEF_ICON_WIDTH;
    } else {
        width = Config.DEF_ICON_WIDTH_S;
    }
    item.w = width;
    var size = Drakon.fitItem(item, render);
    setItemDims(item, size);
    return item;
}

function makeDummyJunction(id, x, y) {
    var item = {
    	id: String(id),
    	isLine: false,
    	x: x,
    	y: y,
    	w: 0,
    	h: 0,
    	type: "junction"
    };
    return item;
}

function makeDummyLine(id, isVertical, head, tail, role) {
    var item = {
    	id: String(id),
    	isLine: true,
    	isVertical: isVertical,
    	head: head,
    	tail: tail,
    	role: role,
    	type: isVertical ? "vertical" : "horizontal"
    };
    return item;
}

function makeFreeSpace(editor, pgraph, headId, tailId, box, commands) {
    var render = editor.render;
    var graph = editor.storage.graph;
    var head = graph.getNode(headId);
    var tail = graph.getNode(tailId);
    var headBox = getBox(head, render);
    var tailBox = getBox(tail, render);
    var insertion = new Utils.Point(
    	head.x,
    	headBox.bottom + Config.METRE - box.top
    );
    var h = box.bottom - box.top;
    var dh = tail.y - tailBox.top;
    var required = headBox.bottom +
     Config.METRE * 2 + h + dh;
    var movedNodes = {};
    if (required > tail.y) {
        var delta = required - tail.y;
        pgraph.moveDown(
            tailId,
            delta,
            movedNodes
        );
    }
    var directionProps = "horizontal";
    var fakeSkewer = {};
    var leftBox = new Utils.Box(
    	box.left + insertion.x,
    	box.top + insertion.y,
    	head.x,
    	box.bottom + insertion.y
    );
    var leftItem = { box: leftBox };
    pgraph.pushObjects(
        leftItem.box,
        fakeSkewer,
        box.right,
        directionProps,
        movedNodes
    );
    var rightBox = new Utils.Box(
    	head.x,
    	box.top + insertion.y,
    	box.right + insertion.x,
    	box.bottom + insertion.y
    );
    var rightItem = { box: rightBox };
    pgraph.pushObjects(
        rightItem.box,
        fakeSkewer,
        box.left,
        directionProps,
        movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    return insertion;
}

function makeHeaderCont(text) {
    var content = makeCont(text)
    var defaultFont = getDefault("font")
    var size
    var family
    if (defaultFont) {
        var parsed = Utils.parseFontString(defaultFont)
        size = parsed.size
        family = parsed.family
    } else {
        size = Config.FONT_SIZE
        family = Config.FONT_FAMILY
    }
    var font = Utils.buildFontString(
    	false,
    	true,
    	headerSize(size),
    	family
    )
    content.font = font
    return content
}

function makeHorSpace(pgraph, x, y, w, h, movedNodes) {
    var directionProps = "horizontal";
    var box = Utils.boxFromPoint(x, y, 0, h);
    pgraph.pushObjects(
        box,
        {},
        w,
        directionProps,
        movedNodes
    );
    pgraph.pushObjects(
        box,
        {},
        -w,
        directionProps,
        movedNodes
    );
}

function makeIconBoxForType(render, type, cont, width) {
    var item = {
    	type: type,
    	content: cont,
    	isLine: false,
    	x: 0,
    	y: 0,
    	w: width
    };
    var callback = Items.getItemCallback(
    	type
    );
    var size = Drakon.fitItem(item, render);
    setItemDims(item, size);
    var box = callback.makeBox(
    	item,
    	0,
    	0,
    	render
    );
    var result = {
    	size: size,
    	box: box
    };
    return result;
}

function makeMindItem(id, render, type, content, width) {
    var item = {
    	id: String(id),
    	isLine: false,
    	type: type,
    	content: content,
    	x: 0,
    	y: 0
    }
    item.w = width
    var size = Drakon.fitItem(item, render)
    setItemDims(item, size)
    return item
}

function makeNewZone(canvas) {
    var zone = canvas.zone;
    canvas.zone++;
    return zone;
}

function makePipe(pgraph, left, right, corner, movedNodes) {
    var graph = pgraph.graph;
    var leftX = left.x;
    var rightX = right.x;
    var top;
    var bottom;
    if (left.y < right.y) {
        top = left.y;
        bottom = right.y;
    } else {
        top = right.y;
        bottom = left.y;
    }
    var step = Config.SNAP;
    while (true) {
        if (hasPipe(graph, leftX, top, rightX, bottom)) {
            break;
        }
        pgraph.moveRight(
        	corner,
        	step,
        	movedNodes
        );
        rightX += step;
    }
}

function makePipeForEdge(pgraph, leftId, rightId, movedNodes) {
    var graph = pgraph.graph;
    var left = nextPointBelow(
    	graph,
    	leftId
    )
    left.y -= Config.METRE / 2;
    var right = nextPointBelow(
    	graph,
    	rightId
    );
    right.y -= Config.METRE / 2;
    var rightEdge = graph.getEdge(
    	rightId
    );
    makePipe(
    	pgraph,
    	left,
    	right,
    	rightEdge.tail,
    	movedNodes
    );
}

function makePipeForNode(pgraph, leftId, rightId, movedNodes) {
    var graph = pgraph.graph;
    var leftNode = graph.getNode(leftId);
    var left = new Utils.Point(
    	leftNode.x,
    	leftNode.y
    );
    var right = nextPointBelow(
    	graph,
    	rightId
    );
    right.y -= Config.METRE / 2;
    var rightEdge = graph.getEdge(
    	rightId
    );
    makePipe(
    	pgraph,
    	left,
    	right,
    	rightEdge.tail,
    	movedNodes
    );
}

function makePointToCommand(editor, addressNodeId, targetNode) {
    var graph = editor.storage.graph
    var address = graph.getNode(addressNodeId)
    var cont = Utils.copyObject(getContent(address))
    var text = getText(targetNode);
    cont.txt = text
    var menuText = tr("MES_POINT_TO") + " \"" + text + "\"";
    var result = { 
    	type: "item", 
    	text: menuText, 
    	code: function() {
     	       setItemText(editor, addressNodeId, cont);
    	}
    };
    return result;
}

function makeRCont() {
    var content = makeCont("")
    content.radius = RoundedRadius
    return content
}

function makeSecDeletionPlan(graph, edgeId, plan) {
    var edge = graph.getEdge(edgeId);
    var node = graph.getTail(edge);
    plan.edges[edgeId] = true;
    if (isArrowStart(graph, node)) {
        deleteArrow(graph, node, plan);
    } else {
        var type = describeJunction(node);
        if (type === "left-t") {
            if (node.id in plan.stairs) {
                delete plan.stairs[node.id]
                var downId = graph.getNodeDown(node);
                plan.edges[node.down] = true;
                plan.nodes[node.id] = true;
                planDeleteMain(
                	graph,
                	downId,
                	plan,
                	false
                );
            } else {
                pokeVer(
                	graph,
                	node,
                	plan
                );
            }
        } else {
            var downId = graph.getNodeDown(node);
            plan.edges[node.down] = true;
            plan.nodes[node.id] = true;
            planDeleteMain(
            	graph,
            	downId,
            	plan,
            	false
            );
        }
    }
}

function makeSimpleSubtree(type, width) {
    var empty = makeCont("")
    var id = "1"
    if (type == "raction") {
        empty.radius = RoundedRadius
    }
    var newChild = makeMindItem(
    	id,
    	self.render,
    	type,
    	empty,
    	width
    )
    newChild.x = newChild.w
    newChild.y = newChild.h
    var result = new Utils.LogicalTree(id)
    Utils.addLogicalTreeNode(result, newChild)
    return result
}

function makeSocket(graph, id, type, action) {
    var x, y
    var item = graph.getItem(id)
    if (item.isLine) {
        var head = graph.getHead(item)
        var tail = graph.getTail(item)
        if (item.isVertical) {
            var top = head.y + head.h
            var bottom = tail.y - tail.h
            x = head.x
            y = Math.floor((top + bottom) / 2)
        } else {
            var left = head.x + head.w
            var right = tail.x - tail.w
            y = head.y
            x = Math.floor((left + right) / 2)
        }
    } else {
        if (action.action) {
            x = item.x + action.dx
            y = item.y + action.dy
        } else {
            x = item.x
            y = item.y
        }
    }
    var pos = new Utils.Point(x, y)
    return new Socket(id, pos, type, action)
}

function makeSocketType(socketType, action, x, y) {
    var type = {
    	action: action.action,
    	socketType: socketType,
    	itemId: action.itemId,
    	dx: x,
    	dy: y
    }
    return type
}

function makeTurnIntoElement(itemId, avItem2) {
    var item = {
    	image: avItem2.image,
    	text: tr(avItem2.text),
    	code: function() {
    		changeMindElementType(itemId, avItem2.type)
    	}
    }
    return item
}

function makeUndoAndExecute(editor, commandList, after, redraw) {
    var commandList2 = calculateUndo(
    	editor.storage,
    	commandList
    );
    executeCommands(
    	editor,
    	commandList2,
    	after,
    	false,
    	redraw
    );
    return commandList2
}

function mark2DownBig(stack, canvas, head, zone) {
    var graph = canvas.graph;
    var edge = graph.getEdge(head.down);
    var tail = graph.getTail(edge);
    if (mark2Upper(edge, zone)) {
        if (tail.right) {
            var redge = graph.getEdge(tail.right);
            if (redge.role == "parallel") {
                stack.push(zone);
                var newZone = makeNewZone(canvas);
                mark2DownBig(stack, canvas, tail, newZone);
                var rtail = graph.getNode(redge.tail);
                mark2parallel(canvas, rtail);
            } else {
                if (edge.role == "par-down") {
                    if (tail.down) {
                        var oldZone = stack.pop();
                        mark2DownBig(stack, canvas, tail, oldZone);
                    }
                } else {
                    mark2RightUpper(stack, canvas, tail, zone);
                    if (tail.down) {
                        mark2NewZone(stack, canvas, tail);
                    }
                }
            }
        } else {
            if (tail.down) {
                mark2DownBig(stack, canvas,  tail, zone);
            } else {
                if ((edge.role == "par-down") || (!(tail.left))) {
                    
                } else {
                    var leftEdge = graph.getEdge(tail.left);
                    if (leftEdge.role === "sil_floor") {
                        
                    } else {
                        mark2LeftLower(stack, canvas, tail, zone);
                    }
                }
            }
        }
    }
}

function mark2DownPar(stack, canvas, head, zone) {
    var graph = canvas.graph;
    var edge = graph.getEdge(head.down);
    var tail = graph.getTail(edge);
    if (edge.role == "par-down") {
        mark2DownSmall(stack, canvas, tail, zone);
    } else {
        mark2DownPar(stack, canvas, tail, zone);
    }
}

function mark2DownSmall(stack, canvas, head, zone) {
    var graph = canvas.graph;
    var edge = graph.getEdge(head.down);
    var tail = graph.getTail(edge);
    if (mark2Lower(edge, zone)) {
        if (tail.right) {
            var redge = graph.getEdge(tail.right);
            if (redge.role == "parallel") {
                mark2DownPar(stack, canvas, tail, zone);
            } else {
                if (edge.role == "par-down") {
                    
                } else {
                    if (tail.left) {
                        var left = graph.getEdge(tail.left);
                        if (left.role == "lstick") {
                            if (tail.down) {
                                mark2DownSmall(stack, canvas, tail, zone);
                            } else {
                                if (tail.right) {
                                    mark2RightLower(stack, canvas, tail, zone);
                                }
                            }
                        }
                    } else {
                        if (tail.down) {
                            mark2DownSmall(stack, canvas, tail, zone);
                        } else {
                            if (tail.right) {
                                mark2RightLower(stack, canvas, tail, zone);
                            }
                        }
                    }
                }
            }
        } else {
            if (tail.left) {
                var left = graph.getEdge(tail.left);
                if (left.role == "lstick") {
                    if (tail.down) {
                        mark2DownSmall(stack, canvas, tail, zone);
                    } else {
                        if (tail.right) {
                            mark2RightLower(stack, canvas, tail, zone);
                        }
                    }
                }
            } else {
                if (tail.down) {
                    mark2DownSmall(stack, canvas, tail, zone);
                } else {
                    if (tail.right) {
                        mark2RightLower(stack, canvas, tail, zone);
                    }
                }
            }
        }
    }
}

function mark2LeftLower(stack, canvas, tail, zone) {
    var graph = canvas.graph;
    var edge = graph.getEdge(tail.left);
    var head = graph.getHead(edge);
    if (mark2Lower(edge, zone)) {
        if (head.down) {
            mark2DownBig(stack, canvas,  head, zone);
        } else {
            if (head.left) {
                mark2LeftLower(stack, canvas, head, zone);
            } else {
                if (head.up) {
                    mark2UpSmall(stack, canvas, head, zone);
                }
            }
        }
    }
}

function mark2Lower(edge, zone) {
    if (edge.lowerMark) {
        return false;
    } else {
        edge.lowerMark = zone;
        return true;
    }
}

function mark2NewZone(stack, canvas, node) {
    var graph = canvas.graph;
    var nextZone = makeNewZone(canvas);
    mark2RightLower(stack, canvas,
    	node,
    	nextZone
    );
    mark2DownBig(stack, canvas, 
    	node,
    	nextZone
    );
}

function mark2RightLower(stack, canvas, head, zone) {
    var graph = canvas.graph;
    var edge = graph.getEdge(head.right);
    var tail = graph.getTail(edge);
    if (mark2Lower(edge, zone)) {
        if (tail.down) {
            mark2DownSmall(stack, canvas, tail, zone);
        } else {
            if (tail.right) {
                mark2RightLower(stack, canvas, tail, zone);
            }
        }
    }
}

function mark2RightUpper(stack, canvas, head, zone) {
    var graph = canvas.graph;
    var edge = graph.getEdge(head.right);
    var tail = graph.getTail(edge);
    if ((mark2Upper(edge, zone)) && (!(tail.up))) {
        if (tail.right) {
            mark2RightUpper(stack, canvas, tail, zone);
            if (tail.down) {
                mark2NewZone(stack, canvas, tail);
            }
        } else {
            if (tail.down) {
                mark2DownBig(stack, canvas,  tail, zone);
            }
        }
    }
}

function mark2UpSmall(stack, canvas, tail, zone) {
    var graph = canvas.graph;
    var edge = graph.getEdge(tail.up);
    var head = graph.getHead(edge);
    if (mark2Lower(edge, zone)) {
        if (hasLeft(graph, head)) {
            mark2LeftLower(stack, canvas, head, zone);
        } else {
            if (head.up) {
                mark2UpSmall(stack, canvas, head, zone);
            }
        }
    }
}

function mark2Upper(edge, zone) {
    if (edge.upperMark) {
        return false;
    } else {
        edge.upperMark = zone;
        return true;
    }
}

function mark2parallel(canvas, head) {
    var graph = canvas.graph;
    var nextZone = makeNewZone(canvas);
    var stack = [];
    mark2DownBig(stack, canvas, head, nextZone);
    if (head.right) {
        var tail = graph.getNodeRightEx(head);
        mark2parallel(canvas, tail);
    }
}

function markVerticals(graph, node, verticals) {
    if (node.up) {
        verticals[node.up] = true
    }
    while (true) {
        verticals[node.down] = true
        node = graph.getNodeDownEx(node)
        if (node.down) {
            
        } else {
            break;
        }
    }
}

function measureBranch(render, graph, top) {
    var nodes;
    var edges;
    var headerId = graph.getNodeDown(top);
    if (top.right) {
        var bgraph = findBranchGraph(graph, headerId);
        nodes = bgraph.nodes;
        edges = bgraph.edges;
    } else {
        nodes = {};
        edges = {};
        nodes[top.id] = true;
        var bottom = goDownToEnd(graph, top.id)
        nodes[bottom.id] = true
        graph.enumerateManhattan(
        	headerId,
        	nodes,
        	edges
        );
    }
    var graph2 = copyGraphSectionNoMove(
    	graph,
    	nodes,
    	edges
    );
    var pgraph = createPhysicalGraph(
    	graph2,
    	render
    );
    var subBox = findDiagramBox(pgraph.graph);
    return subBox;
}

function measureDiagram() {
    var pgraph = createPhysicalGraph(
    	self.storage.graph,
    	self.render
    );
    var left = Number.MAX_VALUE
    var right = -Number.MAX_VALUE
    var top = Number.MAX_VALUE
    var bottom = -Number.MAX_VALUE
    var dbox = findDiagramBoxCore(
    	pgraph.graph,
    	left,
    	top,
    	right,
    	bottom
    );
    var box = findFreeItemsBox(
    	self.storage.free,
    	dbox.left,
    	dbox.top,
    	dbox.right,
    	dbox.bottom
    )
    left = getRidOfMinMax(box.left, 0)
    right = getRidOfMinMax(box.right, 300)
    top = getRidOfMinMax(box.top, 0)
    bottom = getRidOfMinMax(box.bottom, 300)
    var border = Config.METRE;
    return new Utils.Box(
    	left - border,
    	top - border,
    	right + border,
    	bottom + border
    );
}

function middleParallel(graph, node) {
    if (((node.type == "junction") && (node.left)) && (node.right)) {
        var edge = graph.getEdge(node.left);
        if (edge.role == "parallel") {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function mih3Ok(graph, item) {
    if (((item.isLine) || (item.type == "junction")) || (!(item.down))) {
        return false
    } else {
        var below = graph.getNodeDownEx(item)
        if (below.type == "junction") {
            return true
        } else {
            return false
        }
    }
}

function mindAction(actionName, itemId, type) {
    CallTrace.add(
    	"Editor: " + actionName,
    	[itemId]
    )
    var task = createTask(itemId)
    if (type) {
        var width = getWidthForMindRoot(
        	itemId,
        	actionName
        )
        var toInsert = makeSimpleSubtree(type, width)
        task.toInsert(toInsert)
    }
    runTask(task, actionName)
}

function mindPasteAction(actionName, itemId, subtree) {
    CallTrace.add(
    	"Editor: " + actionName,
    	[itemId]
    )
    var task = createTask(itemId)
    var width = getWidthForMindRoot(
    	itemId,
    	actionName
    )
    var root = subtree.nodes[subtree.root]
    root.w = width
    var size = Drakon.fitItem(root, self.render)
    setItemDims(root, size)
    task.toInsert(subtree)
    runTask(task, actionName)
}

function mouseClick(x, y) {
    addTrace("mouseClick", [x, y])
    self.dragOn = false
    var item = self.findVisualItem(
    	x,
    	y
    );
    addTrace("found vi", [item])
    self.dirty = true;
    if (item) {
        if ((item.id) && (!(self.isSelected(item.id)))) {
            deselectAll(self);
            selectItem(self, item.id);
            redrawCanvas(self);
        } else {
            self.dirty = false;
        }
    } else {
        deselectAll(self);
        redrawCanvas(self);
    }
    return {
    	mustRedraw: self.dirty
    };
}

function moveByArrow(dx, dy, visibleBox) {
    var ids = getSelection()
    if (ids.length == 1) {
        var currentId = ids[0]
        var current = getAnyItem(
        	self.storage,
        	currentId
        );
        dx *= Config.SNAP
        dy *= Config.SNAP
        startVisualDrag(currentId)
        visualDrag(dx, dy, visibleBox)
        endVisualDrag()
    }
}

function moveCanvasNode(canvas, id, x, y) {
    var graph = canvas.graph
    var render = canvas.render
    var free = canvas.free
    var node
    node = free.get(id)
    if (node) {
        
    } else {
        node = graph.getNode(id)
    }
    Items.moveCanvasNode(
    	render,
    	id,
    	node,
    	x,
    	y
    );
}

function moveGraphBy(graph, dx, dy) {
    var _ind13207 = 0;
    var _col13207 = graph.nodes;
    var _keys13207 = Object.keys(_col13207); 
    var _len13207 = _keys13207.length;
    while (true) {
        if (_ind13207 < _len13207) {
            
        } else {
            break;
        }
        var id = _keys13207[_ind13207]; var node = _col13207[id];
        node.x += dx;
        node.y += dy;
        _ind13207++;
    }
}

function moveHandle(id, handleType, dx, dy, x, y) {
    if (self.readonly) {
        
    } else {
        var free = self.canvas.free
        var render = self.render
        var item = free.get(id)
        var selection = getSelectedIds(self)
        var newValues = Items.moveHandle(
        	item,
        	handleType,
        	dx,
        	dy,
        	x,
        	y
        )
        Utils.mergeSets(item, newValues)
        Items.renderItem(
        	null,
        	render,
        	item,
        	selection
        )
    }
}

function moveHorLeft(pgraph, nodeId, x, movedNodes) {
    var graph = pgraph.graph;
    var id = nodeId;
    var node;
    while (true) {
        node = graph.getNode(id);
        if (node.right) {
            
        } else {
            break;
        }
        id =graph.getNodeRight(node);
    }
    var delta = x - node.box.right - Config.METRE;
    pgraph.moveRight(
    	id,
    	delta,
    	movedNodes
    );
}

function moveHorLineAway(pgraph, edge, box, movedNodes) {
    var graph = pgraph.graph;
    var id = edge.tail;
    var rightNode;
    while (true) {
        rightNode = graph.getNode(id);
        if (rightNode.right) {
            
        } else {
            break;
        }
        id =graph.getNodeRight(rightNode);
    }
    var delta = box.left - rightNode.box.right;
    pgraph.moveRight(
    	rightNode.id,
    	delta,
    	movedNodes
    );
}

function moveSubgraph(subgraph, insX, insY) {
    var graph = subgraph.graph;
    var dx = insX;
    var first = graph.getNode(subgraph.first);
    var dy = insY + first.h;
    moveGraphBy(graph, dx, dy);
}

function moveToRightFrom(pgraph, sourceEdge, targetEdge, movedNodes) {
    var srcHead = pgraph.graph.getHead(sourceEdge);
    var dstHead = pgraph.graph.getHead(targetEdge);
    moveToRightFromCore(
    	pgraph,
    	srcHead,
    	dstHead,
    	movedNodes
    );
}

function moveToRightFromCore(pgraph, srcHead, dstHead, movedNodes) {
    var srcX = srcHead.x;
    var dstX = dstHead.x;
    var minX = dstX + Config.METRE;
    if (srcX < minX) {
        var delta = minX - srcX;
        pgraph.moveRight(
        	srcHead.id,
        	delta,
        	movedNodes
        );
    }
}

function nextPointBelow(graph, edgeId) {
    var edge = graph.getEdge(edgeId);
    var head = graph.getHead(edge);
    var nextY = head.box.bottom + Config.METRE;
    return new Utils.Point(
    	head.x,
    	nextY
    );
}

function normalizeCommands(commands) {
    var inserts = new Utils.SortedSet()
    var _ind18130 = 0;
    var _col18130 = commands;
    var _len18130 = _col18130.length;
    while (true) {
        if (_ind18130 < _len18130) {
            
        } else {
            break;
        }
        var command = _col18130[_ind18130];
        if (command.type === "insert") {
            inserts.add(command.id, command)
        }
        _ind18130++;
    }
    var deleteIds = {};
    var commands2 = [];
    var _ind18110 = 0;
    var _col18110 = commands;
    var _len18110 = _col18110.length;
    while (true) {
        if (_ind18110 < _len18110) {
            
        } else {
            break;
        }
        var command = _col18110[_ind18110];
        if (command.type === "delete") {
            if (command.id in inserts.set) {
                
            } else {
                commands2.push(command);
            }
            deleteIds[command.id] = true;
        }
        _ind18110++;
    }
    var _ind18154 = 0;
    var _col18154 = commands;
    var _len18154 = _col18154.length;
    while (true) {
        if (_ind18154 < _len18154) {
            
        } else {
            break;
        }
        var command = _col18154[_ind18154];
        if (command.type == "update") {
            var insertCommand = inserts.get(command.id)
            if (insertCommand) {
                Utils.mergeSets(
                	insertCommand.fields,
                	command.fields
                )
            }
        }
        _ind18154++;
    }
    var _ind18117 = 0;
    var _col18117 = commands;
    var _len18117 = _col18117.length;
    while (true) {
        if (_ind18117 < _len18117) {
            
        } else {
            break;
        }
        var command = _col18117[_ind18117];
        if ((command.id in deleteIds) || (command.id in inserts.set)) {
            
        } else {
            commands2.push(command);
        }
        _ind18117++;
    }
    var _ind18171 = 0;
    var _col18171 = inserts.list;
    var _len18171 = _col18171.length;
    while (true) {
        if (_ind18171 < _len18171) {
            
        } else {
            break;
        }
        var id = _col18171[_ind18171];
        if (id in deleteIds) {
            
        } else {
            var insertCommand = inserts.get(id)
            commands2.push(insertCommand);
        }
        _ind18171++;
    }
    return commands2;
}

function normalizeCommands2(commands) {
    var inserts = {}
    var deletes = {}
    var commands2 = []
    var _ind18448 = 0;
    var _col18448 = commands;
    var _len18448 = _col18448.length;
    while (true) {
        if (_ind18448 < _len18448) {
            
        } else {
            break;
        }
        var command = _col18448[_ind18448];
        if (command.type === "insert") {
            inserts[command.id] = true
        } else {
            if (command.type === "delete") {
                deletes[command.id] = true;
            }
        }
        _ind18448++;
    }
    var _ind18438 = 0;
    var _col18438 = commands;
    var _len18438 = _col18438.length;
    while (true) {
        if (_ind18438 < _len18438) {
            
        } else {
            break;
        }
        var command = _col18438[_ind18438];
        if ((command.id in deletes) && (command.id in inserts)) {
            
        } else {
            commands2.push(command);
        }
        _ind18438++;
    }
    return commands2;
}

function onArrow(manFinder, checkPosition) {
    var id = null
    var graph = self.storage.graph
    var ids = getSelection()
    if (ids.length == 0) {
        id = findTopMost(self)
    } else {
        var currentId = ids[0]
        var current = getAnyItem(
        	self.storage,
        	currentId
        );
        if (current.isLine) {
            id = findTopMost(self)
        } else {
            if (current.free) {
                var criteria = function(item) {
                	return checkPosition(item, current)
                }
                id = findClosest(self, current, criteria)
            } else {
                id = manFinder(graph, current)
                if (id) {
                    
                } else {
                    var criteria = function(item) {
                    	return checkPosition(item, current)
                    }
                    id = findClosest(self, current, criteria)
                }
            }
        }
    }
    if (id) {
        selectItem(self, id)
        redraw()
    }
}

function onInnerFloor(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetLeft = graph.getHead(targetEdge);
    var dims = findLedgeFromOrigin(
    	graph,
    	sourceTail.id,
    	targetLeft.id
    );
    var targetX;
    if (dims.x > sourceTail.x) {
        var hDelta = dims.x - sourceTail.x;
        pgraph.moveRight(
        	sourceTail.id,
        	hDelta,
        	movedNodes
        );
        targetX = dims.x;
    } else {
        targetX = sourceTail.x;
    }
    drill(
    	pgraph,
    	targetX,
    	sourceTail.y,
    	targetLeft.y,
    	movedNodes
    );
    var commands = {};
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	target
    );
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var newJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	targetLeft.y,
    	commandList
    );
    var leftBridge = generateId(editor.storage);
    var rightBridge = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	leftBridge,
    	targetEdge.head,
    	newJun,
    	"left"
    );
    pushInsertHorizontal(
    	commandList,
    	rightBridge,
    	newJun,
    	targetEdge.tail,
    	"left"
    );
    return commandList;
}

function onOuterFloor(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetLeft = graph.getHead(targetEdge);
    var target2 = editor.storage.graph.getEdge(
    	target
    );
    var dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetLeft.id
    );
    var targetX;
    if (dims.x > sourceTail.x) {
        var hDelta = dims.x - sourceTail.x;
        pgraph.moveRight(
        	sourceTail.id,
        	hDelta,
        	movedNodes
        );
        targetX = dims.x;
    } else {
        targetX = sourceTail.x;
    }
    drill(
    	pgraph,
    	targetX,
    	sourceTail.y,
    	targetLeft.y,
    	movedNodes
    );
    var commands = {};
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	target
    );
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var newJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	targetLeft.y,
    	commandList
    );
    var leftBridge = generateId(editor.storage);
    var rightBridge = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	leftBridge,
    	targetEdge.head,
    	newJun,
    	target2.role
    );
    pushInsertHorizontal(
    	commandList,
    	rightBridge,
    	newJun,
    	targetEdge.tail,
    	target2.role
    );
    return commandList;
}

function onOuterSilFloor(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var render = editor.render;
    var sGraph = editor.storage.graph;
    var movedNodes = {};
    var commandList = [];
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetLeft = graph.getHead(targetEdge);
    var target2 = sGraph.getEdge(target);
    var dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	targetLeft.id
    );
    var neighbourId = graph.getNodeUp(targetLeft);
    var neighbourHead = sGraph.getNode(neighbourId);
    var addCont = neighbourHead.content;
    var width = getVerticalWidth(
    	sGraph,
    	sourceEdge.head
    );
    var add = fitItemType(
    	render,
    	"address",
    	width,
    	addCont
    )
    var targetX;
    if (dims.x > sourceTail.x) {
        var hDelta = dims.x - sourceTail.x;
        pgraph.moveRight(
        	sourceTail.id,
        	hDelta,
        	movedNodes
        );
        targetX = dims.x;
    } else {
        targetX = sourceTail.x;
    }
    drill(
    	pgraph,
    	targetX,
    	sourceTail.y,
    	targetLeft.y,
    	movedNodes
    );
    pushDeleteEdge(
    	commandList,
    	target
    );
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var h = graph.getNode(sourceEdge.head);
    var addX = h.x;
    var le = graph.getNode(targetEdge.head);
    var addY = le.y - Config.METRE - add.h;
    var commands = {};
    makeHorSpace(
        pgraph,
        addX,
        addY,
        width,
        add.h,
        movedNodes
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList2 = Utils.objectValues(commands);
    commandList = commandList.concat(commandList2);
    var addId = generateId(editor.storage);
    var junId = generateId(editor.storage);
    pushInsertJunction(
    	commandList,
    	junId,
    	addX, le.y
    );
    pushInsertNodeAt(
    	render,
    	commandList,
    	addId,
    	"address",
    	addX, addY,
    	width, add.h,
    	addCont
    );
    connectVer(
    	editor,
    	commandList,
    	sourceEdge.head, addId,
    	"down", null
    );
    connectVer(
    	editor,
    	commandList,
    	addId, junId,
    	null, null
    );
    connectHor(
    	editor,
    	commandList,
    	targetEdge.head, junId,
    	"sil_floor", null
    );
    connectHor(
    	editor,
    	commandList,
    	junId, targetEdge.tail,
    	"sil_floor", null
    );
    return commandList;
}

function paste(x, y) {
    if (ignoreCommand()) {
        
    } else {
        var type = getClipboardType()
        if (type == "free") {
            pasteFree(self, x, y)
        } else {
            var socket = clipTypeToSocket(type)
            if (socket) {
                if (type == "mind") {
                    if (isMind()) {
                        showInsertionSockets(socket)
                    }
                } else {
                    if (isDrakon()) {
                        showInsertionSockets(socket)
                    }
                }
            }
        }
    }
}

function pasteBlock(editor, edgeId) {
    var subgraph = getClipboard("block");
    if (subgraph) {
        subgraph.graph = createGraph(subgraph.graph);
        var count = getIconCount(subgraph.graph);
        if ((canAddMore(editor, count)) && (subgraph)) {
            insertSubgraph(editor, edgeId, subgraph, "paste block");
        }
    }
}

function pasteBranch(editor, nodeId) {
    var render = editor.render;
    var graph = editor.storage.graph;
    var subgraph = getClipboard("branch");
    if (subgraph) {
        addTrace(
        	"paste branch",
        	[nodeId, Utils.copyObject(subgraph)]
        );
        var sgraph = createGraph(subgraph.graph);
        subgraph.graph = sgraph;
        subgraph.pgraph = createPhysicalGraph(
        	subgraph.graph,
        	render
        );
        var leftBranch = graph.getNode(nodeId)
        var leftTop = graph.getNodeUpEx(leftBranch)
        var leftBottom, rightBox = null
        var noEnd = !leftTop.right
        var bTop = sgraph.getNode(subgraph.top);
        var bBottom = sgraph.getNode(subgraph.bottom);
        var rBottom = sgraph.getNode(subgraph.rBottom);
        var leftBox = measureBranch(render, graph, leftTop);
        var subBox = findDiagramBox(subgraph.pgraph.graph);
        if (noEnd) {
            leftBottom = goDownToEnd(graph, leftTop.id)
        } else {
            
            var rightTop = graph.getNodeRightEx(leftTop)
            var rightBottom = goDownToEnd(graph, rightTop.id)
            var isLast = (!rightBottom.left)
            if (isLast) {
                var oldBottom = goDownToEnd(graph, leftTop.id);
                leftBottom = goRightToEnd(graph, oldBottom.id);
            } else {
                leftBottom = graph.getNodeLeftEx(rightBottom);
            }
            rightBox = measureBranch(render, graph, rightTop);
        }
        var mainHeight = leftBottom.y - leftTop.y;
        var subHeight = bBottom.y - bTop.y;
        var pgraph = createPhysicalGraph(
        	graph,
        	render
        );
        var movedNodes = {};
        var lowerNodes = findLowerNodes(sgraph, bBottom);
        var arrowCorner = goLeftToEnd(graph, leftBottom.id);
        var group = arrowCorner.id;
        var yDiff;
        if (mainHeight > subHeight) {
            yDiff = mainHeight - subHeight;
            lowerNodes.forEach(function(node) {
            	node.y += yDiff;
            });
        } else {
            if (mainHeight < subHeight) {
                yDiff = subHeight - mainHeight;
                pgraph.moveDown(
                	leftBottom.id,
                	yDiff,
                	movedNodes
                );
            }
        }
        if (noEnd) {
            
        } else {
            var requiredWidth = subBox.right - subBox.left;
            var actualWidth = rightBox.left - leftBox.right;
            if (requiredWidth > actualWidth) {
                var xDiff = requiredWidth - actualWidth;
                pgraph.moveRight(
                	rightTop.id,
                	xDiff,
                	movedNodes
                );
            }
        }
        var commands = {};
        buildMoveCommands(
        	pgraph,
        	movedNodes,
        	commands
        );
        var commandList = Utils.objectValues(commands);
        if (noEnd) {
            
        } else {
            pushDeleteEdge(
            	commandList,
            	leftTop.right
            );
            if (isLast) {
                
            } else {
                pushDeleteEdge(
                	commandList,
                	leftBottom.right
                );
            }
        }
        var idMap = {};
        idMap[bBottom.group] = group;
        var dx = leftBox.right - subBox.left;
        var dy = leftTop.y;
        moveGraphBy(sgraph, dx, dy);
        addSubgraphItems(
        	editor,
        	subgraph,
        	commandList,
        	idMap
        );
        var newTopId = idMap[subgraph.top];
        var newBottomId = idMap[subgraph.bottom];
        var newRBottomId = idMap[subgraph.rBottom];
        connectHor(
        	editor,
        	commandList,
        	leftTop.id, newTopId,
        	null
        );
        connectHor(
        	editor,
        	commandList,
        	leftBottom.id, newBottomId,
        	"sil_floor"
        );
        if (noEnd) {
            
        } else {
            connectHor(
            	editor,
            	commandList,
            	newTopId, rightTop.id,
            	null
            );
            if (isLast) {
                
            } else {
                connectHor(
                	editor,
                	commandList,
                	newRBottomId, rightBottom.id,
                	"sil_floor"
                );
            }
        }
        applyCommands(
        	editor,
        	commandList,
        	null
        );
    }
}

function pasteCase(editor, nodeId) {
    var payload = getClipboard("case");
    if (payload) {
        insertCase(editor, nodeId, payload.content);
    }
}

function pasteDuration(editor, nodeId) {
    var payload = getClipboard("duration")
    if (payload) {
        insertDuration(editor, nodeId, payload)
    }
}

function pasteFree(editor, x, y) {
    addTrace(
    	"paste free items",
    	[]
    );
    var payload = getClipboard("free")
    if (payload) {
        var items = payload.items
        var left = Number.MAX_VALUE
        var top = Number.MAX_VALUE
        var _ind17193 = 0;
        var _col17193 = items;
        var _len17193 = _col17193.length;
        while (true) {
            if (_ind17193 < _len17193) {
                
            } else {
                break;
            }
            var item = _col17193[_ind17193];
            var box = getBox(item)
            var ix = box.left
            var iy = box.top
            left = Math.min(left, ix)
            top = Math.min(top, iy)
            _ind17193++;
        }
        var oldToNew = {}
        var dx = Utils.snapPos(x - left)
        var dy = Utils.snapPos(y - top)
        var _ind17199 = 0;
        var _col17199 = items;
        var _len17199 = _col17199.length;
        while (true) {
            if (_ind17199 < _len17199) {
                
            } else {
                break;
            }
            var item = _col17199[_ind17199];
            var id = generateId(editor.storage)
            oldToNew[item.id] = id
            item.id = id
            item.x += dx
            item.y += dy
            _ind17199++;
        }
        var commandList = []
        var _ind17206 = 0;
        var _col17206 = items;
        var _len17206 = _col17206.length;
        while (true) {
            if (_ind17206 < _len17206) {
                
            } else {
                break;
            }
            var item = _col17206[_ind17206];
            if (item.next) {
                item.next = oldToNew[item.next]
            }
            commandList.push(new Command(
            	"insert",
            	"free",
            	item.id,
            	item
            ));
            _ind17206++;
        }
        var firstId = items[0].id
        var freeList = editor.storage.free.list
        if (freeList.length == 0) {
            
        } else {
            var last = freeList.length - 1
            var prevId = freeList[last]
            pushUpdate(
            	commandList,
            	"free",
            	prevId,
            	{ next: firstId }
            )
        }
        var ids = Utils.objectValues(oldToNew)
        applyCommands(
        	editor,
        	commandList,
        	ids
        );
    }
}

function pasteInSocket(editor, prim) {
    var _sw134800000_ = 0;
    var socket = prepareSocketOp(editor, prim);
    var graph = editor.storage.graph;
    if (canAddMore(editor, 2)) {
        var target = graph.getItem(socket.id);
        if (downRole(target)) {
            if (socket.action == "block") {
                pasteBlock(editor, socket.id);
            }
        } else {
            if (target.isVertical) {
                var below = graph.getNode(target.tail);
                if ((below.type == socket.action) && (below.type == "case")) {
                    pasteCase(editor, below.id);
                }
            } else {
                var branch = getBranchForEdge(graph, target);
                if ((branch) && (branch.type == socket.action)) {
                    _sw134800000_ = socket.action;
                    if (_sw134800000_ === "case") {
                        pasteCase(editor, branch.id);
                    } else {
                        if (_sw134800000_ === "branch") {
                            pasteBranch(editor, branch.id);
                        }
                    }
                } else {
                    if (socket.action == "duration") {
                        pasteDuration(editor, socket.id);
                    } else {
                        pasteBlock(editor, socket.id);
                    }
                }
            }
        }
    }
}

function pasteMind(x, y, actions) {
    var menu = []
    var subtree = getClipboard("mind")
    if (subtree) {
        var _ind21921 = 0;
        var _col21921 = actions;
        var _len21921 = _col21921.length;
        while (true) {
            if (_ind21921 < _len21921) {
                
            } else {
                break;
            }
            var action = _col21921[_ind21921];
            addMindPasteAction(action, subtree, menu)
            _ind21921++;
        }
        showContextMenu(x, y - 30, menu)
    }
}

function pasteText(editor, nodeId) {
    var clip = getClipboard("text");
    if (clip) {
        var text = ""
        if (clip.content) {
            text = clip.content.txt || ""
        }
        var item = getAnyItem(editor.storage, nodeId)
        var old = getContent(item)
        var newContent = setContentTxt(
        	old,
        	text
        )
        setItemText(editor, nodeId, newContent);
    }
}

function performChange(editor, command, isUndo) {
    var _sw14890000_ = 0;
    var _sw14970000_ = 0;
    var _sw166740000_ = 0;
    var _sw15080000_ = 0;
    var storage = editor.storage;
    _sw14890000_ = command.table;
    if (_sw14890000_ === "diagrams") {
        updateDiagram(
        	storage,
        	command,
        	isUndo
        );
    } else {
        if (_sw14890000_ === "nodes") {
            _sw14970000_ = command.type;
            if (_sw14970000_ === "insert") {
                runItemInsert(
                	editor, 
                	command,
                	isUndo
                );
            } else {
                if (_sw14970000_ === "update") {
                    runNodeUpdate(
                    	editor, 
                    	command,
                    	isUndo
                    );
                } else {
                    if (_sw14970000_ === "delete") {
                        
                    } else {
                        throw "Unexpected switch value: " + _sw14970000_;
                    }
                    runItemDelete(
                    	storage, 
                    	command,
                    	isUndo
                    );
                }
            }
        } else {
            if (_sw14890000_ === "free") {
                _sw166740000_ = command.type;
                if (_sw166740000_ === "insert") {
                    runFreeInsert(
                    	editor, 
                    	command,
                    	isUndo
                    );
                } else {
                    if (_sw166740000_ === "update") {
                        runFreeUpdate(
                        	editor, 
                        	command,
                        	isUndo
                        );
                    } else {
                        if (_sw166740000_ === "delete") {
                            
                        } else {
                            throw "Unexpected switch value: " + _sw166740000_;
                        }
                        runFreeDelete(
                        	storage, 
                        	command,
                        	isUndo
                        );
                    }
                }
            } else {
                if (_sw14890000_ === "edges") {
                    
                } else {
                    throw "Unexpected switch value: " + _sw14890000_;
                }
                _sw15080000_ = command.type;
                if (_sw15080000_ === "insert") {
                    runItemInsert(
                    	editor, 
                    	command,
                    	isUndo
                    );
                } else {
                    if (_sw15080000_ === "delete") {
                        
                    } else {
                        throw "Unexpected switch value: " + _sw15080000_;
                    }
                    runItemDelete(
                    	storage, 
                    	command,
                    	isUndo
                    );
                }
            }
        }
    }
}

function performLocalChange(editor, commands, isUndo) {
    var count = commands.length;
    var i;
    if (isUndo) {
        i = count - 1;
        while (true) {
            if (i >= 0) {
                
            } else {
                break;
            }
            performChange(editor, commands[i], true);
            i--;
        }
    } else {
        i = 0;
        while (true) {
            if (i < count) {
                
            } else {
                break;
            }
            performChange(editor, commands[i], false);
            i++;
        }
    }
}

function performRedo() {
    if (ignoreCommand()) {
        
    } else {
        var undo = self.undo;
        if (undo.next >= undo.steps.length) {
            
        } else {
            var step = undo.steps[undo.next];
            addTrace("redo", step.info)
            executeCommands(
            	self,
            	step.commands,
            	step.after,
            	false,
            	true
            );
            persistChanges(step.commands, false)
            undo.next++;
        }
    }
}

function performUndo() {
    if (ignoreCommand()) {
        
    } else {
        var undo = self.undo;
        if (undo.next > 0) {
            undo.next--;
            var step = undo.steps[undo.next];
            addTrace("undo", step.info)
            executeCommands(
            	self,
            	step.commands,
            	step.before,
            	true,
            	true
            );
            persistChanges(step.commands, true)
        }
    }
}

function persistAndRedraw(editor, state, redraw) {
    var storage = editor.storage;
    var error = storage.graph.checkEdges();
    if (error) {
        Utils.throwError(error);
    } else {
        error = rebuildFree(editor)
        if (error) {
            Utils.throwError(error);
        } else {
            if (redraw) {
                restoreState(editor, state);
                buildTextBoxes()
                redrawCanvas(editor);
            }
        }
    }
}

function persistChange(pers, command, isUndo) {
    var _sw231280000_ = 0;
    var _sw231360000_ = 0;
    _sw231280000_ = command.table;
    if (_sw231280000_ === "diagrams") {
        var fields
        if (isUndo) {
            fields = command.undo
        } else {
            fields = command.fields
        }
        pers.updateDiagram(fields)
    } else {
        _sw231360000_ = command.type;
        if (_sw231360000_ === "insert") {
            if (isUndo) {
                pers.remove(command.id);
            } else {
                var item = copyStorageItem(command.fields);
                item.id = command.id;
                pers.add(item);
            }
        } else {
            if (_sw231360000_ === "update") {
                var fields;
                if (isUndo) {
                    fields = command.undo;
                } else {
                    fields = command.fields;
                }
                fields.id = command.id;
                pers.update(fields);
            } else {
                if (_sw231360000_ === "delete") {
                    
                } else {
                    throw "Unexpected switch value: " + _sw231360000_;
                }
                if (isUndo) {
                    var item = copyStorageItem(command.undo);
                    item.id = command.id;
                    pers.add(item);
                } else {
                    pers.remove(command.id);
                }
            }
        }
    }
}

function persistChanges(commands, isUndo) {
    var pers = self.storage.persistence
    var _ind23219 = 0;
    var _col23219 = commands;
    var _len23219 = _col23219.length;
    while (true) {
        if (_ind23219 < _len23219) {
            
        } else {
            break;
        }
        var command = _col23219[_ind23219];
        persistChange(
        	pers,
        	command,
        	isUndo
        )
        _ind23219++;
    }
    pers.persist()
}

function planDeleteCase(graph, node, plan) {
    var junId = graph.getNodeUp(node);
    var jun = graph.getNode(junId);
    var firstId = graph.getNodeDown(node);
    if (jun.right) {
        pokeHor(graph, jun, plan);
    } else {
        plan.edges[jun.left] = true;
        plan.nodes[junId] = true;
    }
    plan.edges[node.up] = true;
    planDeleteMain(graph, node.id, plan);
}

function planDeleteCases(graph, nodeId, plan) {
    var joints = getSelectJoints(
    	graph,
    	nodeId
    );
    var count = joints.length;
    var i;
    i = count - 1;
    while (true) {
        if (i > 0) {
            
        } else {
            break;
        }
        var joint = joints[i];
        plan.nodes[joint.id] = true;
        plan.edges[joint.left] = true;
        plan.edges[joint.down] = true;
        var caseId = graph.getNodeDown(joint);
        planDeleteMain(graph, caseId, plan);
        i--;
    }
}

function planDeleteLoop(graph, node, plan) {
    pokeVer(graph, node, plan);
    var lowId = Drakon.findEndLoop(graph, node);
    if (lowId) {
        var low = graph.getNode(lowId);
        plan.mainDeletes.push(lowId);
        pokeVer(graph, low, plan);
    }
}

function planDeleteLoopEnd(graph, node, plan) {
    pokeVer(graph, node, plan);
    var upId = Drakon.findBeginLoop(graph, node);
    if (upId) {
        var up = graph.getNode(upId);
        plan.mainDeletes.push(upId);
        pokeVer(graph, up, plan);
    }
}

function planDeleteMain(graph, nodeId, plan) {
    var _sw57040000_ = 0;
    var node = graph.getNode(nodeId);
    if (node.down) {
        var downId = graph.getNodeDown(node);
        _sw57040000_ = node.type;
        if (_sw57040000_ === "question") {
            plan.nodes[nodeId] = true;
            plan.edges[node.down] = true;
            makeSecDeletionPlan(graph, node.right, plan);
            planDeleteMain(graph, downId, plan);
        } else {
            if (_sw57040000_ === "select") {
                var down = graph.getNode(downId);
                var caseId = graph.getNodeDown(down);
                plan.nodes[nodeId] = true;
                plan.nodes[downId] = true;
                plan.edges[node.down] = true;
                plan.edges[down.down] = true;
                planDeleteCases(graph, nodeId, plan);
                planDeleteMain(graph, caseId, plan);
            } else {
                if (_sw57040000_ === "junction") {
                    var jType = describeJunction(node);
                    if (jType === "left-t") {
                        var leftId = graph.getNodeLeft(node);
                        var left = graph.getNode(leftId);
                        if (left.type === "question") {
                            plan.stairs[nodeId] = true;
                        } else {
                            plan.nodes[nodeId] = true;
                            plan.edges[node.down] = true;
                            planDeleteMain(graph, downId, plan);
                        }
                    } else {
                        plan.nodes[nodeId] = true;
                        plan.edges[node.down] = true;
                        planDeleteMain(graph, downId, plan);
                    }
                } else {
                    plan.nodes[nodeId] = true;
                    plan.edges[node.down] = true;
                    planDeleteMain(graph, downId, plan);
                }
            }
        }
    } else {
        plan.nodes[nodeId] = true;
        planDeleteSkewerEnd(
        	graph,
        	node,
        	plan
        );
    }
}

function planDeleteQuestion(graph, node, plan) {
    var rightId =graph.getNodeRight(node);
    var right = graph.getNode(rightId);
    var rightType = describeJunction(right);
    pokeVer(graph, node, plan);
    plan.edges[node.right] = true;
    if (rightType === "left-t") {
        pokeVer(graph, right, plan);
    } else {
        if (rightType === "left-down") {
            plan.nodes[rightId] = true;
            plan.edges[right.down] = true;
            var downId = graph.getNodeDown(right);
            planDeleteMain(graph, downId, plan, true);
        } else {
            if (rightType === "left-up") {
                
            } else {
                throw "Unexpected switch value: " + rightType;
            }
            var right = graph.getNode(rightId);
            deleteArrow(graph, right, plan);
        }
    }
}

function planDeleteSelect(graph, node, plan) {
    var junId = graph.getNodeDown(node);
    var jun = graph.getNode(junId);
    var caseId = graph.getNodeDown(jun);
    var caseNode = graph.getNode(caseId);
    plan.mainDeletes.push(caseId);
    pokeVer(graph, node, plan);
    pokeVer(graph, jun, plan);
    pokeVer(graph, caseNode, plan);
    planDeleteCases(graph, node.id, plan);
}

function planDeleteSkewerEnd(graph, node, plan) {
    if (node.type === "junction") {
        if (node.left) {
            if (node.right) {
                var rightId =graph.getNodeRight(node);
                if (hasNodesOnRight(graph, rightId, plan)) {
                    pokeHor(
                    	graph,
                    	node,
                    	plan
                    );
                } else {
                    var leftId = graph.getNodeLeft(node);
                    var left = graph.getNode(leftId);
                    plan.edges[node.left] = true;
                    pokeVer(graph, left, plan);
                }
            } else {
                var leftId = graph.getNodeLeft(node);
                var left = graph.getNode(leftId);
                plan.edges[node.left] = true;
                pokeVer(graph, left, plan);
            }
        } else {
            if (node.right) {
                var rightId =graph.getNodeRight(node);
                var right = graph.getNode(rightId);
                var rightEdge = graph.getEdge(node.right);
                plan.edges[node.right] = true;
                if (isArrowStart(graph, right)) {
                    deleteArrow(graph, right, plan);
                } else {
                    if (rightEdge.role === "right") {
                        deleteRight(
                        	graph,
                        	right,
                        	plan
                        );
                    } else {
                        pokeVer(graph, right, plan);
                    }
                }
            }
        }
    }
}

function pokeHor(graph, node, plan) {
    pokeOut(
    	graph,
    	node,
    	plan,
    	"left",
    	"right",
    	plan.horHoles
    );
}

function pokeOut(graph, node, plan, upProp, downProp, holes) {
    var id = node.id;
    var up = node[upProp];
    var down = node[downProp];
    if ((up) && (down)) {
        plan.nodes[id] = true;
        plan.edges[up] = true;
        plan.edges[down] = true;
        var headId = graph.getEdge(up).head;
        var tailId = graph.getEdge(down).tail;
        holes[id] = {
        	up: headId,
        	down: tailId,
        	dir: upProp
        };
    }
}

function pokeVer(graph, node, plan) {
    pokeOut(
    	graph,
    	node,
    	plan,
    	"up",
    	"down",
    	plan.verHoles
    );
}

function postEdit(commands) {
    var edit = {
    	dirty: false,
    	commands: commands
    }
    sameBranchHeight(edit)
    sameAddressHeight(edit)
    autoCycleMarks(edit)
    persistChanges(
    	edit.commands,
    	false
    )
    if (edit.dirty) {
        buildTextBoxes()
        redrawCanvas(self)
    }
    return edit.commands
}

function prepareSocketOp(editor, prim) {
    var socket = editor.canvas.sockets[prim];
    deselectAll(editor);
    redrawCanvas(editor);
    editor.dirty = true;
    return socket;
}

function probeDeleteItem(graph, node, visited) {
    var _sw88420000_ = 0;
    var downId, down;
    var canRight;
    if (node.id in visited) {
        return true;
    } else {
        visited[node.id] = true;
        _sw88420000_ = node.type;
        if ((_sw88420000_ === "beginend") || (_sw88420000_ === "end")) {
            return true;
        } else {
            if (_sw88420000_ === "junction") {
                return probeDeleteJunction(
                	graph,
                	node,
                	visited
                );
            } else {
                if (_sw88420000_ === "question") {
                    canRight = probeDeleteQuestion(
                    	graph,
                    	node,
                    	visited
                    );
                    if (canRight) {
                        downId = graph.getNodeDown(node);
                        down = graph.getNode(downId);
                        return probeDeleteItem(graph, down, visited);
                    } else {
                        return false;
                    }
                } else {
                    if (_sw88420000_ === "select") {
                        canRight = probeDeleteSelect(
                        	graph,
                        	node,
                        	visited
                        );
                        if (canRight) {
                            var junId = graph.getNodeDown(node);
                            var jun = graph.getNode(junId);
                            downId = graph.getNodeDown(jun);
                            down = graph.getNode(downId);
                            return probeDeleteItem(graph, down, visited);
                        } else {
                            return false;
                        }
                    } else {
                        if (node.down) {
                            downId = graph.getNodeDown(node);
                            down = graph.getNode(downId);
                            return probeDeleteItem(graph, down, visited);
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
    }
}

function probeDeleteJunction(graph, node, visited) {
    var type = describeJunction(node);
    if (type === "right-t") {
        var rightId =graph.getNodeRight(node);
        if (rightId in visited) {
            if (node.down) {
                var downId = graph.getNodeDown(node);
                var down = graph.getNode(downId);
                return probeDeleteItem(graph, down, visited);
            } else {
                return true;
            }
        } else {
            var edge = graph.getEdge(node.right);
            if (edge.role === "arrow") {
                if (node.down) {
                    var downId = graph.getNodeDown(node);
                    var down = graph.getNode(downId);
                    return probeDeleteItem(graph, down, visited);
                } else {
                    return true;
                }
            } else {
                return false;
            }
        }
    } else {
        if (node.down) {
            var downId = graph.getNodeDown(node);
            var down = graph.getNode(downId);
            return probeDeleteItem(graph, down, visited);
        } else {
            return true;
        }
    }
}

function probeDeleteQuestion(graph, node, visited) {
    var rightId =graph.getNodeRight(node);
    var right = graph.getNode(rightId);
    if (((right.down) && (!(right.up))) && (!(probeDeleteItem(graph, right, visited)))) {
        return false;
    } else {
        return true;
    }
}

function probeDeleteSelect(graph, node, visited) {
    var joints = getSelectJoints(graph, node.id);
    var i;
    i = joints.length - 1;
    while (true) {
        if (i > 0) {
            
        } else {
            return true;
        }
        var joint = joints[i];
        var downId = graph.getNodeDown(joint);
        var down = graph.getNode(downId);
        var can = probeDeleteItem(
        	graph,
        	down,
        	visited
        );
        if (can) {
            
        } else {
            return false;
        }
        i--;
    }
}

function pullDownSkewerItem(graph, itemIds, result) {
    var _ind21071 = 0;
    var _col21071 = itemIds;
    var _len21071 = _col21071.length;
    while (true) {
        if (_ind21071 < _len21071) {
            
        } else {
            break;
        }
        var itemId = _col21071[_ind21071];
        var item = graph.getItem(itemId);
        result.add(item.id)
        if (item.type == "junction") {
            if (item.up) {
                var above = graph.getNodeUpEx(item)
                if (above.role == "header") {
                    result.add(above.id)
                }
            }
        } else {
            if (item.role == "sub") {
                var above = graph.getNodeUpEx(item)
                var bridge = graph.getHorizontal(
                	above.id
                )
                pullDownSkewerItem(
                	graph,
                	bridge,
                	result
                )
                break;
            }
        }
        _ind21071++;
    }
}

function pushAside(pgraph, node, x, movedNodes) {
    var delta;
    if ((node.x < x) && (!(node.type == "duration"))) {
        delta = x - node.box.right - Config.METRE;
    } else {
        delta = x - node.box.left + Config.METRE;
    }
    pgraph.moveRight(
    	node.id,
    	delta,
    	movedNodes
    );
}

function pushDeleteArrow(editor, graph, rightBottom, commandList) {
    var rightTopId = graph.getNodeUp(rightBottom);
    var rightTop = graph.getNode(rightTopId);
    var leftTopId = graph.getNodeLeft(rightTop);
    var leftTop = graph.getNode(leftTopId);
    pushDeleteEdge(
    	commandList,
    	rightBottom.up
    );
    pushDeleteEdge(
    	commandList,
    	rightTop.left
    );
    pushDeleteNode(
    	commandList,
    	rightBottom.id
    );
    pushDeleteNode(
    	commandList,
    	rightTopId
    );
    deleteJunctionBetween(
    	editor,
    	graph,
    	leftTop,
    	commandList
    );
}

function pushDeleteEdge(commandList, id) {
    var deleteUp = new Command(
    	"delete",
    	"edges",
    	id,
    	null
    );
    commandList.push(deleteUp);
}

function pushDeleteNode(commandList, id) {
    var deleteDown = new Command(
    	"delete",
    	"nodes",
    	id,
    	null
    );
    commandList.push(deleteDown);
}

function pushDeleteNodeEx(graph, commandList, id) {
    var node = graph.getNode(id);
    var duration = Drakon.getDuration(graph, node);
    if (duration) {
        pushDeleteEdge(
        	commandList,
        	node.left
        );
        pushDeleteNode(
        	commandList,
        	duration.id
        );
    }
    pushDeleteNode(
    	commandList,
    	id
    );
}

function pushDeleteSubgraph(commList, nodes, edges) {
    var _ind10777 = 0;
    var _col10777 = edges;
    var _keys10777 = Object.keys(_col10777); 
    var _len10777 = _keys10777.length;
    while (true) {
        if (_ind10777 < _len10777) {
            
        } else {
            break;
        }
        var edgeId = _keys10777[_ind10777]; var _ = _col10777[edgeId];
        pushDeleteEdge(
        	commList,
        	edgeId
        );
        _ind10777++;
    }
    var _ind10775 = 0;
    var _col10775 = nodes;
    var _keys10775 = Object.keys(_col10775); 
    var _len10775 = _keys10775.length;
    while (true) {
        if (_ind10775 < _len10775) {
            
        } else {
            break;
        }
        var nodeId = _keys10775[_ind10775]; var _ = _col10775[nodeId];
        pushDeleteNode(
        	commList,
        	nodeId
        );
        _ind10775++;
    }
}

function pushInsertDown(commandList, edgeId, up, down) {
    pushInsertVertical(
    	commandList,
    	edgeId,
    	up,
    	down,
    	"down"
    );
}

function pushInsertFree(render, commandList, id, type, x, y, w, h, content) {
    var item = makeDummyItem(
    	1,
    	render,
    	type,
    	content
    )
    var fit = Drakon.fitItem(item, render)
    var fields = {
    	id: id,
    	type: type,
    	free: true,
    	x: x,
    	y: y,
    	w: w,
    	h: h,
    	a: fit.a,
    	tb: fit.tb,
    	tb2: fit.tb2,
    	content: content
    };
    commandList.push(new Command(
    	"insert",
    	"free",
    	id,
    	fields
    ));
}

function pushInsertHorizontal(commandList, edgeId, up, down, role) {
    var newEdge = new Command(
    	"insert",
    	"edges",
    	edgeId,
    	{
    		type: "horizontal",
    		isVertical: false,
    		isLine: true,
    		head: up,
    		tail: down,
    		role: role
    	}
    );
    commandList.push(newEdge);
}

function pushInsertJunction(commList, id, x, y) {
    var node = {
    	type: "junction",
    	x: x,
    	y: y,
    	w: 0,
    	h: 0
    };
    pushInsertNode(
    	commList,
    	id,
    	node
    );
}

function pushInsertNode(commandList, id, node) {
    var fields = 	{
    	type: node.type,
    	isLine: false,
    	x: node.x,
    	y: node.y,
    	w: node.w,
    	h: node.h,
    	a: node.a,
    	content: node.content,
    	flag1: node.flag1,
    	role: node.role
    };
    if (node.tb) {
        fields.tb = node.tb;
    }
    if (node.tb2) {
        fields.tb2 = node.tb2;
    }
    commandList.push(new Command(
    	"insert",
    	"nodes",
    	id,
    	fields
    ));
}

function pushInsertNodeAt(render, commandList, id, type, x, y, w, h, content) {
    var node = {
    	id: id,
    	type: type,
    	x: x,
    	y: y,
    	w: w,
    	h: h,
    	content: content
    };
    adjustFontSize(node)
    var size = Drakon.fitItem(node, render);
    setItemDims(node, size);
    pushInsertNode(
    	commandList,
    	id,
    	node
    );
}

function pushInsertVertical(commandList, edgeId, up, down, role) {
    var newEdge = new Command(
    	"insert",
    	"edges",
    	edgeId,
    	{
    		type: "vertical",
    		isVertical: true,
    		isLine: true,
    		head: up,
    		tail: down,
    		role: role
    	}
    );
    commandList.push(newEdge);
}

function pushLedgeLeft(pgraph, startNodeId, endNodeId, x, movedNodes) {
    var graph = pgraph.graph;
    var wall = scanLeftWall(
    	graph,
    	startNodeId,
    	endNodeId
    );
    var _ind4788 = 0;
    var _col4788 = wall.nodes;
    var _len4788 = _col4788.length;
    while (true) {
        if (_ind4788 < _len4788) {
            
        } else {
            break;
        }
        var id = _col4788[_ind4788];
        var node = graph.getNode(id);
        var delta = x - node.x - Config.METRE;
        if (delta < 0) {
            pgraph.moveRight(
            	id,
            	delta,
            	movedNodes
            );
        }
        _ind4788++;
    }
    return wall.lowest;
}

function pushUpdate(commandList, table, id, fields) {
    commandList.push(new Command(
    	"update",
    	table,
    	id,
    	fields
    ));
}

function pushUpdateDiagram(commandList, name) {
    var fields = {
    	name: name
    };
    commandList.push(new Command(
    	"update",
    	"diagrams",
    	"diagram",
    	fields
    ));
}

function questionOnLeft(graph, node) {
    var leftNodeId = graph.getNodeLeft(node);
    var leftNode = graph.getNode(leftNodeId);
    if (leftNode.type == "question") {
        return true;
    } else {
        return false;
    }
}

function rayTraceDown(pgraph, x, y, y2, movedNodes) {
    var graph = pgraph.graph;
    var end = y2 + Config.METRE;
    var top = Math.floor(y + Config.METRE / 2);
    var bottom = y;
    var left = x - 1;
    var right = x + Config.METRE;
    while (true) {
        bottom += Config.METRE;
        if (bottom >= end) {
            break;
        }
        
        var needle = new Utils.Box(left, top, right, bottom);
        var _ind6462 = 0;
        var _col6462 = graph.items;
        var _keys6462 = Object.keys(_col6462); 
        var _len6462 = _keys6462.length;
        while (true) {
            if (_ind6462 < _len6462) {
                
            } else {
                break;
            }
            var iid = _keys6462[_ind6462]; var item = _col6462[iid];
            if ((Utils.boxesIntersect(needle, item.box)) && (!(item.isVertical))) {
                if (item.isLine) {
                    pgraph.moveDown(
                    	item.tail,
                    	Config.METRE,
                    	movedNodes
                    );
                    break;
                }
                if (item.x == x) {
                    
                } else {
                    pushAside(
                    	pgraph,
                    	item,
                    	x,
                    	movedNodes
                    );
                    break;
                }
            }
            _ind6462++;
        }
    }
}

function rayTraceDownEx(pgraph, x, y, y2, topNodeId, movedNodes) {
    var graph = pgraph.graph;
    var end = y2 + Config.METRE;
    var top = Math.floor(y + Config.METRE / 2);
    var bottom = y;
    var left = x - 1;
    var right = x + 1;
    var probe = new Utils.Box(left, top, right, end);
    var x2 = x;
    var _ind6530 = 0;
    var _col6530 = graph.nodes;
    var _keys6530 = Object.keys(_col6530); 
    var _len6530 = _keys6530.length;
    while (true) {
        if (_ind6530 < _len6530) {
            
        } else {
            break;
        }
        var nid = _keys6530[_ind6530]; var node = _col6530[nid];
        if (((node.x > x) || (node.type == "duration")) && (Utils.boxesIntersect(node.box, probe))) {
            var leftEdge = node.box.left - Config.METRE;
            if (leftEdge < x2) {
                x2 = leftEdge;
            }
        }
        _ind6530++;
    }
    if (x2 == x) {
        
    } else {
        var delta = x2 - x;
        pgraph.moveRight(
        	topNodeId,
        	delta,
        	movedNodes
        );
    }
    left = x2 - 1;
    right = x2 + 1;
    while (true) {
        bottom += Config.METRE;
        if (bottom >= end) {
            break;
        }
        
        var needle = new Utils.Box(left, top, right, bottom);
        var _ind6547 = 0;
        var _col6547 = graph.items;
        var _keys6547 = Object.keys(_col6547); 
        var _len6547 = _keys6547.length;
        while (true) {
            if (_ind6547 < _len6547) {
                
            } else {
                break;
            }
            var iid = _keys6547[_ind6547]; var item = _col6547[iid];
            if ((Utils.boxesIntersect(needle, item.box)) && (!(item.isVertical))) {
                if (item.isLine) {
                    if (item.role == "lstick") {
                        
                    } else {
                        moveHorLeft(
                        	pgraph,
                        	item.tail,
                        	x2,
                        	movedNodes
                        );
                    }
                    break;
                }
                if (item.x == x2) {
                    
                } else {
                    pushAside(
                    	pgraph,
                    	item,
                    	x2,
                    	movedNodes
                    );
                    break;
                }
            }
            _ind6547++;
        }
    }
}

function rayTraceRight(pgraph, x, x2, y, movedNodes) {
    var graph = pgraph.graph;
    var end = x2 + Config.METRE;
    var left = Math.floor(x + Config.METRE / 2);
    var right = x;
    var top = y - Config.METRE + 1;
    var bottom = y + 1;
    while (true) {
        right += Config.SNAP;
        
        var needle = new Utils.Box(left, top, right, bottom);
        var _ind6415 = 0;
        var _col6415 = graph.items;
        var _keys6415 = Object.keys(_col6415); 
        var _len6415 = _keys6415.length;
        while (true) {
            if (_ind6415 < _len6415) {
                
            } else {
                break;
            }
            var iid = _keys6415[_ind6415]; var item = _col6415[iid];
            var id;
            if (item.isLine) {
                id = item.tail;
                if (item.isVertical) {
                    if (Utils.boxesIntersect(needle, item.box)) {
                        pgraph.moveRight(
                        	id,
                        	Config.SNAP,
                        	movedNodes
                        );
                        break;
                    }
                }
            } else {
                id = item.id;
                if (Utils.boxesIntersect(needle, item.box)) {
                    pgraph.moveRight(
                    	id,
                    	Config.SNAP,
                    	movedNodes
                    );
                    break;
                }
            }
            _ind6415++;
        }
        if (right >= end) {
            break;
        }
    }
}

function rebuildFree(editor) {
    var oldFree = editor.storage.free
    var newFree = new Utils.SortedSet()
    var error = copyAndSort(
    	oldFree.set,
    	newFree
    )
    if (error) {
        return error
    } else {
        editor.storage.free = newFree
        return null
    }
}

function rebuildGrips(editor, ids) {
    editor.grips = []
    var freeGrips = []
    var idList = Object.keys(ids)
    var _ind16339 = 0;
    var _col16339 = idList;
    var _len16339 = _col16339.length;
    while (true) {
        if (_ind16339 < _len16339) {
            
        } else {
            break;
        }
        var id = _col16339[_ind16339];
        addDrnGrips(editor, id, freeGrips)
        _ind16339++;
    }
    var moveAll = findGripAllPoint(freeGrips)
    if (moveAll) {
        var itemId = null
        if (idList.length == 1) {
            itemId = idList[0]
        }
        addGrip(
        	editor.grips,
        	itemId,
        	moveAll.x,
        	moveAll.y,
        	Const.DRN_MOVE_ALL,
        	{}
        );
    }
    gMoveAllPos = moveAll
}

function rebuildPhysicsCache(pgraph) {
    //var expanders = getSoftExpanders();
    pgraph.rebuildCache();
}

function recalculateNextId(storage) {
    var graphId = storage.graph.getMaxId()
    var freeId = storage.free.getMaxId()
    storage.nextId = Math.max(graphId, freeId) + 1
}

function recordDimension(node, result) {
    var box = node.box;
    var right = box.right;
    var bottom  = box.bottom;
    if (right > result.x) {
        result.x = right;
    }
    if (bottom > result.y) {
        result.y = bottom;
        result.lowId = node.id;
    }
}

function redraw() {
    redrawCanvas(self);
}

function redrawCanvas(editor) {
    try {
    	redrawCanvasCore(editor, null)
    } catch (ex) {
    	CallTrace.error(ex)
    	throw ex
    }
}

function redrawCanvasCore(editor, insertionSocket) {
    editor.render.clear();
    editor.canvas = new CanvasCache(editor.render);
    var graph = editor.storage.graph;
    editor.render.setBackground(
    	editor.storage.background
    )
    Items.setDiaLine(
    	editor.storage.diaLine,
    	editor.storage.diaLineThickness
    )
    drawBasicItems(
    	editor.storage,
    	editor.canvas
    )
    var ids = getSelectedIds(editor);
    rebuildGrips(editor, ids);
    Items.drawCandies(
    	editor.canvas.graph,
    	editor.canvas.free,
    	editor.render,
    	ids
    );
    drawMoveAll(editor.render)
    var selected = getSelectedItem(editor);
    var sockets;
    if (selected) {
        if (isMind()) {
            
        } else {
            buildSideMarks(editor.canvas);
        }
        sockets = buildSockets(
        	editor,
        	editor.canvas.graph, 
        	selected
        );
    } else {
        if (insertionSocket) {
            if (isMindSocket(insertionSocket)) {
                sockets = buildMindSockets(
                	editor.canvas.graph,
                	insertionSocket
                )
            } else {
                sockets = buildInsertionSockets(
                	editor.canvas.graph,
                	insertionSocket
                );
            }
        } else {
            sockets = [];
        }
    }
    var _ind10861 = 0;
    var _col10861 = sockets;
    var _len10861 = _col10861.length;
    while (true) {
        if (_ind10861 < _len10861) {
            
        } else {
            break;
        }
        var socket = _col10861[_ind10861];
        insertCanvasSocket(editor.canvas, socket);
        _ind10861++;
    }
    editor.canvas.pgraph.rebuildCache();
}

function rememberFont(item, fonts) {
    var content = item.content
    if (content) {
        var font = content.font
        if (font) {
            fonts[font] = true
        }
    }
}

function removeFormat(content) {
    var copy = Utils.copyObject(content)
    var _ind17963 = 0;
    var _col17963 = gFormatNames;
    var _len17963 = _col17963.length;
    while (true) {
        if (_ind17963 < _len17963) {
            
        } else {
            break;
        }
        var name = _col17963[_ind17963];
        delete copy[name]
        _ind17963++;
    }
    copy.font = Utils.buildFontString(
    	false,
    	false,
    	Config.FONT_SIZE,
    	Config.FONT_FAMILY
    )
    return copy
}

function renameBranch(editor, id, cont) {
    var graph = editor.storage.graph;
    var node = graph.getNode(id);
    var oldCont = node.content;
    var addresses = findManyNodesBy(
    	graph,
    	"type",
    	"address"
    );
    var ids = [id];
    var _ind10376 = 0;
    var _col10376 = addresses;
    var _len10376 = _col10376.length;
    while (true) {
        if (_ind10376 < _len10376) {
            
        } else {
            break;
        }
        var address = _col10376[_ind10376];
        if (contEqual(address.content, oldCont)) {
            ids.push(address.id);
        }
        _ind10376++;
    }
    setTextForManyItems(editor, ids, cont);
}

function renameDiagram(name) {
    var graph = self.storage.graph
    var _ind16635 = 0;
    var _col16635 = graph.nodes;
    var _keys16635 = Object.keys(_col16635); 
    var _len16635 = _keys16635.length;
    while (true) {
        if (_ind16635 < _len16635) {
            
        } else {
            var commList = []
            pushUpdateDiagram(commList, name);
            submitCommands(self, commList, true)
            break;
        }
        var id = _keys16635[_ind16635]; var node = _col16635[id];
        if (node.role == "header") {
            var old = getContent(node)
            var content = setContentTxt(old, name)
            setItemText(self, id, content)
            break;
        }
        _ind16635++;
    }
}

function replaceExit(render, bgraph, graph2) {
    var node
    var _ind19733 = 0;
    var _col19733 = bgraph.nodes;
    var _keys19733 = Object.keys(_col19733); 
    var _len19733 = _keys19733.length;
    while (true) {
        if (_ind19733 < _len19733) {
            
        } else {
            break;
        }
        var id = _keys19733[_ind19733]; var _ = _col19733[id];
        node = graph2.getNode(id)
        if (node.type == "end") {
            var top = graph2.getNode(bgraph.top)
            var branch = graph2.getNodeDownEx(top)
            node.type = "address"
            node.w = branch.w
            node.h = branch.h
            node.content = Utils.copyObject(branch.content)
            node.y += node.h
            var y = node.y + node.h + Config.METRE
            var jun = makeDummyJunction(
            	"jun01",
            	node.x,
            	y
            )
            graph2.addItem(jun)
            addDummyLine(
            	graph2,
            	"line01",
            	true,
            	node.id,
            	"jun01",
            	null
            )
            bgraph.bottom = "jun01"
            bgraph.rBottom = "jun01"
            break;
        }
        _ind19733++;
    }
}

function restoreState(editor, state) {
    editor.storage.selection = copySelection(
    	state.selection
    );
}

function rightCorner(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var y;
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetNode = graph.getNode(target);
    extendEdge(
    	pgraph,
    	source,
    	0,
    	movedNodes
    );
    var dims = findLedgeFromOrigin(
    	graph,
    	target,
    	sourceTail.id
    );
    var sourceY = sourceTail.box.top - Config.METRE;
    if (sourceY < dims.y) {
        var vDelta = dims.y - sourceY;
        var bottom = sourceTail.y + vDelta;
        dropDown(
        	pgraph,
        	sourceTail,
        	bottom,
        	movedNodes
        );
        sourceY = dims.y;
    }
    var targetY = targetNode.y;
    var left = new Utils.Point(sourceTail.x, sourceY);
    var right = new Utils.Point(targetNode.x, targetY);
    if (sourceY < targetY) {
        makePipe(
        	pgraph,
        	left,
        	right,
        	target,
        	movedNodes
        );
        var vDelta = targetY - sourceY;
        pgraph.moveDown(
        	sourceTail.id,
        	vDelta,
        	movedNodes
        );
        y = targetY;
    } else {
        if (sourceY > targetY) {
            makePipe(
            	pgraph,
            	left,
            	right,
            	target,
            	movedNodes
            );
            var vDelta = sourceY - targetY;
            pgraph.moveDown(
            	target,
            	vDelta,
            	movedNodes
            );
            y = sourceY;
        } else {
            y = sourceY;
        }
    }
    var commands = {};
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var leftJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	y,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	leftJun,
    	target,
    	"right"
    );
    return commandList;
}

function rightLine(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var y;
    var sourceEdge = graph.getEdge(source);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var targetEdge = graph.getEdge(target);
    var targetHead = graph.getHead(targetEdge);
    var targetTail = graph.getTail(targetEdge);
    extendEdge(
    	pgraph,
    	source,
    	0,
    	movedNodes
    );
    extendEdge(
    	pgraph,
    	target,
    	0,
    	movedNodes
    );
    var dims = findLedgeFromOrigin(
    	graph,
    	targetTail.id,
    	sourceTail.id
    );
    var sourceY = sourceTail.box.top - Config.METRE;
    if (sourceY < dims.y) {
        var vDelta = dims.y - sourceY;
        var bottom = sourceTail.y + vDelta;
        dropDown(
        	pgraph,
        	sourceTail,
        	bottom,
        	movedNodes
        );
        sourceY = dims.y;
    }
    var targetY1 = targetHead.box.bottom + Config.METRE;
    var targetY2 = targetTail.box.top - Config.METRE;
    if (sourceY < targetY1) {
        var left = new Utils.Point(sourceTail.x, sourceY);
        var right = new Utils.Point(targetTail.x, targetY1);
        makePipe(
        	pgraph,
        	left,
        	right,
        	targetHead.id,
        	movedNodes
        );
        var vDelta = targetY1 - sourceY;
        pgraph.moveDown(
        	sourceTail.id,
        	vDelta,
        	movedNodes
        );
        y = targetY1;
    } else {
        if (sourceY > targetY2) {
            var left = new Utils.Point(sourceTail.x, sourceY);
            var right = new Utils.Point(targetTail.x, targetY2);
            makePipe(
            	pgraph,
            	left,
            	right,
            	targetHead.id,
            	movedNodes
            );
            var vDelta = sourceY - targetY2;
            pgraph.moveDown(
            	targetTail.id,
            	vDelta,
            	movedNodes
            );
            y = sourceY;
        } else {
            y = sourceY;
        }
    }
    var commands = {};
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    pushDeleteEdge(
    	commandList,
    	target
    );
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var rightJun = insertJunctionBetween(
    	editor,
    	graph,
    	targetEdge.head,
    	targetEdge.tail,
    	y,
    	commandList
    );
    var leftJun = insertJunctionBetween(
    	editor,
    	graph,
    	sourceEdge.head,
    	null,
    	y,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertHorizontal(
    	commandList,
    	bridgeId,
    	leftJun,
    	rightJun,
    	null
    );
    if (isDownLeft(sourceHead)) {
        addTrace(
        	"transplant liana - right line",
        	[source, target]
        );
        var newEdge = findEdgeAbove(
        	commandList,
        	leftJun
        )
        runAndCollapse(
        	editor,
        	commandList,
        	newEdge
        )
        return null
    } else {
        return commandList;
    }
}

function runAndCollapse(editor, commandList1, edgeId) {
    if (edgeId) {
        var before = copyState(editor);
        var after = copyState(editor);
        after.selection = createSelection();
        commandList1 = makeUndoAndExecute(
        	editor,
        	commandList1,
        	after,
        	true
        )
        var graph = editor.storage.graph
        var edge = graph.getEdge(edgeId)
        var commandList2
        if (isBolt(graph, edge)) {
            var collapsed = collapseBoltCore(
            	editor,
            	edgeId
            )
            commandList2 = makeUndoAndExecute(
            	editor,
            	collapsed.commandList,
            	after,
            	true
            )
        } else {
            commandList2 = []
        }
        concatAndSaveUndo(
        	editor,
        	commandList1,
        	commandList2,
        	before,
        	after
        )
    } else {
        applyCommands(
        	editor,
        	commandList1,
        	null
        )
    }
}

function runAndSaveCommands(editor, before, commands, after, redraw) {
    executeCommands(
    	editor,
    	commands,
    	after,
    	false,
    	redraw
    );
    addToUndo(editor.undo, before, commands, after)
}

function runFreeDelete(storage, command, isUndo) {
    var free = storage.free
    var pers = storage.persistence
    if (isUndo) {
        var item = copyStorageItem(command.undo)
        item.id = command.id
        free.add(command.id, item)
    } else {
        free.remove(command.id)
    }
}

function runFreeInsert(editor, command, isUndo) {
    var storage = editor.storage
    var free = storage.free
    var pers = storage.persistence
    if (isUndo) {
        free.remove(command.id)
    } else {
        var item = copyStorageItem(command.fields)
        item.id = command.id
        free.add(command.id, item)
    }
}

function runFreeUpdate(editor, command, isUndo) {
    var storage = editor.storage
    var render = editor.render
    var free = storage.free
    var pers = storage.persistence
    var fields
    if (isUndo) {
        fields = command.undo
    } else {
        fields = command.fields
    }
    fields.id = command.id
    updateFreeNode(free, fields)
}

function runItemDelete(storage, command, isUndo) {
    var graph = storage.graph;
    var pers = storage.persistence;
    if (isUndo) {
        var item = copyStorageItem(command.undo);
        item.id = command.id;
        graph.addItem(item);
    } else {
        graph.removeItem(command.id);
    }
}

function runItemInsert(editor, command, isUndo) {
    var storage = editor.storage;
    var graph = storage.graph;
    var pers = storage.persistence;
    if (isUndo) {
        graph.removeItem(command.id);
    } else {
        var item = copyStorageItem(command.fields);
        item.id = command.id;
        graph.addItem(item);
    }
}

function runNodeUpdate(editor, command, isUndo) {
    var storage = editor.storage;
    var render = editor.render;
    var graph = storage.graph;
    var pers = storage.persistence;
    var fields;
    if (isUndo) {
        fields = command.undo;
    } else {
        fields = command.fields;
    }
    fields.id = command.id;
    updateNode(render, graph, fields);
}

function runTask(task, actionName) {
    var action = task[actionName]
    var order = action.apply(
    	task
    )
    if (order) {
        self.storage.nextId = order.nextId
        applyCommands(
        	self,
        	order.commands,
        	null
        )
    }
}

function sameAddressHeight(edit) {
    sameHeight(
    	edit,
    	"address",
    	expandBranchAddress
    )
}

function sameBranchHeight(edit) {
    sameHeight(
    	edit,
    	"branch",
    	expandBranchHeader
    )
}

function sameHeight(edit, type, expand) {
    var graph = self.storage.graph
    var maxH = null
    var _ind22753 = 0;
    var _col22753 = graph.nodes;
    var _keys22753 = Object.keys(_col22753); 
    var _len22753 = _keys22753.length;
    while (true) {
        if (_ind22753 < _len22753) {
            
        } else {
            break;
        }
        var id = _keys22753[_ind22753]; var node = _col22753[id];
        if (node.type == type) {
            var fields = Drakon.fitItem(
            	node, 
            	self.render
            )
            if (maxH == null) {
                maxH = fields.h
            } else {
                maxH = Math.max(maxH, fields.h)
            }
        }
        _ind22753++;
    }
    var _ind22827 = 0;
    var _col22827 = graph.nodes;
    var _keys22827 = Object.keys(_col22827); 
    var _len22827 = _keys22827.length;
    while (true) {
        if (_ind22827 < _len22827) {
            
        } else {
            break;
        }
        var id = _keys22827[_ind22827]; var node = _col22827[id];
        if ((node.type == type) && (!(maxH == node.h))) {
            var pgraph = createPhysicalGraph(
            	graph,
            	self.render
            )
            var newCommands = {}
            var _ind22771 = 0;
            var _col22771 = graph.nodes;
            var _keys22771 = Object.keys(_col22771); 
            var _len22771 = _keys22771.length;
            while (true) {
                if (_ind22771 < _len22771) {
                    
                } else {
                    break;
                }
                var id = _keys22771[_ind22771]; var node = _col22771[id];
                if (node.type == type) {
                    expand(
                    	pgraph, 
                    	id,
                    	maxH,
                    	newCommands
                    )
                }
                _ind22771++;
            }
            combineRunCommands(
            	edit,
            	newCommands
            )
            break;
        }
        _ind22827++;
    }
}

function saveHandlePos(id) {
    if (self.readonly) {
        
    } else {
        addTrace(
        	"save handle pos",
        	[id]
        )
        var free = self.canvas.free
        var item = free.get(id)
        var oldFree = self.storage.free
        var oldItem = oldFree.get(id)
        var fields = {}
        var _ind18788 = 0;
        var _col18788 = item;
        var _keys18788 = Object.keys(_col18788); 
        var _len18788 = _keys18788.length;
        while (true) {
            if (_ind18788 < _len18788) {
                
            } else {
                break;
            }
            var key = _keys18788[_ind18788]; var value = _col18788[key];
            if ((key in gNonCopiableFields) || ((oldItem[key] == value) && (!(key == "content")))) {
                
            } else {
                fields[key] = value
            }
            _ind18788++;
        }
        var updates = []
        var change = new Command(
        	"update",
        	"free",
        	id,
        	fields
        )
        updates.push(change)
        submitCommands(self, updates, true)
    }
}

function scanDown(leftX, graph, src, targetId, result) {
    var nodeId = graph.getNodeDown(src);
    var node = graph.getNode(nodeId);
    if (nodeId == targetId) {
        
    } else {
        recordDimension(node, result);
        if (node.right) {
            if (hasLeft(graph, node)) {
                scanLeft(leftX, graph, node, targetId, result);
            } else {
                scanRight(leftX, graph, node, targetId, result);
            }
        } else {
            if (node.down) {
                scanDown(leftX, graph, node, targetId, result);
            } else {
                if (node.left) {
                    scanLeft(leftX, graph, node, targetId, result);
                }
            }
        }
    }
}

function scanLeft(leftX, graph, src, targetId, result) {
    var nodeId = graph.getNodeLeft(src);
    var node = graph.getNode(nodeId);
    recordDimension(node, result);
    if (node.x < leftX) {
        var target = graph.getNode(targetId);
        if (node.y > target.y) {
            
        } else {
            if (nodeId == targetId) {
                
            } else {
                if (node.down) {
                    scanDown(leftX, graph, node, targetId, result);
                } else {
                    if (node.left) {
                        var leftNode = graph.getNodeLeftEx(node)
                        if (leftNode.type == "duration") {
                            scanUp(leftX, graph, node, targetId, result);
                        } else {
                            scanLeft(leftX, graph, node, targetId, result);
                        }
                    } else {
                        scanUp(leftX, graph, node, targetId, result);
                    }
                }
            }
        }
    } else {
        if (nodeId == targetId) {
            
        } else {
            if (node.down) {
                scanDown(leftX, graph, node, targetId, result);
            } else {
                if (node.left) {
                    var leftNode = graph.getNodeLeftEx(node)
                    if (leftNode.type == "duration") {
                        scanUp(leftX, graph, node, targetId, result);
                    } else {
                        scanLeft(leftX, graph, node, targetId, result);
                    }
                } else {
                    scanUp(leftX, graph, node, targetId, result);
                }
            }
        }
    }
}

function scanLeftWall(graph, startNodeId, endNodeId) {
    var startNode = graph.getNode(
    	startNodeId
    );
    var current = {
    	node: startNode,
    	edge: { id: null }
    };
    if (startNodeId == endNodeId) {
        return {
        	nodes: [ startNodeId ],
        	lowest: startNode.y
        };
    } else {
        var nodes = [];
        var lowestY = startNode.y;
        while (true) {
            var next = findNextOnWall(
            	graph,
            	current
            );
            var id = next.node.id;
            nodes.push(id);
            current = next;
            if (id == endNodeId) {
                break;
            }
            if (next.node.y > lowestY) {
                lowestY = next.node.y;
            }
        }
        return {
        	nodes: nodes,
        	lowest: lowestY
        };
    }
}

function scanRight(leftX, graph, src, targetId, result) {
    var nodeId =graph.getNodeRight(src);
    var node = graph.getNode(nodeId);
    var type = describeJunction(node);
    if ((nodeId == targetId) || (type === "left-up")) {
        
    } else {
        recordDimension(node, result);
        if (nodeId == targetId) {
            
        } else {
            if (node.right) {
                scanRight(leftX, graph, node, targetId, result);
            } else {
                scanDown(leftX, graph, node, targetId, result);
            }
        }
    }
}

function scanStartBelow(graph, source, y) {
    var srcEdge = graph.getEdge(source);
    return scanStartBelowCore(
    	graph,
    	srcEdge.tail,
    	y
    );
}

function scanStartBelowCore(graph, srcNodeId, y) {
    var srcNode = graph.getNode(srcNodeId);
    var probe = new Utils.Box(
    	Math.floor(srcNode.x - Config.METRE * 1.5),
    	Math.floor(srcNode.y + Config.METRE * 0.5),
    	Math.floor(srcNode.x + Config.METRE * 1.5),
    	Math.floor(y + Config.METRE * 0.5)
    );
    var found = null;
    var highest = 10000000000;
    var _ind5211 = 0;
    var _col5211 = graph.edges;
    var _keys5211 = Object.keys(_col5211); 
    var _len5211 = _keys5211.length;
    while (true) {
        if (_ind5211 < _len5211) {
            
        } else {
            break;
        }
        var eid = _keys5211[_ind5211]; var edge = _col5211[eid];
        if (Utils.boxesIntersect(probe, edge.box)) {
            var head = graph.getHead(edge);
            if (head.y < highest) {
                found = head.id;
                highest = head.y;
            }
        }
        _ind5211++;
    }
    if (found === null) {
        Utils.throwError(
         "No edge on the way");
    } else {
        return found;
    }
}

function scanSurface(graph, start, targetId, visitor) {
    var node = start;
    var dir = "left";
    var id;
    while (true) {
        visitor(node);
        if (targetId == node.id) {
            break;
        }
        if (dir === "down") {
            if (node.right) {
                dir = "right";
                id =graph.getNodeRight(node);
            } else {
                if (node.down) {
                    id = graph.getNodeDown(node);
                } else {
                    if (hasLeft(graph, node)) {
                        dir = "left";
                        id = graph.getNodeLeft(node);
                    } else {
                        Utils.throwError(
                         "dead end");
                    }
                }
            }
        } else {
            if (dir === "right") {
                if (node.up) {
                    Utils.throwError(
                     "dead end");
                } else {
                    if (node.right) {
                        id =graph.getNodeRight(node);
                    } else {
                        if (node.down) {
                            dir = "down";
                            id = graph.getNodeDown(node);
                        } else {
                            Utils.throwError(
                             "dead end");
                        }
                    }
                }
            } else {
                if (dir === "up") {
                    if (hasLeft(graph, node)) {
                        dir = "left";
                        id = graph.getNodeLeft(node);
                    } else {
                        if (node.up) {
                            id = graph.getNodeUp(node);
                        } else {
                            Utils.throwError(
                             "dead end");
                        }
                    }
                } else {
                    if (dir === "left") {
                        
                    } else {
                        throw "Unexpected switch value: " + dir;
                    }
                    if (node.down) {
                        dir = "down";
                        id = graph.getNodeDown(node);
                    } else {
                        if (hasLeft(graph, node)) {
                            id = graph.getNodeLeft(node);
                        } else {
                            if (node.up) {
                                dir = "up";
                                id = graph.getNodeUp(node);
                            } else {
                                Utils.throwError(
                                 "dead end");
                            }
                        }
                    }
                }
            }
        }
        node = graph.getNode(id);
    }
}

function scanUp(leftX, graph, src, targetId, result) {
    var nodeId = graph.getNodeUp(src);
    var node = graph.getNode(nodeId);
    recordDimension(node, result);
    if (nodeId == targetId) {
        
    } else {
        if (hasLeft(graph, node)) {
            scanLeft(leftX, graph, node, targetId, result);
        } else {
            scanUp(leftX, graph, node, targetId, result);
        }
    }
}

function selectAll() {
    var editor = self
    var storage = editor.storage
    var nodes = Object.keys(storage.graph.nodes)
    var free = storage.free.list
    var all = nodes.concat(free)
    selectItems(editor, all)
    redrawCanvas(editor);
}

function selectItem(editor, id) {
    var item = getAnyItem(editor.storage, id)
    console.log(id, item)
    editor.storage.selection = createSelection();
    if (item) {
        editor.storage.selection.add(id, true);
    }
}

function selectItems(editor, ids) {
    editor.storage.selection = createSelection();
    var _ind18010 = 0;
    var _col18010 = ids;
    var _len18010 = _col18010.length;
    while (true) {
        if (_ind18010 < _len18010) {
            
        } else {
            break;
        }
        var id = _col18010[_ind18010];
        editor.storage.selection.add(id, false);
        _ind18010++;
    }
}

function selectOneItem(itemId) {
    deselectAll(self)
    selectItem(self, itemId)
    redrawCanvas(self)
}

function setBackground(data) {
    if (ignoreCommand()) {
        
    } else {
        addTrace(
        	"set background",
        	[data]
        )
        var editor = self
        var commandList = []
        var fields = {}
        setNotNull(data, "background", fields)
        setNotNull(data, "diaLine", fields)
        setNotNull(data, "diaLineThickness", fields)
        commandList.push(new Command(
        	"update",
        	"diagrams",
        	"diagram",
        	fields
        ));
        submitCommands(editor, commandList, true)
    }
}

function setCallback(name, fun) {
    Callbacks[name] = fun
}

function setContent(id, content) {
    if (ignoreCommand()) {
        
    } else {
        addTrace(
        	"setContent",
        	[id, content]
        );
        setItemText(self, id, content)
    }
}

function setContentField(content, key, value) {
    var font = content.font || self.storage.font
    var parsed = Utils.parseFontString(
    	font
    )
    if (key === "font-italic") {
        parsed.italic = value
        var font2 =  Utils.buildFontString(
        	parsed.italic,
        	parsed.bold,
        	parsed.size,
        	parsed.family
        )
        content.font = font2
    } else {
        if (key === "font-bold") {
            parsed.bold = value
            var font2 =  Utils.buildFontString(
            	parsed.italic,
            	parsed.bold,
            	parsed.size,
            	parsed.family
            )
            content.font = font2
        } else {
            if (key === "font-size") {
                parsed.size = value
                var font2 =  Utils.buildFontString(
                	parsed.italic,
                	parsed.bold,
                	parsed.size,
                	parsed.family
                )
                content.font = font2
            } else {
                if (key === "font-family") {
                    parsed.family = value
                    var font2 =  Utils.buildFontString(
                    	parsed.italic,
                    	parsed.bold,
                    	parsed.size,
                    	parsed.family
                    )
                    content.font = font2
                } else {
                    content[key] = value
                }
            }
        }
    }
}

function setContentForManyItems(editor, ids, makeContent) {
    addTrace(
    	"set text for many items",
    	ids
    );
    var before = copyState(editor);
    var after = copyState(editor);
    var i;
    var count = ids.length;
    var allCommands = [];
    i = 0;
    while (true) {
        if (i < count) {
            
        } else {
            break;
        }
        var id = ids[i];
        var item = getAnyItem(editor.storage, id)
        var newContent = makeContent(item)
        allCommands = setTextExecute(
        	editor,
        	id,
        	newContent,
        	allCommands
        );
        i++;
    }
    persistAndRedraw(
    	editor,
    	after,
    	true
    )
    addToUndo(editor.undo, before, allCommands, after)
    selectItems(editor, ids)
}

function setContentLink(content, link) {
    var copy = Utils.copyObject(content)
    copy.link = link
    return copy
}

function setContentTxt(content, txt) {
    var copy = Utils.copyObject(content)
    copy.txt = txt
    return copy
}

function setContentTxt2(content, txt2) {
    var copy = Utils.copyObject(content)
    copy.txt2 = txt2
    return copy
}

function setFormat(ids, format) {
    if (ignoreCommand()) {
        
    } else {
        var editor = self
        var makeContent = function(item) {
        	var newContent = setManyContentFields(
        		item.content,
        		format
        	)
        	return newContent
        }
        setContentForManyItems(
        	editor,
        	ids,
        	makeContent
        )
    }
}

function setFreeItemSize(id, x, y, width, height) {
    if (ignoreCommand()) {
        
    } else {
        addTrace(
        	"resize free item",
        	id
        );
        var free = self.storage.free
        var item = free.get(id)
        if (item) {
            var changed = {
            	commands: {}
            }
            Drakon.changeFreeItem(
            	render,
            	free,
            	id,
            	width,
            	height,
            	item.content,
            	changed
            );
            var command = getOrCreateUpdate(
            	changed.commands,
            	id
            )
            command.fields.x = x
            command.fields.y = y
            var updates = Utils.objectValues(
            	changed.commands
            )
            applyCommands(
            	self,
            	updates,
            	id
            );
        }
    }
}

function setItemDims(item, size) {
    item.w = size.w;
    item.h = size.h;
    if ("a" in size) {
        item.a = size.a;
    }
    if (size.tb) {
        item.tb = size.tb;
    }
    if (size.tb2) {
        item.tb2 = size.tb2;
    }
}

function setItemText(editor, id, cont) {
    cont = trimContent(cont)
    addTrace(
    	"set item text",
    	[id, Utils.copyObject(cont)]
    );
    var commands = {};
    var graph = editor.storage.graph;
    var render = editor.render;
    var pgraph = createPhysicalGraph(graph, render);
    setItemTextCore(
    	editor,
    	pgraph,
    	id,
    	cont,
    	commands
    );
    var commList = Utils.objectValues(commands);
    var item = getAnyItem(editor.storage, id)
    if ((item.role == "header") && (cont.txt)) {
        pushUpdateDiagram(commList, cont.txt);
    }
    submitCommands(editor, commList, true)
}

function setItemTextCore(editor, pgraph, id, cont, commands) {
    var render = editor.render;
    var graph = editor.storage.graph;
    var free = editor.storage.free
    var item = getAnyItem(
    	editor.storage,
    	id
    )
    var changed = {
    	commands: commands
    }
    if (item.free) {
        Drakon.changeFreeItem(
        	render,
        	free,
        	id,
        	item.w,
        	item.h,
        	cont,
        	changed
        );
    } else {
        if (isMind()) {
            Mind.changeItem(
            	render,
            	pgraph,
            	id,
            	item.w,
            	cont,
            	changed
            );
        } else {
            Drakon.changeItem(
            	render,
            	pgraph,
            	id,
            	item.w,
            	cont,
            	changed
            );
        }
    }
    if (changed.tb) {
        item.tb = changed.tb;
    }
    if (changed.tb2) {
        item.tb2 = changed.tb2;
    }
}

function setItemWidth(id, width) {
    if (ignoreCommand()) {
        
    } else {
        addTrace(
        	"setItemWidth",
        	[id, width]
        );
        var editor = self;
        var graph = editor.storage.graph;
        var render = editor.render;
        var pgraph = createPhysicalGraph(
        	graph,
        	render
        );
        var node = graph.getNode(id);
        var commands = {};
        if (isMind()) {
            Mind.setItemWidth(
            	render,
            	pgraph,
            	id,
            	width,
            	commands
            )
        } else {
            if (Drakon.isWideIcon(node)) {
                Drakon.setSkewerWidth(
                	render,
                	pgraph,
                	id,
                	width,
                	commands
                );
            } else {
                var result = {
                	commands: commands
                };
                Drakon.changeItem(
                	render,
                	pgraph,
                	id,
                	width,
                	node.content,
                	result
                );
            }
        }
        var commList = Utils.objectValues(commands);
        applyCommands(
        	editor,
        	commList,
        	id
        );
    }
}

function setManyContentFields(content, fields) {
    var result
    if (content) {
        result = Utils.copyObject(content)
    } else {
        result = new Utils.Content("", "")
    }
    var _ind17712 = 0;
    var _col17712 = fields;
    var _keys17712 = Object.keys(_col17712); 
    var _len17712 = _keys17712.length;
    while (true) {
        if (_ind17712 < _len17712) {
            
        } else {
            break;
        }
        var key = _keys17712[_ind17712]; var value = _col17712[key];
        setContentField(
        	result,
        	key,
        	value
        )
        _ind17712++;
    }
    return result
}

function setNextPointers(nodes) {
    var i
    var last = nodes.length - 1
    i = 0;
    while (true) {
        if (i < last) {
            
        } else {
            break;
        }
        var current = nodes[i]
        var next = nodes[i + 1]
        current.next = next.id
        i++;
    }
    if (nodes.length > 0) {
        nodes[last].next = ""
    }
}

function setNotEmpty(src, name, target) {
    var value = src[name]
    if (value) {
        target[name] = value
    }
}

function setNotNull(src, name, target, tname) {
    if (name in src) {
        tname = tname || name
        target[tname] = src[name]
    }
}

function setNotNullFields(commandList, keys) {
    var fields = {}
    var empty = true
    var _ind17598 = 0;
    var _col17598 = keys;
    var _len17598 = _col17598.length;
    while (true) {
        if (_ind17598 < _len17598) {
            
        } else {
            break;
        }
        var key = _col17598[_ind17598];
        var value = getDefault(key)
        if (value) {
            fields[key] = value
            empty = false
        }
        _ind17598++;
    }
    if (empty) {
        
    } else {
        commandList.push(new Command(
        	"update",
        	"diagrams",
        	"diagram",
        	fields
        ));
    }
}

function setReadonly(readonly) {
    self.readonly = readonly
}

function setStorage(editor, storage) {
    editor.render.clear();
    editor.sockets = [];
    editor.undo = new Undo();
    editor.storage = storage;
}

function setTextExecute(editor, id, cont, allCommands) {
    cont = trimContent(cont)
    var graph = editor.storage.graph;
    var render = editor.render;
    var commands = {};
    var node = getAnyItem(editor.storage, id)
    if (((node.down) || (!(node.type == "beginend"))) || (isMind())) {
        
    } else {
        var update = Drakon.getOrCreateUpdate(
        	commands,
        	id
        );
        update.fields.type = "end";
        node.type = "end";
    }
    var pgraph = createPhysicalGraph(graph, render);
    setItemTextCore(
    	editor,
    	pgraph,
    	id,
    	cont,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    if (commandList.length == 0) {
        
    } else {
        commandList = calculateUndo(
        	editor.storage,
        	commandList
        );
        performLocalChange(
        	editor,
        	commandList,
        	false
        )
        allCommands = allCommands.concat(commandList);
    }
    return allCommands;
}

function setTextForManyItems(editor, ids, cont) {
    var makeContent = function(item) {
    	var old = getContent(item)
    	var newContent = Utils.copyObject(old)
    	newContent.txt = cont.txt
    	newContent.txt2 = cont.txt2
    	return newContent
    }
    setContentForManyItems(
    	editor,
    	ids,
    	makeContent
    )
}

function setUserSettings(settings) {
    gUserSettings = Utils.copyObject(settings)
}

function shortCycleDown(editor, pgraph, source, target) {
    var graph2 = editor.storage.graph.clone();
    var graph = pgraph.graph;
    var sourceEdge = graph.getEdge(source);
    var down = graph.getNode(sourceEdge.tail);
    var leftEdge = down.left;
    var commands1 = expandBoltCore(editor, pgraph, leftEdge);
    var newEdgeId = findInsertedEdge(commands1);
    var dummyStorage = {
    	graph: graph2,
    	persistence: new FakePersistence(),
    	nextId: editor.storage.nextId
    };
    var dummyEditor = {
    	storage: dummyStorage,
    	render: render
    }
    var count = commands1.length;
    var i = 0;
    while (true) {
        if (i < count) {
            
        } else {
            break;
        }
        var command = commands1[i];
        performChange(dummyEditor, command, false);
        i++;
    }
    var pgraph3 = createPhysicalGraph(
    	graph2,
    	editor.render
    );
    var commands2 = leftInnerLine(
    	dummyEditor,
    	pgraph3,
    	newEdgeId,
    	target
    );
    editor.storage.nextId = dummyEditor.storage.nextId;
    var deletedIn2 = commands2.filter(function(comm) {
    	return comm.type == "delete";
    });
    var insertedIn1 = commands1.filter(function(comm) {
    	return comm.type == "insert";
    });
    var deleted2 = {};
    var inserted1 = {};
    deletedIn2.forEach(function(comm) {
    	deleted2[comm.id] = true;
    });
    insertedIn1.forEach(function(comm) {
    	inserted1[comm.id] = true;
    });
    var commands1ex = commands1.filter(function(comm) {
    	return !(comm.id in deleted2);
    });
    var commands2ex = commands2.filter(function(comm) {
    	return !(comm.type == "delete" && (comm.id in inserted1));
    });
    return commands1ex.concat(commands2ex);
}

function shouldResize(item) {
    if (((((((((item.isLine) || (item.type === "beginend")) || (item.type === "end")) || (item.type === "junction")) || (item.type === "duration")) || (item.type === "pause")) || (item.type === "ctrlStart")) || (item.type === "ctrlEnd")) || (item.type === "timer")) {
        return false;
    } else {
        return true;
    }
}

function showContextMenu(x, y, menu) {
    var fun = Callbacks.showContextMenu
    if (fun) {
        fun(x, y, menu)
    }
}

function showInputBox(title, oldText, callback, x, y) {
    var fun = Callbacks.showInputBox;
    if (fun) {
        fun(title, oldText, callback, x, y);
    }
}

function showInsertionSockets(type) {
    if (self.readonly) {
        
    } else {
        deselectAll(self);
        redrawCanvasCore(self, type);
    }
}

function showMessage(text) {
    var fun = Callbacks.showMessage;
    if (fun) {
        fun(text);
    }
}

function showWarningPopup(message) {
    var fun = Callbacks.showWarningPopup;
    if (fun) {
        fun(message);
    }
}

function sizeOrTextChanged(item, newContent, size) {
    if ((((contEqual(item.content, newContent)) && (item.w == size.w)) && (item.h == size.h)) && ((size.a == null) || (item.a == size.a))) {
        return false;
    } else {
        return true;
    }
}

function softLeft(graph, item) {
    if (item.type == "duration") {
        return graph.getNodeRight(item);
    } else {
        return null;
    }
}

function softUp(graph, item) {
    var _sw147120000_ = 0;
    _sw147120000_ = item.type;
    if ((_sw147120000_ === "branch") || (_sw147120000_ === "case")) {
        var above = graph.getNodeUp(item);
        return above;
    } else {
        if ((_sw147120000_ === "select") || (_sw147120000_ === "address")) {
            var below = graph.getNodeDown(item);
            return below;
        } else {
            return null;
        }
    }
}

function startEdit() {
    var ids = getSelection()
    if (ids.length == 1) {
        var id = ids[0]
        if (canBeEdited(id)) {
            startEditText(id)
        }
    }
}

function startEditText(id) {
    var node = getAnyItem(
    	self.storage,
    	id
    );
    var x = node.x + node.w
    var y = node.y - node.h
    if (node.type == "f_line") {
        x = node.x + 20
        y = node.y + 20
    }
    var old = getContent(node);
    var setTextProc;
    if (node.type === "branch") {
        setTextProc = function(text) {
        	var content = setContentTxt(old, text);
        	renameBranch(self, id, content);
        };
    } else {
        setTextProc = function(text) {
        	var content = setContentTxt(old, text);
        	setItemText(self, id, content);
        };
    }
    showInputBox(
    	tr("MES_CHANGE_ITEM_TEXT") + ": " + id,
    	old.txt,
    	setTextProc,
    	x,
    	y
    );
}

function startEditTextAt(id, x, y) {
    var node = getAnyItem(
    	self.storage,
    	id
    );
    if (hasUpperText(node)) {
        var middle = node.y - node.h + node.a * 2;
        if (y > middle) {
            startEditText(id);
        } else {
            startEditUpperText(id);
        }
    } else {
        startEditText(id);
    }
}

function startEditUpperText(id) {
    var node = getAnyItem(
    	self.storage,
    	id
    );
    var x = node.x + node.w
    var y = node.y - node.h
    var old = getContent(node);
    var setTextProc;
    setTextProc = function(text2) {
    	var content = setContentTxt2(old, text2);
    	setItemText(self, id, content);
    };
    showInputBox(
    	tr("MES_CHANGE_ITEM_UPPER") + ": " + id,
    	old.txt2,
    	setTextProc,
    	x,
    	y
    );
}

function startVisualDrag(itemId) {
    if (self.readonly) {
        
    } else {
        gDragStartItem = null
        gDragItems = []
        self.changedNodes = {}
        if (itemId) {
            var item = getAnyItem(self.storage, itemId)
            if (item.free) {
                gDragItems = findItemsToDrag(self, itemId)
            } else {
                gDragStartItem = itemId
                var expanders = getHardExpanders()
                self.canvas.pgraph.startPhysicalDrag(itemId, expanders)
            }
        } else {
            gDragItems = findItemsToDrag(self, itemId)
        }
        self.dragOn = true
    }
}

function submitCommands(editor, commands, redraw) {
    applyCommandsCore(
    	editor,
    	commands,
    	null,
    	false,
    	redraw
    )
}

function swapYesNo(editor, id) {
    addTrace(
    	"swap 'yes' and 'no'",
    	[id]
    );
    var item = editor.storage.graph.getItem(id);
    var newFlag;
    if (item.flag1) {
        newFlag = 0;
    } else {
        newFlag = 1;
    }
    var myChange = new Command(
    	"update",
    	"nodes",
    	id,
    	{
    		flag1: newFlag
    	}
    );
    var commands = [ myChange ];
    submitCommands(editor, commands, true)
}

function takeOldValues(fields, old, undo) {
    var _ind17548 = 0;
    var _col17548 = fields;
    var _keys17548 = Object.keys(_col17548); 
    var _len17548 = _keys17548.length;
    while (true) {
        if (_ind17548 < _len17548) {
            
        } else {
            break;
        }
        var name = _keys17548[_ind17548]; var _ = _col17548[name];
        var oldValue = old[name]
        if ((oldValue === null) || (oldValue === undefined)) {
            oldValue = ""
        }
        undo[name] = oldValue
        _ind17548++;
    }
}

function toBack(editor, itemId) {
    addTrace(
    	"toBack",
    	[itemId]
    );
    var list = editor.storage.free.list
    var commList = []
    var itemOrdinal = list.indexOf(itemId)
    if (itemOrdinal == 0) {
        
    } else {
        var firstId = list[0]
        pushUpdate(
        	commList,
        	"free",
        	itemId,
        	{ next: firstId }
        )
        var nextId
        if (itemOrdinal == list.length - 1) {
            nextId = ""
        } else {
            nextId = list[itemOrdinal + 1]
        }
        var prevId = list[itemOrdinal - 1]
        pushUpdate(
        	commList,
        	"free",
        	prevId,
        	{ next: nextId }
        )
        applyCommands(
        	editor,
        	commList,
        	itemId
        );
    }
}

function toFront(editor, itemId) {
    addTrace(
    	"toFront",
    	[itemId]
    );
    var list = editor.storage.free.list
    var commList = []
    var itemOrdinal = list.indexOf(itemId)
    if (itemOrdinal == list.length - 1) {
        
    } else {
        pushUpdate(
        	commList,
        	"free",
        	itemId,
        	{ next: "" }
        )
        if (itemOrdinal == 0) {
            
        } else {
            var nextId = list[itemOrdinal + 1]
            var prevId = list[itemOrdinal - 1]
            pushUpdate(
            	commList,
            	"free",
            	prevId,
            	{ next: nextId }
            )
        }
        var lastId = list[list.length - 1]
        pushUpdate(
        	commList,
        	"free",
        	lastId,
        	{ next: itemId }
        )
        applyCommands(
        	editor,
        	commList,
        	itemId
        );
    }
}

function toPrimitive(editor) {
    addTrace(
    	"to primitive",
    	[]
    );
    var graph = editor.storage.graph;
    var render = editor.render;
    var pgraph = createPhysicalGraph(graph, render);
    var header = findNodeByRole(graph, "header");
    var crossId = graph.getNodeDown(header);
    var cross = graph.getNode(crossId);
    var branchId = graph.getNodeDown(cross);
    var branch = graph.getNode(branchId);
    var bottom = goDownToEnd(graph, crossId);
    var edges = {};
    var nodes = {};
    var secondBranchId = findSecondBranch(graph, cross);
    var addresses = findSiblingAddresses(
    	graph,
    	bottom,
    	secondBranchId,
    	nodes
    );
    var firstId = graph.getNodeDown(branch);
    var addressId = graph.getNodeUp(bottom);
    var address = graph.getNode(addressId);
    var lastId = graph.getNodeUp(address);
    var en = makeDummyItem(
    	1,
    	render,
    	"end",
    	makeCont(getEnd())
    );
    nodes[header.id] = true;
    nodes[branchId] = true;
    edges[branch.down] = true;
    var _ind9890 = 0;
    var _col9890 = addresses;
    var _len9890 = _col9890.length;
    while (true) {
        if (_ind9890 < _len9890) {
            
        } else {
            break;
        }
        var addId = _col9890[_ind9890];
        nodes[addId] = true;
        var address2 = graph.getNode(addId);
        edges[address2.up] = true;
        _ind9890++;
    }
    graph.enumerateManhattan(
    	crossId,
    	nodes,
    	edges
    );
    delete nodes[header.id];
    var commList = [];
    pushDeleteSubgraph(
    	commList,
    	nodes,
    	edges
    );
    var endId = generateId(editor.storage);
    if (addresses.length > 1) {
        var y = address.y + address.h +
          Config.METRE * 2 + en.h;
        var junctions = [];
        pushInsertNodeAt(
        	render,
        	commList,
        	endId,
        	"end",
        	address.x, y,
        	en.w, en.h,
        	makeCont(getEnd())
        );
        connectVer(
        	editor,
        	commList,
        	header.id, firstId,
        	"down"
        );
        var _ind9957 = 0;
        var _col9957 = addresses;
        var _len9957 = _col9957.length;
        while (true) {
            if (_ind9957 < _len9957) {
                
            } else {
                break;
            }
            var addId = _col9957[_ind9957];
            var add = graph.getNode(addId);
            var downId = graph.getNodeDown(add);
            var downJ = graph.getNode(downId);
            var upId = graph.getNodeUp(add);
            var jId = generateId(editor.storage);
            junctions.push(jId);
            pushInsertJunction(
            	commList,
            	jId,
            	add.x, downJ.y
            );
            connectVer(
            	editor,
            	commList,
            	upId, jId,
            	"down"
            );
            _ind9957++;
        }
        var i = 1;
        while (true) {
            if (i < junctions.length) {
                
            } else {
                break;
            }
            connectHor(
            	editor,
            	commList,
            	junctions[i - 1], junctions[i],
            	"left"
            );
            i++;
        }
        connectVer(
        	editor,
        	commList,
        	junctions[0], endId,
        	"down"
        );
    } else {
        if (firstId == addressId) {
            pushInsertNodeAt(
            	render,
            	commList,
            	endId,
            	"end",
            	address.x, address.y,
            	en.w, en.h,
            	makeCont(getEnd())
            );
            connectVer(
            	editor,
            	commList,
            	header.id, endId,
            	"down"
            );
        } else {
            pushInsertNodeAt(
            	render,
            	commList,
            	endId,
            	"end",
            	address.x, address.y,
            	en.w, en.h,
            	makeCont(getEnd())
            );
            connectVer(
            	editor,
            	commList,
            	header.id, firstId,
            	"down"
            );
            connectVer(
            	editor,
            	commList,
            	lastId, endId,
            	"down"
            );
        }
    }
    applyCommands(
    	editor,
    	commList,
    	null
    );
}

function toSilhouette(editor) {
    addTrace(
    	"to silhouette",
    	[]
    );
    if (canAddMore(editor, 5)) {
        var render = editor.render;
        var pgraph = createPhysicalGraph(
        	editor.storage.graph, render);
        var graph = pgraph.graph
        var movedNodes = {};
        var commList = [];
        var commands = {};
        var header = findNodeByRole(graph, "header");
        adjustForWildCycles(
        	pgraph, 
        	header,
        	movedNodes
        )
        var bra = makeDummyItem(
        	1,
        	render,
        	"branch",
        	makeCont("branch W")
        );
        extendEdge(
        	pgraph,
        	header.down,
        	bra.h + Config.METRE / 2,
        	movedNodes
        );
        var en = makeDummyItem(
        	1,
        	render,
        	"end",
        	makeCont(getEnd())
        );
        var width = getVerticalWidth(
        	graph,
        	header.id
        );
        var end = goDownToEnd(graph, header.id);
        var leftEdge = findLeftSkewerEdge(
        	pgraph,
        	header.id
        );
        var y0 = header.y + header.h + Config.METRE;
        var y1 = y0 + Config.METRE + bra.h;
        var aboveEndId = graph.getNodeUp(end);
        var aboveEnd = pgraph.graph.getNode(aboveEndId);
        var x2;
        var braLeft = header.x - width;
        var x0 = leftEdge - Config.METRE;
        x2 = header.x + width + bra.w
          + Config.METRE * 4;
        var diaBox = findDiagramBox(pgraph.graph);
        var y2 = diaBox.bottom + bra.h;
        var y3 = y2 + Config.METRE + bra.h;
        var yEnd = y1 + Config.METRE * 4 + bra.h +
          en.h;
        if (x2 < diaBox.right) {
            x2 = diaBox.right;
        }
        var x1 = header.x;
        var x3 = x2 + bra.w * 2 + Config.METRE * 4;
        buildMoveCommands(
        	pgraph,
        	movedNodes,
        	commands
        );
        commList = Utils.objectValues(commands);
        if (aboveEndId == header.id) {
            
        } else {
            pushDeleteEdge(
            	commList,
            	header.down
            );
        }
        pushDeleteEdge(
        	commList,
        	end.up
        );
        pushDeleteNode(
        	commList,
        	end.id
        );
        var t0 = generateId(editor.storage);
        var t1 = generateId(editor.storage);
        var t2 = generateId(editor.storage);
        var t3 = generateId(editor.storage);
        var b1 = generateId(editor.storage);
        var b2 = generateId(editor.storage);
        var b3 = generateId(editor.storage);
        var a1 = generateId(editor.storage);
        var a2 = generateId(editor.storage);
        var f0 = generateId(editor.storage);
        var f1 = generateId(editor.storage);
        var f2 = generateId(editor.storage);
        var endId = generateId(editor.storage);
        pushInsertJunction(
        	commList,
        	t0,
        	x0, y0
        );
        pushInsertJunction(
        	commList,
        	t1,
        	x1, y0
        );
        pushInsertJunction(
        	commList,
        	t2,
        	x2, y0
        );
        pushInsertJunction(
        	commList,
        	t3,
        	x3, y0
        );
        var c1 = makeCont("Branch 1");
        var c2 = makeCont("Branch 2");
        var c3 = makeCont("Branch 3");
        pushInsertNodeAt(
        	render,
        	commList,
        	b1,
        	"branch",
        	x1, y1,
        	width, bra.h,
        	c1
        );
        pushInsertNodeAt(
        	render,
        	commList,
        	b2,
        	"branch",
        	x2, y1,
        	bra.w, bra.h,
        	c2
        );
        pushInsertNodeAt(
        	render,
        	commList,
        	b3,
        	"branch",
        	x3, y1,
        	bra.w, bra.h,
        	c3
        );
        pushInsertJunction(
        	commList,
        	f0,
        	x0, y3
        );
        pushInsertJunction(
        	commList,
        	f1,
        	x1, y3
        );
        pushInsertJunction(
        	commList,
        	f2,
        	x2, y3
        );
        pushInsertNodeAt(
        	render,
        	commList,
        	a1,
        	"address",
        	x1, y2,
        	width, bra.h,
        	c2
        );
        pushInsertNodeAt(
        	render,
        	commList,
        	a2,
        	"address",
        	x2, y2,
        	bra.w, bra.h,
        	c3
        );
        connectVer(
        	editor,
        	commList,
        	header.id, t1,
        	null
        );
        connectHor(
        	editor,
        	commList,
        	t0, t1,
        	"rarrow"
        );
        connectHor(
        	editor,
        	commList,
        	t1, t2,
        	null
        );
        connectHor(
        	editor,
        	commList,
        	t2, t3,
        	null
        );
        connectVer(
        	editor,
        	commList,
        	t1, b1,
        	null
        );
        connectVer(
        	editor,
        	commList,
        	t2, b2,
        	null
        );
        connectVer(
        	editor,
        	commList,
        	t3, b3,
        	null
        );
        connectHor(
        	editor,
        	commList,
        	f0, f1,
        	null
        );
        connectHor(
        	editor,
        	commList,
        	f1, f2,
        	"sil_floor"
        );
        connectVer(
        	editor,
        	commList,
        	t0, f0,
        	null
        );
        connectVer(
        	editor,
        	commList,
        	a1, f1,
        	null
        );
        connectVer(
        	editor,
        	commList,
        	a2, f2,
        	null
        );
        if (aboveEndId == header.id) {
            connectVer(
            	editor,
            	commList,
            	b1, a1,
            	"down"
            );
        } else {
            var belowHeaderId = graph.getNodeDown(header);
            connectVer(
            	editor,
            	commList,
            	b1, belowHeaderId,
            	"down"
            );
            connectVer(
            	editor,
            	commList,
            	aboveEndId, a1,
            	"down"
            );
        }
        connectVer(
        	editor,
        	commList,
        	b2, a2,
        	"down"
        );
        pushInsertNodeAt(
        	render,
        	commList,
        	endId,
        	"end",
        	x3, yEnd,
        	en.w, en.h,
        	makeCont(getEnd())
        );
        connectVer(
        	editor,
        	commList,
        	b3, endId,
        	"down"
        );
        applyCommands(
        	editor,
        	commList,
        	null
        );
    }
}

function toggleCycleMark(editor, id) {
    swapYesNo(editor, id);
}

function toggleSilhouette() {
    if (ignoreCommand()) {
        
    } else {
        if (hasDrakon()) {
            if (isSilhouette(self.storage.graph)) {
                toPrimitive(self);
            } else {
                toSilhouette(self);
            }
        } else {
            console.log("Not DRAKON")
        }
    }
}

function toggleTreeType() {
    if ((ignoreCommand()) || (!(isMind()))) {
        
    } else {
        mindAction("toggleTree", null, null)
    }
}

function topInnerCorner(editor, pgraph, source, target) {
    var graphS = editor.storage.graph;
    var graph = pgraph.graph;
    var movedNodes = {};
    var commandList = [];
    var delta;
    var sourceEdge = graph.getEdge(source);
    var targetNode = graph.getNode(target);
    var sourceHead = graph.getHead(sourceEdge);
    var sourceTail = graph.getTail(sourceEdge);
    var leftEdge = graph.getEdge(targetNode.left);
    var targetLeft = graph.getHead(leftEdge);
    var dims = findLedgeFromOrigin(
    	graph,
    	sourceTail.id,
    	targetLeft.id
    );
    if (dims.y > targetNode.y) {
        dropDown(
        	pgraph,
        	targetNode,
        	dims.y,
        	movedNodes
        );
    }
    dims = findLedgeFromOrigin(
    	graph,
    	sourceTail.id,
    	targetLeft.id
    );
    if (dims.x > targetNode.x) {
        delta = dims.x - targetNode.x;
        pgraph.moveRight(
        	target,
        	delta,
        	movedNodes
        );
    }
    var newHor = deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    deleteNodeAndUp(
    	pgraph,
    	sourceEdge.tail,
    	newHor
    );
    var sourceY = sourceHead.box.bottom + Config.METRE;
    if (sourceY > targetNode.y) {
        dropDown(
        	pgraph,
        	targetNode,
        	sourceY,
        	movedNodes
        );
    }
    if (sourceHead.x == targetNode.x) {
        
    } else {
        delta = targetNode.x - sourceHead.x;
        pgraph.moveRight(
        	sourceHead.id,
        	delta,
        	movedNodes
        );
    }
    drill(
    	pgraph,
    	sourceHead.x,
    	sourceHead.box.bottom,
    	targetNode.y,
    	movedNodes
    );
    delete movedNodes[sourceTail.id];
    var commands = {};
    makeCommonWidth(
    	editor,
    	pgraph,
    	sourceHead.id,
    	target,
    	movedNodes,
    	commands
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    commandList = commandList.concat(
    	Utils.objectValues(commands)
    );
    var bridge = generateId(editor.storage);
    pushInsertDown(
    	commandList,
    	bridge,
    	sourceHead.id,
    	target
    );
    return commandList;
}

function topOuterCorner(editor, pgraph, source, target) {
    var graph = pgraph.graph;
    var movedNodes = {};
    var commands = {};
    var delta;
    var sourceEdge = graph.getEdge(source);
    var targetNode = graph.getNode(target);
    var sourceTail = graph.getTail(sourceEdge);
    var sourceHead = graph.getHead(sourceEdge);
    var dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	target
    );
    if (dims.y > targetNode.y) {
        dropDown(
        	pgraph,
        	targetNode,
        	dims.y,
        	movedNodes
        );
    }
    dims = findLedgeDimensions(
    	graph,
    	sourceTail.id,
    	target
    );
    if (dims.x > targetNode.x) {
        delta = dims.x - targetNode.x;
        pgraph.moveRight(
        	target,
        	delta,
        	movedNodes
        );
    }
    if (sourceTail.x == targetNode.x) {
        
    } else {
        delta = targetNode.x - sourceTail.x;
        pgraph.moveRight(
        	sourceTail.id,
        	delta,
        	movedNodes
        );
    }
    drill(
    	pgraph,
    	sourceTail.x,
    	sourceTail.y,
    	targetNode.y,
    	movedNodes
    );
    makeCommonWidth(
    	editor,
    	pgraph,
    	sourceTail.id,
    	target,
    	movedNodes,
    	commands
    );
    buildMoveCommands(
    	pgraph,
    	movedNodes,
    	commands
    );
    var commandList = Utils.objectValues(commands);
    deleteLiana(
    	editor,
    	graph,
    	sourceEdge,
    	commandList
    );
    var bridgeId = generateId(editor.storage);
    pushInsertDown(
    	commandList,
    	bridgeId,
    	sourceHead.id,
    	target
    );
    return commandList;
}

function transplantLiana(editor, prim) {
    var selected = editor.transplantSource;
    var socket = prepareSocketOp(editor, prim);
    var target = socket.id;
    if ((typeof socket.action) === "string") {
        console.log("trasplant not implemented: ", selected, target, socket.action);
    } else {
        addTrace(
        	"transplant liana",
        	[socket.name, selected, target]
        )
        console.log(socket.name)
        var item = editor.storage.graph.getItem(
        	selected
        );
        if (item.isLine) {
            
        } else {
            selected = item.up;
        }
        var pgraph = createPhysicalGraph(
        	editor.storage.graph,
        	editor.render
        );
        var commandList = socket.action(
        	editor,
        	pgraph,
        	selected,
        	target
        );
        if (commandList) {
            applyCommands(
            	editor,
            	commandList,
            	null
            );
        }
    }
}

function traverseDown(graph, nodeId) {
    var list = graph.getVerticalDown(nodeId);
    return Utils.listToSet(list);
}

function traverseHorizontal(graph, itemId) {
    var list = graph.getHorizontal(itemId);
    return Utils.listToSet(list);
}

function traverseRightSide(graph, start, leftX, bottomY) {
    var node;
    var result = [];
    var id = start;
    var direction = "down";
    while (true) {
        node = graph.getNode(id);
        result.push(node);
        if (((node.x < leftX) && (node.y > bottomY)) || (node.type == "address")) {
            break;
        }
        if (direction === "down") {
            if (node.right) {
                var rNode = graph.getNodeRightEx(node)
                if (rNode.up) {
                    id = null
                } else {
                    id = rNode.id
                    direction = "right";
                }
            } else {
                if (node.down) {
                    id = graph.getNodeDown(node);
                    direction = "down";
                } else {
                    if (node.left) {
                        id = graph.getNodeLeft(node);
                        direction = "left";
                    } else {
                        id = null;
                    }
                }
            }
        } else {
            if (direction === "right") {
                if (node.right) {
                    id = graph.getNodeRight(node);
                    direction = "right";
                } else {
                    if (node.down) {
                        id = graph.getNodeDown(node);
                        direction = "down";
                    } else {
                        id = null;
                    }
                }
            } else {
                if (direction === "left") {
                    if (node.down) {
                        id = graph.getNodeDown(node);
                        direction = "down";
                    } else {
                        if (node.left) {
                            id = graph.getNodeLeft(node);
                            direction = "left";
                        } else {
                            if (node.up) {
                                id = graph.getNodeUp(node);
                                direction = "up";
                            } else {
                                id = null;
                            }
                        }
                    }
                } else {
                    if (direction === "up") {
                        
                    } else {
                        throw "Unexpected switch value: " + direction;
                    }
                    if (node.left) {
                        id = graph.getNodeLeft(node);
                        direction = "left";
                    } else {
                        if (node.up) {
                            id = graph.getNodeUp(node);
                            direction = "up";
                        } else {
                            id = null;
                        }
                    }
                }
            }
        }
        if (id) {
            
        } else {
            break;
        }
    }
    return result;
}

function traverseUp(graph, nodeId) {
    var list = graph.getVerticalUp(nodeId);
    return Utils.listToSet(list);
}

function traverseVertical(graph, itemId) {
    var list = graph.getVertical(itemId);
    return Utils.listToSet(list);
}

function trimContent(cont) {
    cont = Utils.copyObject(cont) || makeCont("")
    var text = cont.txt || ""
    cont.txt = text.trim()
    var text2 = cont.txt2 || ""
    cont.txt2 = text2.trim()
    return cont
}

function turnInto(x, y, itemId) {
    var graph = self.storage.graph
    var item = graph.getItem(itemId)
    var available = getMindTypes()
    var i
    i = 0;
    while (true) {
        if (i < available.length) {
            
        } else {
            break;
        }
        var avItem = available[i]
        if (avItem.type == item.type) {
            available.splice(i, 1)
            break;
        }
        i++;
    }
    var menu = []
    var _ind21827 = 0;
    var _col21827 = available;
    var _len21827 = _col21827.length;
    while (true) {
        if (_ind21827 < _len21827) {
            
        } else {
            break;
        }
        var avItem2 = _col21827[_ind21827];
        var item = makeTurnIntoElement(
        	itemId,
        	avItem2
        )
        menu.push(item)
        _ind21827++;
    }
    showContextMenu(x, y - 30, menu)
}

function updateCanvasEdge(canvas, id, selection) {
    var render = canvas.render;
    var graph = canvas.graph;
    var edge = graph.getEdge(id);
    Items.eraseFromRender(render, edge);
    Items.renderItem(graph, render, edge, selection);
}

function updateCanvasSockets(canvas) {
    var old = canvas.sockets;
    canvas.sockets = {};
    var _ind3223 = 0;
    var _col3223 = old;
    var _keys3223 = Object.keys(_col3223); 
    var _len3223 = _keys3223.length;
    while (true) {
        if (_ind3223 < _len3223) {
            
        } else {
            break;
        }
        var prim = _keys3223[_ind3223]; var oldSocket = _col3223[prim];
        canvas.render.deleteItem(prim);
        insertCanvasSocket(
        	canvas,
        	oldSocket
        );
        _ind3223++;
    }
}

function updateDiagram(storage, command, isUndo) {
    var pers = storage.persistence;
    var fields
    if (isUndo) {
        fields = command.undo
    } else {
        fields = command.fields
    }
    var _ind17560 = 0;
    var _col17560 = fields;
    var _keys17560 = Object.keys(_col17560); 
    var _len17560 = _keys17560.length;
    while (true) {
        if (_ind17560 < _len17560) {
            
        } else {
            break;
        }
        var name = _keys17560[_ind17560]; var value = _col17560[name];
        storage[name] = value
        _ind17560++;
    }
}

function updateFreeNode(free, node) {
    var old = free.get(node.id);
    var _ind16737 = 0;
    var _col16737 = node;
    var _keys16737 = Object.keys(_col16737); 
    var _len16737 = _keys16737.length;
    while (true) {
        if (_ind16737 < _len16737) {
            
        } else {
            break;
        }
        var name = _keys16737[_ind16737]; var value = _col16737[name];
        old[name] = value;
        _ind16737++;
    }
}

function updateNode(render, graph, node) {
    var old = graph.getNode(node.id);
    var _ind15774 = 0;
    var _col15774 = node;
    var _keys15774 = Object.keys(_col15774); 
    var _len15774 = _keys15774.length;
    while (true) {
        if (_ind15774 < _len15774) {
            
        } else {
            break;
        }
        var name = _keys15774[_ind15774]; var value = _col15774[name];
        if (graph.nonUpdatable[name]) {
            Utils.throwError(
             "Field '" + name + "' cannot be updated.");
            break;
        }
        old[name] = value;
        _ind15774++;
    }
}

function visualDrag(dx, dy, visibleBox) {
    if ((self.readonly) || (!(self.dragOn))) {
        
    } else {
        self.render.clearGuides()
        if (gDragStartItem) {
            var pgraph = self.canvas.pgraph;
            var change = pgraph.physicalDrag(
            	dx,
            	dy
            );
            var _ind12156 = 0;
            var _col12156 = change.nodes;
            var _keys12156 = Object.keys(_col12156); 
            var _len12156 = _keys12156.length;
            while (true) {
                if (_ind12156 < _len12156) {
                    
                } else {
                    break;
                }
                var id = _keys12156[_ind12156]; var _ = _col12156[id];
                var node = pgraph.graph.getNode(id);
                self.changedNodes[id] = true;
                moveCanvasNode(
                	self.canvas,
                	id,
                	node.x,
                	node.y
                );
                _ind12156++;
            }
            var _ind12160 = 0;
            var _col12160 = change.edges;
            var _keys12160 = Object.keys(_col12160); 
            var _len12160 = _keys12160.length;
            while (true) {
                if (_ind12160 < _len12160) {
                    
                } else {
                    break;
                }
                var edge = _keys12160[_ind12160]; var _ = _col12160[edge];
                updateCanvasEdge(
                	self.canvas,
                	edge,
                	self.storage.selection.ids
                );
                _ind12160++;
            }
            updateCanvasSockets(self.canvas);
            drawDrakonGuides(
            	self.render,
            	pgraph.graph,
            	gDragStartItem,
            	visibleBox
            )
        } else {
            var free = self.canvas.free
            var _ind16841 = 0;
            var _col16841 = gDragItems;
            var _len16841 = _col16841.length;
            while (true) {
                if (_ind16841 < _len16841) {
                    
                } else {
                    break;
                }
                var id = _col16841[_ind16841];
                var item = free.get(id)
                var x = item.x + dx
                var y = item.y + dy
                moveCanvasNode(
                	self.canvas,
                	id,
                	x,
                	y
                );
                _ind16841++;
            }
            if ((gMoveAllPrim) && (gShouldMoveAll)) {
                gMoveAllPos.x += dx
                gMoveAllPos.y += dy
                
                render.moveItem(
                	gMoveAllPrim,
                	gMoveAllPos.x,
                	gMoveAllPos.y
                )
            }
            drawFreeGuides(
            	self,
            	visibleBox
            )
        }
    }
}


this.test = {

canDeleteItem: canDeleteItem,
insertSimpleItem: insertSimpleItem,
insertQuestion: insertQuestion,
deleteItem: deleteItem,
setItemText: setItemText,
selectItem: selectItem,
transplantLiana: transplantLiana,
leftInnerLine: leftInnerLine,
leftOuterLine: leftOuterLine,
leftOuterCorner: leftOuterCorner,
onOuterFloor: onOuterFloor,
onInnerFloor: onInnerFloor,
leftOuterLine: leftOuterLine,
leftInnerLine: leftInnerLine,
leftInnerLineEx: leftInnerLineEx,
rightLine: rightLine,
rightCorner: rightCorner,
leftOuterCorner: leftOuterCorner,
leftInnerCorner: leftInnerCorner,
topOuterCorner: topOuterCorner,
topInnerCorner: topInnerCorner,
leftInnerLine: leftInnerLine,
collapseBolt: collapseBolt,
expandBolt: expandBolt,
createCycle: createCycle,
detectInternalCycle: detectInternalCycle,
detectOuterCycle: detectOuterCycle,
toSilhouette: toSilhouette,
toPrimitive: toPrimitive,
onOuterSilFloor: onOuterSilFloor,
leftOuterCornerSil: leftOuterCornerSil,
renameBranch: renameBranch,
insertBranch: insertBranch,
shortCycleDown: shortCycleDown,
insertPath: insertPath,
insertItem: insertItem,
deletePath: deletePath,
findCycleStartCandidates: findCycleStartCandidates,
pasteBlock: pasteBlock,
toFront: toFront,
toBack: toBack,
setContent: setContent
};



function FakePersistence() {
	var self = this;
	
	self.add = function(item) {}
	self.remove = function(id) {}
	self.update = function(item) {}
	self.updateDiagram = function(name) {}
	self.persist = function() {}
}

buildFreeBuilders()
}
